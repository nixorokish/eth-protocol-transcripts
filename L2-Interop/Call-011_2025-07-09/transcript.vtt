WEBVTT

1
00:07:46.310 --> 00:07:47.010
Joshua Rudolf: Hey! Luke!

2
00:07:51.100 --> 00:07:52.360
oscar.morke ┃ Ledger: Hello, Joshua.

3
00:07:55.480 --> 00:07:56.560
Joshua Rudolf: Excuse me.

4
00:08:00.970 --> 00:08:01.809
Orest Tarasiuk (t1): Hey, guys.

5
00:08:03.400 --> 00:08:04.080
oscar.morke ┃ Ledger: Hello!

6
00:08:05.230 --> 00:08:06.270
Joshua Rudolf: I understand

7
00:08:10.350 --> 00:08:12.709
Joshua Rudolf: Birdie's been hanging out with Dunk right? A little bit.

8
00:08:13.750 --> 00:08:17.829
Joshua Rudolf: Yeah, we're actually Co working.

9
00:08:19.330 --> 00:08:21.630
Joshua Rudolf: Just got off a call with him. Nice. That's cool.

10
00:08:21.630 --> 00:08:22.610
Orest Tarasiuk (t1): Hi, Ed.

11
00:08:23.100 --> 00:08:23.880
Orest Tarasiuk (t1): Cool.

12
00:08:25.550 --> 00:08:29.460
Joshua Rudolf: I didn't realize that you guys were previously work colleagues.

13
00:08:30.130 --> 00:08:36.109
Orest Tarasiuk (t1): Yeah, yeah. 10 years ago, until 6 years ago, roughly.

14
00:08:36.370 --> 00:08:37.920
Joshua Rudolf: Yeah, nice. That's cool.

15
00:08:38.230 --> 00:08:39.559
Orest Tarasiuk (t1): Time flies.

16
00:08:39.710 --> 00:08:42.999
Joshua Rudolf: Yeah, especially in crypto.

17
00:08:43.740 --> 00:08:46.269
Orest Tarasiuk (t1): Yeah, this was before crypto, though, so time.

18
00:08:47.203 --> 00:08:48.136
Joshua Rudolf: Right.

19
00:08:49.070 --> 00:08:51.160
Orest Tarasiuk (t1): Even faster. How does we need

20
00:08:55.160 --> 00:09:00.980
Orest Tarasiuk (t1): Ian? Are you gonna be giving the same talk as Zubelin, or is it gonna be a revamp.

21
00:09:01.992 --> 00:09:04.590
Ian | Polymer Labs: Very similar, but a bridged version.

22
00:09:05.030 --> 00:09:10.769
Orest Tarasiuk (t1): Oh, yeah, great. I'm gonna tell my colleague I I liked it a lot. Yeah, it's a great talk.

23
00:09:10.770 --> 00:09:12.310
Ian | Polymer Labs: Thanks. Appreciate that.

24
00:09:14.310 --> 00:09:17.569
Ian | Polymer Labs: Had a lot of fun at Zoo, Berlin. It's a great event.

25
00:09:20.280 --> 00:09:21.660
Orest Tarasiuk (t1): Was excellent.

26
00:09:24.010 --> 00:09:30.229
Joshua Rudolf: Cool. We'll get started in a minute. Yeah, thank you. Ian and M. Team for joining. We'll have

27
00:09:30.730 --> 00:09:45.730
Joshua Rudolf: some brief presentations from each. And if it's okay with you guys, I may do a small audible on the agenda and start off with the privacy stuff. I don't think we'll spend a lot of time there. So hopefully, we can get through it relatively quickly. But yeah, may just start off with the

28
00:09:46.320 --> 00:09:53.060
Joshua Rudolf: the privacy 1st agenda item then, and then we'll go over to you, Ian. From there.

29
00:09:54.170 --> 00:09:54.990
Ian | Polymer Labs: Sounds good.

30
00:09:55.450 --> 00:09:57.690
Orest Tarasiuk (t1): Are you the 1st speaker, Ian.

31
00:09:59.440 --> 00:10:00.079
Joshua Rudolf: Like a second, now.

32
00:10:00.080 --> 00:10:01.300
Ian | Polymer Labs: I'll be second.

33
00:10:01.300 --> 00:10:01.920
Orest Tarasiuk (t1): Okay.

34
00:10:04.410 --> 00:10:06.690
Joshua Rudolf: We'll try to get to Ian in about 10 min.

35
00:10:08.630 --> 00:10:12.029
Joshua Rudolf: All right. Give me one second. Here.

36
00:10:17.750 --> 00:10:20.429
Joshua Rudolf: make sure everything's recording correctly

37
00:10:27.770 --> 00:10:36.379
Joshua Rudolf: cool. Okay, yeah. Welcome everybody to the L 2 interrupt working group. We have 3 agenda items today, starting off with

38
00:10:36.580 --> 00:10:40.050
Joshua Rudolf: a brief review and sort of

39
00:10:40.660 --> 00:11:00.779
Joshua Rudolf: yeah, just a overview on the wallet and privacy work from there. We have Ian from Polymer on native interrupt upgrade ability and then finishing up with M. Team from spire on based roll up and how this fits into the larger interrupt vision.

40
00:11:01.540 --> 00:11:13.273
Joshua Rudolf: So starting off with privacy, yeah, so just briefly touching on the topic of privacy and the experimental wallet that

41
00:11:15.946 --> 00:11:33.060
Joshua Rudolf: sorry that that folks from the Ef. Wonderland and buyer and others are working on. We shared a bit about this on the last call for anyone that that missed it. It can. You can review the recap or recording from the last call the Tldr is, we are working on an experimental wallet

42
00:11:33.060 --> 00:11:48.730
Joshua Rudolf: which is a fork of empire to help accelerate work around interopping privacy. Going forward, the wallet will have a larger privacy focus, which we believe is something quite critical and valuable to accelerate.

43
00:11:48.730 --> 00:12:13.008
Joshua Rudolf: There were some recent understandable questions or concerns maybe raised around. What exactly will this look like? How are we thinking about? Which privacy protocols to leverage? And just these kinds of things around? Okay, yes, like, I think many people here agree around privacy being an important thing, and the wallet being a valuable vehicle for it. But

44
00:12:13.460 --> 00:12:19.388
Joshua Rudolf: There's some path dependence here, and just some questions around, what is this actually going to look like? So

45
00:12:20.330 --> 00:12:42.770
Joshua Rudolf: we may have Vitalik joining us to share his thoughts. I'm not sure if he's here right now, Vitalik, if you are yeah, maybe unmute yourself and jump in. But otherwise I think we also have some folks from the Wonderland team here. Yes, so maybe. Yeah. Maybe anyone from Wonderland if you wanna start off and share your thoughts around the wallet and kind of latest thinking around privacy. There.

46
00:12:49.860 --> 00:12:51.060
Gori | Wonderland: Hey, everyone.

47
00:12:51.440 --> 00:13:16.949
Gori | Wonderland: I'm good afternoon to give you a brief summary for the ones who have not seen the previous one. The wallet will enable, in terms of privacy, private sense, and private receipts. How can you send funds to another wallet without showing either the sender nor the receiver? And how can you make that eat like with an amazing user experience? Right?

48
00:13:17.540 --> 00:13:22.209
Gori | Wonderland: For example, how do you share your wallet address like the stealth wallet address

49
00:13:22.710 --> 00:13:28.430
Gori | Wonderland: so that anyone can send money to it, and then it aggregates to your real

50
00:13:28.790 --> 00:13:33.869
Gori | Wonderland: private deposit address without people being able to link those 2 together.

51
00:13:34.490 --> 00:13:42.199
Gori | Wonderland: There is some protocols which are aiming to help expand privacy in the ecosystem, such as railgan and privacy pools.

52
00:13:42.470 --> 00:13:52.940
Gori | Wonderland: The goal of the wallet is not to enshrine any of those, but to create the privacy standards so that any privacy protocol can build on top of this

53
00:13:53.180 --> 00:14:00.249
Gori | Wonderland: SDK, that the wallet will integrate. Yes, Tldr of the SDK,

54
00:14:00.570 --> 00:14:06.580
Gori | Wonderland: it's literally the heart and soul of what we're doing. Yes, the wallet.

55
00:14:06.640 --> 00:14:30.839
Gori | Wonderland: like literally. It's the whole value of the kohaku wallet that SDK our aim is to move the ecosystem forward and to get wallets like Metamask, Ravi, Okx, and many others to integrate this this SDK and actually integrate privacy in an easier way. If they would like to do it right now, it'd be nearly impossible or very, very, very hard.

56
00:14:31.020 --> 00:14:33.190
Gori | Wonderland: So we want to make it easy.

57
00:14:33.310 --> 00:14:40.650
Gori | Wonderland: and to display the capabilities of that SDK, we will have the wallet prototype, which is the fork of buyer.

58
00:14:42.460 --> 00:14:47.240
Gori | Wonderland: Did I miss anything, Josh, that you want to share or scale it. You want to add something.

59
00:14:47.770 --> 00:14:48.960
Joshua Rudolf: No, I think you covered it.

60
00:14:49.874 --> 00:14:52.340
Joshua Rudolf: Yes, Kelly, or anyone else want to jump in.

61
00:15:01.860 --> 00:15:16.370
Skele | Wonderland: I can take the question from Frankie, though what standards are needed. So we need a few things. The most important one is address servation. So for you to be able in an uninteractive way, find the

62
00:15:16.560 --> 00:15:21.779
Skele | Wonderland: let's say, private key or secret that you will use to deposit for another person.

63
00:15:22.772 --> 00:15:25.210
Skele | Wonderland: Do you see

64
00:15:25.640 --> 00:15:33.100
Skele | Wonderland: something that we are working with? And it's similar to self addresses, as you know it, there is also the standard of how do you

65
00:15:33.350 --> 00:15:49.529
Skele | Wonderland: communicate that secret to the receiver, for example, hey, I created this secret for you. How do you find that you now have an increase, or a new note or a new private balance. And then there is a more

66
00:15:49.700 --> 00:16:00.390
Skele | Wonderland: boring standard, which is Apis, and how would does the wallet actually communicate with these privacy protocols

67
00:16:01.050 --> 00:16:15.290
Skele | Wonderland: which is not so fancy. But it's something that we need to standardize as well for the SDK, and that's mainly it. We do have some components of chain regarding indexing and how to be able to

68
00:16:15.590 --> 00:16:29.350
Skele | Wonderland: as privately as possible, not leak information when you're trying to find your secrets. But yeah, that's mainly it. We'll have more. We have some details on the address reservation. We can share a document with you guys right now on the chat.

69
00:16:36.160 --> 00:16:39.040
Joshua Rudolf: Thanks, Cyke. Did you wanna jump in.

70
00:16:45.440 --> 00:16:46.349
cyp | status.network: That's for me.

71
00:16:46.490 --> 00:16:47.960
Joshua Rudolf: Yes. Sorry. Yeah.

72
00:16:47.960 --> 00:16:48.720
cyp | status.network: Awesome.

73
00:16:49.801 --> 00:16:51.858
cyp | status.network: Cool. Yeah, hey? Hey? Everyone.

74
00:16:52.860 --> 00:16:55.721
cyp | status.network: so real quick. I just wanted to

75
00:16:56.310 --> 00:17:00.209
cyp | status.network: to kind of give you a quick update on what we've been building so far.

76
00:17:00.810 --> 00:17:12.495
cyp | status.network: I think it's kind of relevant to to our call. I I posted very quickly on the chats group. I think last week about that. So yeah, it's mostly related to to privacy.

77
00:17:13.210 --> 00:17:39.800
cyp | status.network: what we are doing now is within service network. So service network is L, 2, based on the linear stack. We do gases, transactions. Natively meaning. We like, anyone can submit pre-transactions. We implement a spam protection backed by airline. So Zkp to guarantee that you're not spamming the network

78
00:17:41.400 --> 00:17:42.290
cyp | status.network: and

79
00:17:42.600 --> 00:17:54.400
cyp | status.network: we also have studies as an app right, like the the Og wallet. And so the goal now is to implement more privacy into what we're building. And

80
00:17:54.984 --> 00:18:06.795
cyp | status.network: one of the cool aspects of gases transactions is that it's re-anonymizes the wallets because you can basically submit transactions from wallet that has 0 gas

81
00:18:07.620 --> 00:18:26.740
cyp | status.network: And so it's not like with all the different privacy solutions that are currently implemented, where you always need to phone somewhere every layer, a vendor, something that will kind of take charge of that, and so that in the end it kind of links to other wallets, and and for the anonymity

82
00:18:27.140 --> 00:18:34.710
cyp | status.network: of of the the wallet, it's not very good. So we've got less transactional actions we can really have, like a pretty pretty good anonymity set

83
00:18:35.020 --> 00:19:00.321
cyp | status.network: in the end. And and so we're working now with relgan to implement their solution at the kind of base layer on the L 2 meaning that from the studies app and from any app that will be built on studies network you'll be have. You'll have the choice to either go private or not.

84
00:19:00.920 --> 00:19:20.939
cyp | status.network: And so it's very early still. But just like I, I wanted to to kind of get you guys feedback or like, at least let you know that. Yeah, we're working on that direction where we want to have private transactions and private app interactions built in at the wallet level, but also directly on the chain as well.

85
00:19:27.390 --> 00:19:33.340
cyp | status.network: And by the way, linear. So we are based on the linear stack. So linear is also

86
00:19:33.520 --> 00:19:53.219
cyp | status.network: working with us on that and they are currently implementing relevant for the Metamask cards. And so the goal is basically to also have it implemented. At the Metamask level. We are. We're not there yet. But yeah, it's it's going to to be

87
00:19:53.470 --> 00:19:58.239
cyp | status.network: we. We're working on right now. So probably in the next next few months we'll have some something to show.

88
00:20:03.660 --> 00:20:04.506
Joshua Rudolf: Awesome thanks.

89
00:20:09.780 --> 00:20:12.169
Joshua Rudolf: Cool anything else on this topic.

90
00:20:16.730 --> 00:20:20.389
cyp | status.network: Try our test nets. It's free. You don't have to reach.

91
00:20:22.450 --> 00:20:23.720
Joshua Rudolf: So that was good.

92
00:20:27.520 --> 00:20:32.839
Joshua Rudolf: Cool, well, if nothing else on privacy, we can move on to the next agenda. Item.

93
00:20:34.350 --> 00:20:36.620
Joshua Rudolf: I will hand it over to you. Ian.

94
00:20:37.170 --> 00:20:40.109
Ian | Polymer Labs: Thanks. Let's see if I can share my screen. I haven't used.

95
00:20:40.110 --> 00:20:44.023
Joshua Rudolf: Oh, yeah. One second, I gotta let you. Okay, there you go.

96
00:20:55.840 --> 00:20:57.379
Ian | Polymer Labs: See if this works.

97
00:21:05.470 --> 00:21:09.570
Ian | Polymer Labs: Sorry I've got to adjust my permissions, my computer quick.

98
00:21:44.540 --> 00:21:46.459
Ian | Polymer Labs: I'll have to leave and rejoin.

99
00:21:46.780 --> 00:21:48.490
Joshua Rudolf: I also might be able to share.

100
00:21:48.870 --> 00:21:50.970
Joshua Rudolf: Yeah, good, much. Second 10.

101
00:21:50.970 --> 00:21:54.679
Joshua Rudolf: Hey, Mac? OS tells you to restart. I think you don't need to.

102
00:21:55.170 --> 00:21:56.370
Joshua Rudolf: Yeah. I was gonna say.

103
00:21:57.560 --> 00:21:59.139
Orest Tarasiuk (t1): Only you've had the same experience.

104
00:21:59.140 --> 00:22:00.540
Joshua Rudolf: Yeah, exactly.

105
00:22:00.540 --> 00:22:01.330
Orest Tarasiuk (t1): Yeah.

106
00:22:06.480 --> 00:22:08.840
Joshua Rudolf: We'll give them a minute. There we go!

107
00:22:09.330 --> 00:22:10.199
Ian | Polymer Labs: Here we go.

108
00:22:10.330 --> 00:22:13.950
Ian | Polymer Labs: Think this will work. Now, okay.

109
00:22:13.950 --> 00:22:14.630
Joshua Rudolf: Yep.

110
00:22:14.810 --> 00:22:15.610
Orest Tarasiuk (t1): 88.

111
00:22:16.560 --> 00:22:18.670
Ian | Polymer Labs: Cool. See if I can.

112
00:22:19.710 --> 00:22:20.530
Ian | Polymer Labs: Busy.

113
00:22:26.010 --> 00:22:27.878
Ian | Polymer Labs: Alright, thank you. Sorry about that.

114
00:22:28.860 --> 00:22:40.709
Ian | Polymer Labs: So yeah, today, I want to talk about something which I spoke about at Zoo, Berlin, and I think I spoke to a number of you like separately as well about this topic. And so sort of the basis of this topic is

115
00:22:41.340 --> 00:22:48.580
Ian | Polymer Labs: assuming, like the foundational axiom, is that you know, eventually we do want to achieve native interop between roll ups

116
00:22:48.770 --> 00:22:58.769
Ian | Polymer Labs: and by native interrupt. What I mean is interrupt. That's verified as part of the l 1 state transition function, you know, under l 1 consensus. And this is achieved.

117
00:22:59.200 --> 00:23:03.309
Ian | Polymer Labs: It's achieved using the outputs that roll-ups settle to the l. 1,

118
00:23:03.730 --> 00:23:05.740
Ian | Polymer Labs: you know, looks somewhat like this.

119
00:23:06.010 --> 00:23:08.640
Ian | Polymer Labs: And then, of course, other roll-ups can absorb

120
00:23:09.210 --> 00:23:25.849
Ian | Polymer Labs: those outputs into their own execution environment. Whether this is done using l. 1 s. Load or l 1 origin. Once they have these roots inside their execution environment, you can make arbitrary, you can verify arbitrary claims about the counterparty. L. 2. Inside of that L 2 execution environment.

121
00:23:26.010 --> 00:23:30.070
Ian | Polymer Labs: So that looks great in theory. But there's this problem in practice that

122
00:23:30.240 --> 00:23:56.040
Ian | Polymer Labs: actually, every roll up basically settles somewhere different and in a different format. So it's very heterogeneous. The the layout of the outputs on the l 1. And so it becomes quite difficult actually to deploy a contract on some l. 2 that is configured in a way that it can locate and make sense of the settled outputs of all of the other counterparty. L. 2 s.

123
00:23:56.190 --> 00:24:10.040
Ian | Polymer Labs: Essentially, what you need to do is you need to configure. This verifier contract with a mapping of chain ids to a location in a format that that the L 2 corresponding to that chain id uses when it settles.

124
00:24:10.300 --> 00:24:12.380
Ian | Polymer Labs: and you know you could do this

125
00:24:12.430 --> 00:24:27.320
Ian | Polymer Labs: with your verifier contract upfront. You can figure it, configure it with this information. But roll ups are not ossified. So what happens when you know the one in the middle here changes it upgrades from, let's say, OP stack bedrock to OP Stack Canon.

126
00:24:27.360 --> 00:24:48.209
Ian | Polymer Labs: Its settlement location, its settlement format. It changes in that process, or, what happens when a new L 2 enters the system, and we want to also connect with that. L. 2. Well, we need to configure it as well. And so what this sort of necessitates in practice is that you have to have some upgradability in your native interrupt verifier contracts

127
00:24:48.380 --> 00:24:56.259
Ian | Polymer Labs: because ethereum is upgrading. The L. 2 s. Are upgrading, and so these verifier contracts have to be able to upgrade in order to maintain parity with

128
00:24:56.540 --> 00:24:58.750
Ian | Polymer Labs: the system as as it evolves.

129
00:24:59.271 --> 00:25:07.719
Ian | Polymer Labs: And this is obviously a bit of a problem, because you don't actually achieve native interop right? If you have a multi sig somewhere in the system that

130
00:25:08.060 --> 00:25:13.530
Ian | Polymer Labs: allows for upgrades to occur. So is native interrupt, even

131
00:25:13.700 --> 00:25:25.679
Ian | Polymer Labs: possible like, can we actually even achieve this in practice without a fully ossified system. We know without effectively having sharding and I think that you know, I think this is something that everybody

132
00:25:26.020 --> 00:25:39.040
Ian | Polymer Labs: has come up across. You know various teams have been working on native interrupt protocols, such as bases standard and and arbitrum's broadcast standard and so anybody who's been working on a native interrupt

133
00:25:39.410 --> 00:25:42.219
Ian | Polymer Labs: protocol has surely ran into this

134
00:25:42.630 --> 00:25:47.140
Ian | Polymer Labs: and I think you know, at a high level, there's basically like 3 ways that you address this.

135
00:25:47.720 --> 00:25:51.930
Ian | Polymer Labs: Either we standardized settlement

136
00:25:52.130 --> 00:26:05.007
Ian | Polymer Labs: which probably never gonna happen. You know, you can have standardization within a cluster, which is this is kind of an argument actually in favor of like in cluster, interrupt, because part of what you solve in in cluster interrupt is this problem

137
00:26:05.350 --> 00:26:12.650
Ian | Polymer Labs: But you still need to interrupt between clusters. Right? I don't think anybody. I think everybody on this call will agree that we're not all going to agree on a single

138
00:26:12.700 --> 00:26:30.570
Ian | Polymer Labs: roll up stack to use, but perhaps within different roll-up stacks is a way of standardizing settlement logic such that it is shared across otherwise divergent stacks, and of course, native roll-ups are another opportunity. Where this type of

139
00:26:30.600 --> 00:26:50.959
Ian | Polymer Labs: the settlement logic could be standardized as part of a native roll up, it could actually be enforced through the native rollup precompiles potentially. So, I think that's something to consider. But then, again, you still have the problem where not every roll up is going to convert to a native roll up, and so you still have to have a way of bridging between the native roll-up cluster and other clusters.

140
00:26:51.581 --> 00:27:01.200
Ian | Polymer Labs: So another way of approaching this would be to push the upgrade ability down to the l 1 and have somewhat of like a configuration or registry contract on the l. 1

141
00:27:01.648 --> 00:27:06.909
Ian | Polymer Labs: and then you can actually use the l 1 view, or you know the l. 1 origin or l. 1 s. Load to

142
00:27:07.090 --> 00:27:11.498
Ian | Polymer Labs: approve updates to your routing in your system.

143
00:27:12.420 --> 00:27:29.220
Ian | Polymer Labs: just based on changes in the configuration that occur in one place on on the l. 1. In this l. 1 contract you can absorb those changes into the L. 2 s. To affect those changes in the L. 2 contracts, and the advantage here is that by pushing the upgradeability down into one place on the l. 1

144
00:27:29.330 --> 00:27:31.499
Ian | Polymer Labs: well, it's easier to maintain, like a

145
00:27:31.630 --> 00:27:50.520
Ian | Polymer Labs: a better, like a higher Quality Security Council to to, you know, to manage the upgrades of this single contract on the l 1 you could potentially have, like a consortium of like people from every major roll up who are part of this Security Council for this like shared registry contract on the l. 1,

146
00:27:51.220 --> 00:27:54.099
Ian | Polymer Labs: or you could even take it a bit further.

147
00:27:54.350 --> 00:28:02.090
Ian | Polymer Labs: You could put it under the purview of the l 1 fork choice rule where this is like a system contract that gets upgraded, only, you know, during hard forks.

148
00:28:02.340 --> 00:28:16.869
Ian | Polymer Labs: or, you know, according to the l. 1 validators, and that would truly put this under this. Would that would truly make this. Allow this to be a native interop in the sense that it would be the l 1. Validators that are controlling this routing information.

149
00:28:17.295 --> 00:28:20.719
Ian | Polymer Labs: And then, you know a 3, rd and it's worth mentioning here that

150
00:28:21.140 --> 00:28:33.019
Ian | Polymer Labs: this has some overlap with the on chain config work that's being led by Marissa, which is focused on the Erc 7, 7, 8, 5 right now. I think you know, potentially we could

151
00:28:33.550 --> 00:28:39.590
Ian | Polymer Labs: add this information on top of the other information that's already stored in that config contract.

152
00:28:39.880 --> 00:28:41.769
Ian | Polymer Labs: And then the 3rd approach.

153
00:28:42.030 --> 00:28:54.579
Ian | Polymer Labs: which is, I think, like the sexiest, best approach in theory, would be that every roll up sequencer in the same way that they should be absorbing the l. 1 state route into their execution. Environment.

154
00:28:54.780 --> 00:28:59.319
Ian | Polymer Labs: according to the l. 1 origin, or in order, in order to support the l 1 origin.

155
00:28:59.600 --> 00:29:06.099
Ian | Polymer Labs: they could absorb essentially all of the subtle outputs, the latest sub output for every other roll up that they're aware of

156
00:29:06.691 --> 00:29:13.738
Ian | Polymer Labs: as part of their State transition function, and this has the advantage that it reduces the level of

157
00:29:14.310 --> 00:29:22.249
Ian | Polymer Labs: the levels of Merkel the number of levels of Merkle proofs that you have to provide to prove a counterparty state, because

158
00:29:22.510 --> 00:29:52.130
Ian | Polymer Labs: if you do it, using the l 1 origin view, or you do it based on having. Yeah, if you do it based on the l 1 origin view, you 1st have to prove the settled L. 2 state inside of that l. 1 view, and then you prove your L. 2. State inside of that l. 2 state root that was in that output. But if you just absorbed the outputs directly into the L 2 execution environment, then you would only have to provide a single Merkle proof against the L. 2 state root that was absorbed into the L 2 execution environment.

159
00:29:52.170 --> 00:29:56.150
Ian | Polymer Labs: But I don't think this will work in practice, in part because

160
00:29:56.310 --> 00:30:20.489
Ian | Polymer Labs: some stacks when they settle, you know you don't actually store like the actual roots in storage you store like a hash of them or a commitment to them. And so it's not as simple as like reading from a location on the l. 1 you actually need to like, run a full node for the L. 2, or communicate with a full node for the L. 2. In order to get the Pre image for the hash that was settled to the l. 1. Because the actual.

161
00:30:20.590 --> 00:30:37.950
Ian | Polymer Labs: the actual l. 2 state route is not, you know, present in a storage slot on the l. 1. Instead, it's a hash that commits commits to an object that contains that state root. So that's actually all the slides I have prepared. And yeah, I kind of just wanted to stop this and leave it as like an open

162
00:30:38.030 --> 00:31:02.861
Ian | Polymer Labs: question for discussion. I'm curious what other people are thinking about this. Maybe this is like a little too far out. I know it doesn't really relate to our current priorities of, you know, improving. Interrupt ux immediately. Because this is a much further out problem. But you know, if the goal long term is to support native. Interrupt. Once, you know, once we have real time proving, etc, that has settlement times

163
00:31:03.310 --> 00:31:08.039
Ian | Polymer Labs: much lower than they are today. Then this is something that we should start thinking about. Now, in my opinion.

164
00:31:15.680 --> 00:31:19.549
Allan | Offchain Labs: Which of those options do you feel like is the most feasible, as of right? Now?

165
00:31:19.690 --> 00:31:32.320
Allan | Offchain Labs: I. 2, 2, feels like the best way to deal with the variety amongst roll ups, because one and 3 both just seem to have a lot of nuances for edge cases. But I'm curious which one you feel most optimistic about.

166
00:31:32.720 --> 00:32:02.234
Ian | Polymer Labs: I. I agree with your analysis there. And actually, we've already implemented like a version of this registry contract, and I should add that, like a lot of this is actually inspired by arbitrum's prover pointers. And in a way, this registry on the l. 1 or this configuration contract on the l. 1 can be thought of like a global prover pointer that has been pushed down to the l. 1. Instead of having to like, maintain different prover pointers inside of the L 2 execution environment. And I do think that like today, this is actually kind of the only way you can handle it.

167
00:32:02.990 --> 00:32:11.086
Ian | Polymer Labs: and yeah, I think the amount of standardization that would be required to handle it using the 1st or 3rd approach is probably not

168
00:32:11.630 --> 00:32:14.920
Ian | Polymer Labs: achievable, or I'm doubtful that it is.

169
00:32:17.240 --> 00:32:28.799
Allan | Offchain Labs: Got it. Yeah, that's helpful. And and and the the pattern was a little bit familiar with broadcaster. It makes a lot of sense. Especially if you can just bank on the l. 1 being the best place to go to get that information reliably.

170
00:32:29.110 --> 00:32:29.860
Ian | Polymer Labs: Yeah.

171
00:32:32.140 --> 00:32:33.419
Ian | Polymer Labs: Oh, thank you. Bristly.

172
00:32:57.500 --> 00:33:00.869
Joshua Rudolf: Cool. Well, thank you, Ian. Any other. Oh, yes, call them.

173
00:33:00.870 --> 00:33:04.990
Kalman Lajko: Do you? Do you plan to propose an Erc or

174
00:33:05.440 --> 00:33:08.170
Kalman Lajko: make this contract into an Erc? Maybe.

175
00:33:08.750 --> 00:33:13.130
Ian | Polymer Labs: I think I'm I'm kind of curious. What people think the best route forward is because.

176
00:33:14.200 --> 00:33:31.491
Ian | Polymer Labs: yeah, I don't. Wanna I guess I don't wanna spend time too much time writing a standard. If it's not something that people will actually like, roll up teams aren't actually going to adopt. So I think it's important that there's like some consensus arrived at ahead of time, so that we know that you know the the standard will actually

177
00:33:32.620 --> 00:33:35.949
Ian | Polymer Labs: it'll actually amount to something is, is my opinion.

178
00:33:36.652 --> 00:33:44.307
Ian | Polymer Labs: I think the pro. Probably the best way forward, and would be to, I think, roll it together with the the ongoing

179
00:33:45.587 --> 00:33:58.719
Ian | Polymer Labs: l. 1 chain config work that Marissa's leading and yeah, perhaps it'd be just a an addition or amend amendment to the existing Erc, or maybe another Erc as well.

180
00:34:02.350 --> 00:34:03.120
Kalman Lajko: Okay.

181
00:34:05.020 --> 00:34:09.560
Marissa Posner: Yeah, I can send the link to the group where we're start to chat about some things.

182
00:34:10.980 --> 00:34:11.630
Ian | Polymer Labs: Thank you.

183
00:34:26.860 --> 00:34:34.190
Ian | Polymer Labs: Yeah, I think that's valid question. You know. And like, yeah, the kind of the founding axiom right is that this is something that's worth

184
00:34:34.520 --> 00:34:41.570
Ian | Polymer Labs: pushing for. And I personally think that it is. But you know that's just my personal opinion.

185
00:34:45.670 --> 00:34:48.080
Allan | Offchain Labs: I think you could also make the case that the

186
00:34:50.800 --> 00:34:57.533
Allan | Offchain Labs: the relative size of a of a given cross chain. If it's just a a transfer, as the simplest use case.

187
00:34:58.680 --> 00:35:16.950
Allan | Offchain Labs: really plays a big part. In what different, especially intent, driven solutions, or even like native or off solutions you could use. If you have a very large amount, if you've got, you know 100 million that you want to move between base and arbitrum in either direction. Then there are few solvers. Or you know,

188
00:35:17.380 --> 00:35:32.049
Allan | Offchain Labs: well, capitalized intermediaries that are able to make that happen today via the routes that were, you know, most optimistic about that solve most use cases. So I I do like the idea of having something, albeit a bit slower, that could handle this in a more native way.

189
00:35:34.640 --> 00:35:42.670
Ian | Polymer Labs: Yeah, I agree. And I guess personally, at at Polymer we use a native route as a fallback for our faster route.

190
00:35:43.354 --> 00:35:46.890
Ian | Polymer Labs: So, you know, if our fast route goes down, you can still

191
00:35:47.600 --> 00:35:50.650
Ian | Polymer Labs: progress. Using the slower native row is the idea.

192
00:35:56.290 --> 00:36:06.229
Joshua Rudolf: Yeah, I just wanted to echo Alan and Ian there. My view is that it's an important part of the broader interrupt menu. So yeah. Excited to

193
00:36:07.430 --> 00:36:14.180
Joshua Rudolf: keep pushing on this and and see where it leads. And and Marissa and the A. Team at the F have been have been doing a lot of great work here as well.

194
00:36:21.830 --> 00:36:25.609
Joshua Rudolf: Cool. Yeah. Anything else on this topic.

195
00:36:26.950 --> 00:36:30.050
Joshua Rudolf: If not, we can move on to the final agenda. Item.

196
00:36:33.710 --> 00:36:38.839
Joshua Rudolf: Cool. Alright. I will hand it over to M. Team on base, roll ups and interrupt.

197
00:36:45.540 --> 00:36:46.909
Matthew mteam: Cool. Can you guys see my screen.

198
00:36:47.540 --> 00:36:48.840
Joshua Rudolf: Yes, perfect.

199
00:36:48.840 --> 00:36:53.114
Matthew mteam: Great. Yeah. So that was a pretty technical

200
00:36:54.130 --> 00:36:58.749
Matthew mteam: just conversation from Ann. And I really appreciate that. But this is a lot more kind of high level.

201
00:36:59.281 --> 00:37:19.830
Matthew mteam: I just want to give my my like summarized vision of how base roll-ups can fit into the interop story of ethereum which we've we've been talking about in these calls, but also how we can do that in like a more pragmatic way, like, I'm not going to talk about narrative here, or or value crew, or anything like that. I want to focus on

202
00:37:20.550 --> 00:37:22.490
Matthew mteam: kind of a more product mindset.

203
00:37:23.770 --> 00:37:30.560
Matthew mteam: So the the question I asked myself when I was making this presentation is what is what is interrupt to me. I think we have.

204
00:37:31.269 --> 00:37:37.979
Matthew mteam: all of us have kind of our own understandings of it. But the way that I look at it personally is that kind of as a user.

205
00:37:38.200 --> 00:37:42.160
Matthew mteam: Occasionally I want to move assets from one app to another that counts as

206
00:37:42.990 --> 00:37:58.920
Matthew mteam: as as interop for me. It's not so much a chain, I guess it is like in practice. But for me, if I have my tokens in one area and I want to use them with another app, it's not because I just had them sitting around. It's because I was using them with another application. So

207
00:37:59.090 --> 00:38:06.819
Matthew mteam: just the other day I was moving some tokens from Ave to base because there was more yield on base, and

208
00:38:07.580 --> 00:38:13.263
Matthew mteam: it wasn't because the instance of aave on ethereum was worse.

209
00:38:14.460 --> 00:38:16.749
Matthew mteam: it just wasn't my preference at the time, and so

210
00:38:17.190 --> 00:38:23.709
Matthew mteam: nothing about the chain was important for me. It was literally just the application and what each instance of the application could offer. There.

211
00:38:24.202 --> 00:38:30.790
Matthew mteam: The other part of interrupt that, I think, is perhaps like under represented in the

212
00:38:31.610 --> 00:38:37.180
Matthew mteam: in the conversation sometimes and and Joseph from Inc. Had a really great.

213
00:38:37.490 --> 00:38:51.669
Matthew mteam: really great presentation on this at Ecc is the idea of like composition of different actions among protocols. So we all know this is like being defi Legos. But just to expand on this. You can think of lots of different actions you might have. You could have a

214
00:38:51.920 --> 00:38:57.540
Matthew mteam: and you could have a swap, a deposit, a withdraw whatever

215
00:38:57.700 --> 00:39:12.630
Matthew mteam: you also just have a token. I think a token can be a representation of maybe like an Lp position, and moving that across a protocol and moving the these different representations across protocols with minimal friction, of course, is really powerful. So

216
00:39:13.290 --> 00:39:14.610
Matthew mteam: I think this is like

217
00:39:15.170 --> 00:39:29.973
Matthew mteam: to me. This is what like interrupt being solved means is that we can. I can move my assets from one app to another, and I can move my actions across protocols and kind of compose across them. So maybe I do a leverage long using liquidity for multiple domains.

218
00:39:31.010 --> 00:39:32.210
Matthew mteam: and the point of

219
00:39:32.380 --> 00:39:39.069
Matthew mteam: the kind of where base drops come in for me is, is doing this with like minimal, necessary friction. I think there's a certain amount of

220
00:39:39.768 --> 00:39:45.320
Matthew mteam: of kind of lock in that we have for having multiple chains that are not necessarily the same.

221
00:39:47.220 --> 00:39:52.010
Matthew mteam: But I see this as a a

222
00:39:52.330 --> 00:39:54.700
Matthew mteam: there's a lot we can do for

223
00:39:55.090 --> 00:40:01.010
Matthew mteam: run into those barriers. And so that's what I want to talk about for the rest of the presentation. But friction to me means like

224
00:40:01.300 --> 00:40:02.650
Matthew mteam: for developers.

225
00:40:02.790 --> 00:40:13.460
Matthew mteam: complexity of maybe doing message, mapping or integrating intense. It means like backwards compatibility. So like this. Ave on layer, one work with my lock and mint protocol.

226
00:40:14.000 --> 00:40:26.329
Matthew mteam: so on and so forth. And I think that's at the end of the day this ends up trickling up. And so we see complexity and friction for developers turning into delays for applications launching, and that that's friction for users.

227
00:40:26.450 --> 00:40:28.089
Matthew mteam: And I think we see

228
00:40:28.230 --> 00:40:43.359
Matthew mteam: personally, I think you see, a lot of this in wallets where a lot of complexity has been handed off to the wallets like Metamask, and thus we've seen some delays and kind of what I'd like to see from from wallets and kind of a user experience on that side.

229
00:40:45.660 --> 00:40:47.593
Matthew mteam: So yeah, it's like, get into it.

230
00:40:48.130 --> 00:40:51.180
Matthew mteam: base roll-ups, I think fit in in like 3 big ways.

231
00:40:51.290 --> 00:40:56.090
Matthew mteam: And then there's a few, maybe second order effects that I I want to keep thinking about.

232
00:40:57.240 --> 00:41:03.659
Matthew mteam: I kind of think of space robs at the most basic level as multiplying whatever ethereum. So if ethereum has

233
00:41:04.140 --> 00:41:06.119
Matthew mteam: fast slot time.

234
00:41:06.650 --> 00:41:19.250
Matthew mteam: base reps can can use that export, that sequencing, that that building pipeline into something more. But if ethereum has a negative negative aspects like a expected builder market then you have a

235
00:41:19.370 --> 00:41:22.820
Matthew mteam: you multiply that as well. So you're just giving that to more block space.

236
00:41:22.940 --> 00:41:24.906
Matthew mteam: there's there's pros and cons.

237
00:41:25.830 --> 00:41:47.540
Matthew mteam: The number. One thing that I personally think about is this idea of like a composability zone or an area, maybe a set of chains. That's that are synchronously composable between. There's, of course, there's different levels of this. Maybe you have crossing conduct calls. Maybe you don't but from like a most basic level, I think people, especially Justin, use the term like universal synchronous composability.

238
00:41:47.780 --> 00:41:55.990
Matthew mteam: Where you have ethereum layer. One includes all of the layer twos, all the layer 3, so on, so forth. They're all synchronously composable. I don't see this vision as being

239
00:41:56.320 --> 00:42:01.630
Matthew mteam: practical, because I think there's going to be differences in

240
00:42:02.330 --> 00:42:07.379
Matthew mteam: in how chains kind of express their preferences. But I do think that there are.

241
00:42:07.870 --> 00:42:13.350
Matthew mteam: There are certain places where a like technically composable zone will make a lot of sense. So.

242
00:42:13.530 --> 00:42:30.460
Matthew mteam: for example, if you have a layer 2, and you'd like to have sickness, Lee, composable layer threes, and you've built like a composable zone on top of these. Or maybe we just have a composability zone that doesn't include the layer one but does include a wide set of layer twos. I think there's there's a lot of

243
00:42:30.956 --> 00:42:48.609
Matthew mteam: possibilities there. But for me a base roll up is a is one way to to export the sequencing of maybe a centralized sequencer, or maybe a layer one, and that gets us potential for these these zones to form again, like coordinated by that sequencing aspect. I also think the

244
00:42:49.230 --> 00:42:52.290
Matthew mteam: maybe one of the big ones for me is like reducing friction

245
00:42:52.460 --> 00:42:54.799
Matthew mteam: in a couple of ways. I think

246
00:42:55.170 --> 00:43:03.367
Matthew mteam: this really starts to come out when you compare to asynchronous interop or or interop across chains that are very different.

247
00:43:04.320 --> 00:43:11.790
Matthew mteam: so for developers, the biggest one for me is like, if I'm attempting to engage with some

248
00:43:11.960 --> 00:43:14.550
Matthew mteam: some protocol in another chain, that's my goal.

249
00:43:14.670 --> 00:43:18.679
Matthew mteam: or get my users tokens from another chain into my app.

250
00:43:18.890 --> 00:43:28.450
Matthew mteam: Then there's a few different ways that I could. I could attempt to do this with the technology that exists right now. But what probably ends up happening is that it looks

251
00:43:29.130 --> 00:43:33.650
Matthew mteam: like strange to me, it looks unknown because I haven't seen maybe Async

252
00:43:33.890 --> 00:43:36.050
Matthew mteam: programming practices in solidity before

253
00:43:36.462 --> 00:43:40.419
Matthew mteam: and so this kind of complexity is just friction. And and maybe I mean

254
00:43:40.620 --> 00:43:46.719
Matthew mteam: for me, it's like, if I'm working in forge. And I I'm writing a smart contract, and I

255
00:43:47.560 --> 00:43:56.920
Matthew mteam: I'm so used to doing synchronous contract calls because everything's usually in the same chain, or you know at least these tools are built for that mindset that now we have this like disruption.

256
00:43:57.780 --> 00:44:02.429
Matthew mteam: If there's some asynchronicity there, and I'm not saying this is like insurmountable. I just think it's friction.

257
00:44:03.820 --> 00:44:10.809
Matthew mteam: I was thinking backwards. Compatibility is like a really underrated part of super super like

258
00:44:11.520 --> 00:44:18.330
Matthew mteam: interrupt focus team. Sometimes because we can develop like a great interrupt protocol. But I think it's

259
00:44:18.697 --> 00:44:23.240
Matthew mteam: it's really good to look at, like what we actually want to interrupt with. And for me personally, it's like

260
00:44:23.560 --> 00:44:25.110
Matthew mteam: pretty much the

261
00:44:25.250 --> 00:44:50.920
Matthew mteam: like, the big defi protocols on layer, one on a uniswap. And if there's you know these tokens? Are these contracts already written a lot of times, they're not upgradable and so maintaining backwards compatibility synchronous, asynchronous. Whatever with those is super important. And I think that basically, again, does not guarantee this, but has the potential to enable greater backwards compatibility with the contracts and protocols we know and love.

262
00:44:51.555 --> 00:45:02.629
Matthew mteam: I also think based routes are not like front end thing in all. In in many cases like there's there's still this, I hope, some form of chain abstraction or intent based

263
00:45:02.740 --> 00:45:10.619
Matthew mteam: routing on top of this. But I do think of of of base sequencing as potentially offering a way to do

264
00:45:10.730 --> 00:45:19.349
Matthew mteam: faster settlement of intense. For example. Maybe if you have a at base, roll up

265
00:45:19.530 --> 00:45:21.669
Matthew mteam: settles to ethereum. So it's a layer 2,

266
00:45:22.370 --> 00:45:30.500
Matthew mteam: and you have a another layer. 2. That's not based. Then interacting with the liquidity protocols, tokens whatever on this

267
00:45:30.800 --> 00:45:39.810
Matthew mteam: base layer 2 could be a lot simpler, because you already know what to expect when interacting with your end. Maybe you already have, like a solver market built up for that and so.

268
00:45:39.960 --> 00:45:48.380
Matthew mteam: you know, connecting these dots is is going to be a little bit easier for you again, especially if this is like a base rope that follows the consensus and finality of ethereum.

269
00:45:49.910 --> 00:45:58.880
Matthew mteam: I just wanna link to this, this page right here, where we've written a good bit about this aspire. Just kind of on the idea of visibility, and how we imagine

270
00:45:59.292 --> 00:46:04.409
Matthew mteam: it could be could be done for a base roll up, and then kind of what are some of the effects of that?

271
00:46:06.210 --> 00:46:08.489
Matthew mteam: So what are the trade-offs there. I think this is like

272
00:46:08.780 --> 00:46:13.950
Matthew mteam: everyone's mind kind of jumps to this when they hear the word base rob. And so I want to just address some of these real quick.

273
00:46:14.050 --> 00:46:15.600
Matthew mteam: I think the 1st one

274
00:46:16.440 --> 00:46:26.408
Matthew mteam: from from my perspective, like the biggest one, is just. There's been slow development, not only of baseballs, but also of dependencies like pre comps. Slow development and slow adoption

275
00:46:27.120 --> 00:46:32.569
Matthew mteam: zk has not been necessarily slower than expected, but it's still nominally

276
00:46:32.680 --> 00:46:35.800
Matthew mteam: relatively slow process of getting these things production ready.

277
00:46:37.640 --> 00:46:40.490
Matthew mteam: And then moving on. I think number 2 here is

278
00:46:40.650 --> 00:46:43.780
Matthew mteam: is maybe the hardest one to solve the layer one.

279
00:46:44.030 --> 00:46:47.050
Matthew mteam: and especially the block building. Pipeline just isn't ready for

280
00:46:47.820 --> 00:46:55.480
Matthew mteam: for for defi at a lot of levels. I think that kind of democratizing maximal mev extraction.

281
00:46:55.980 --> 00:46:56.900
Matthew mteam: So

282
00:46:57.290 --> 00:47:05.559
Matthew mteam: the calculated trade-off that you know core devs made, but unfortunately has the has some some second order effects. And so.

283
00:47:06.580 --> 00:47:19.659
Matthew mteam: hey, we've written more about this in this post here, but you can imagine that having a an auction on layer, one that's designed to extract value can make it difficult to run systems that are perhaps serving users

284
00:47:19.820 --> 00:47:25.160
Matthew mteam: that are that are expecting not to be front runner, to be sandwiched like they are in centralized sequence or layer twos.

285
00:47:25.370 --> 00:47:28.579
Matthew mteam: and so at spire. We've been doing a lot of layer 3

286
00:47:28.930 --> 00:47:49.530
Matthew mteam: like base layer threes on centralized sequencer layer twos. There's a lot of benefits that we've written about. But essentially, I just want to kind of expand the idea of a base roll up to. There's more composability zones than the original concept of like universal ethereum, synchronous composability. And maybe these sets join eventually. But I

287
00:47:49.650 --> 00:47:59.719
Matthew mteam: for now I imagine that there's like these tighter knit areas that maybe don't include the layer one right now, just because of again, that extractive sequencing market costs block times, etc.

288
00:48:01.120 --> 00:48:02.420
Matthew mteam: I also want to talk about

289
00:48:02.860 --> 00:48:17.659
Matthew mteam: maybe a less obvious thing, which is the complex cost and fee structure, not necessarily not trying to say that based offs are necessarily more expensive than a centralized sequencer up, but designed poorly and especially designed naively.

290
00:48:17.970 --> 00:48:22.560
Matthew mteam: you will run into a lot of complexity issues. So if you're

291
00:48:22.850 --> 00:48:32.209
Matthew mteam: if you're writing anything that interacts with layer one. Of course you're going to need some some way to pass the fees on to the layer. 2 exactor

292
00:48:32.605 --> 00:48:38.669
Matthew mteam: but if you're if you don't have a single sequencer, and like a place to conveniently do this, it can result in.

293
00:48:39.110 --> 00:48:40.649
Matthew mteam: It can result in a mess. So

294
00:48:41.640 --> 00:48:57.830
Matthew mteam: I believe in most, if not all, OP stack roll ups the the layer. 2 data fee is passed on to users. But it's kind of like taken out of their account instead of a fee that they pay directly. And so the this just additional complexity

295
00:48:57.950 --> 00:49:01.559
Matthew mteam: is the kind of thing you would see on base roll ups. I think

296
00:49:02.130 --> 00:49:07.620
Matthew mteam: this is not unsolvable, and especially when we start to just reduce cost.

297
00:49:07.800 --> 00:49:21.089
Matthew mteam: I guess, gas using layer one. It's like a higher gas limit. This becomes like a lot more straightforward. But again, like, whenever you have, like, a more distributed, decentralized sequencer or proposer layer, you're going to run into these types of complexity issues.

298
00:49:21.660 --> 00:49:26.829
Matthew mteam: Yeah, in summary, just wanna make a few statements here. I think base reps are one option for interop

299
00:49:27.340 --> 00:49:33.400
Matthew mteam: or non-based shared sequencing but they are unique. I think they have some properties that

300
00:49:34.200 --> 00:49:38.700
Matthew mteam: we yeah, we aren't gonna get anywhere else. And we aren't going to be in production.

301
00:49:39.782 --> 00:49:43.299
Matthew mteam: They also offer you can have like a moonshot, I think.

302
00:49:43.730 --> 00:49:51.799
Matthew mteam: like I I wouldn't put it as like a plan a for ethereum wide. Interrupt but more of like a. If this works

303
00:49:52.150 --> 00:49:54.280
Matthew mteam: with things like maybe a native roll up

304
00:49:55.460 --> 00:50:00.000
Matthew mteam: it becomes a part of this. Then we have a we have a

305
00:50:00.160 --> 00:50:09.160
Matthew mteam: a way that could be way better than what we expected for could get a lot closer to like the execution. Sharding roadmap that it's been talking about for a while.

306
00:50:09.650 --> 00:50:28.139
Matthew mteam: and then I also think that we're going to see a lot more like isolated experiments, like again, like base layer threes on layer twos. They can show early value. So I think we'll get to see like the solidity flow of doing a crossing contract call before it's interacting with a layer one. So I'm personally really excited about that. That's 1 of the things we're building as fire

307
00:50:28.660 --> 00:50:30.779
Matthew mteam: that should be coming soon.

308
00:50:31.170 --> 00:50:33.629
Matthew mteam: And then I also think that

309
00:50:34.620 --> 00:50:37.349
Matthew mteam: I said this a couple times. I think base reps are a

310
00:50:37.870 --> 00:50:47.161
Matthew mteam: are a part of a larger picture of interop. They're not the whole story by any means. And really the only thing they get you is this like coordinated sequencing layer, like she was saying to the same thing,

311
00:50:47.800 --> 00:50:51.120
Matthew mteam: and that's enough for starting to work on

312
00:50:51.320 --> 00:50:54.155
Matthew mteam: like an interrupt protocol on top of that.

313
00:50:54.700 --> 00:51:07.277
Matthew mteam: But you still you still need in our program. You still need all of the infrastructure that we've been talking about in these calls. So you know, chain, abstraction, intense are both things that I would find very valuable for a world that even if everything is based

314
00:51:08.740 --> 00:51:11.770
Matthew mteam: there is a potential world where

315
00:51:12.020 --> 00:51:14.780
Matthew mteam: a base and native roll up

316
00:51:14.900 --> 00:51:28.250
Matthew mteam: ends up, becoming essentially an execution shard of the layer, one execution zone. And we see these kind of like coprocessor. Evm environments being like the the simple, elegant way of

317
00:51:30.020 --> 00:51:35.489
Matthew mteam: of doing a roll up. And I think that's again. That's a potential future. But that would involve like a

318
00:51:35.760 --> 00:51:43.300
Matthew mteam: pretty major disruption in existing layer twos, and not something that I'm personally personally betting on right now.

319
00:51:44.230 --> 00:51:45.570
Matthew mteam: that's it. Any questions.

320
00:51:53.940 --> 00:52:10.490
Orest Tarasiuk (t1): So, Matthew, I think you know this concern of mine, but I wanted still to double down on what your vision is for the long term world in terms of the number of synchronous composability zones like, would you

321
00:52:10.790 --> 00:52:22.619
Orest Tarasiuk (t1): be like in the Justin Drake camp of saying, Hey, we can aim to have this, like academically pleasing single composability zone to rule them all.

322
00:52:24.805 --> 00:52:29.169
Matthew mteam: I think it's it's kind of an idealistic perspective.

323
00:52:29.912 --> 00:52:36.099
Matthew mteam: but still one worth like attempting. I mean the the big reason to consider ethereum.

324
00:52:36.640 --> 00:52:47.569
Matthew mteam: For like a big priority for your composability zone is because of the network effect that ethereum has but again, we talked about some practical things that make that difficult, and I think we will end up seeing

325
00:52:48.700 --> 00:52:55.300
Matthew mteam: you know whether I like it or not. We'll we'll start seeing composibility zones like synchronous composibility. Zones there don't include ethereum@firstst

326
00:52:55.710 --> 00:53:05.869
Matthew mteam: So eventually, yeah, I'd love to do that. I think that's always going to be a part of our mission at spire. But of course there's practicality things we have to think about. I

327
00:53:07.160 --> 00:53:09.880
Matthew mteam: I do think that there's a

328
00:53:10.930 --> 00:53:15.019
Matthew mteam: it's kind of like a hub and spoke model that we can imagine here. Or maybe there's a few

329
00:53:15.210 --> 00:53:28.019
Matthew mteam: large layer twos that have async interop with layer one but have their own composability zones with layer threes on top. I think something like base could be, you know, with our base vision could be something like a early prototype of that

330
00:53:28.130 --> 00:53:34.960
Matthew mteam: I'm not sure again, how this like evolves in in 5 to 10 year. Timelines.

331
00:53:35.110 --> 00:53:35.710
Matthew mteam: Good question.

332
00:53:39.650 --> 00:53:59.040
Orest Tarasiuk (t1): I'm worried. This is a bearish take, because it means we can't hope to have a million times more transactions right? If we keep this assumption of having a single entity to sequence the entirety of the execution zoning this will be the bottleneck.

333
00:54:00.260 --> 00:54:04.680
Orest Tarasiuk (t1): So like this only works like, we will have this ceiling somewhere.

334
00:54:04.980 --> 00:54:10.669
Orest Tarasiuk (t1): which is why, yeah, I think it's a bit of a limited view. Maybe.

335
00:54:11.890 --> 00:54:15.840
Matthew mteam: You mean, for just like a like a base rope

336
00:54:16.000 --> 00:54:19.060
Matthew mteam: on a layer, 2 kind of being constrained by the layer, one resources.

337
00:54:19.720 --> 00:54:47.290
Orest Tarasiuk (t1): Well, it doesn't matter a world where a single entity has the ultimate power over how transactions are sequenced, which is a fundamental precondition to having shared sequencing or base sequencing in particular, right? So like it feels safe from 1st principles. We don't really like. My gut thing is, we don't want to build towards a world where we only have a single execution zone.

338
00:54:50.370 --> 00:54:54.369
Matthew mteam: I again, I think it's kind of a

339
00:54:54.540 --> 00:54:59.109
Matthew mteam: misconception that for a for a base world to exist, you need all

340
00:54:59.688 --> 00:55:05.789
Matthew mteam: sequencing rights and all the right locks to be given to the same entity for for a slot.

341
00:55:07.000 --> 00:55:08.299
Matthew mteam: I read this article

342
00:55:08.910 --> 00:55:19.500
Matthew mteam: called base Reps can scale actually that that addresses like this exact question from from Christopher goes. And I think that the

343
00:55:20.170 --> 00:55:34.700
Matthew mteam: maybe the biggest thing here is like understanding that a base drop is not not guaranteeing that the in the context of ethereum, it's not guaranteeing that the layer one proposer their layer. One builder, has the right lock and is actually sequencing transactions and doing heavy lifting there, but rather that

344
00:55:34.830 --> 00:55:36.480
Matthew mteam: they have coordination

345
00:55:37.080 --> 00:55:50.239
Matthew mteam: with whoever's doing that. And so. And there's another part of this which is like the consensus and finality side. But the point is that the level of coordination that you need is not absolute, so it doesn't have to be. You give over your entire block. I think it's

346
00:55:50.530 --> 00:55:54.499
Matthew mteam: it's maybe quite dangerous to imagine a world where we have, like a super builder

347
00:55:54.870 --> 00:55:58.619
Matthew mteam: builds everything and I'd be I'd be quite against that

348
00:55:59.940 --> 00:56:18.060
Matthew mteam: But again, I I think perhaps we see a more distributed model. But again it's hard to know. I think@firstst Probably see there being enough enough room in like a centralized sequencer to to juice more out of it for other chains aspire. We have a model that can do base sequencing, but doesn't

349
00:56:18.400 --> 00:56:20.890
Matthew mteam: constrain the layer. 2 sequencer at all.

350
00:56:21.590 --> 00:56:25.087
Matthew mteam: That'll be that'll be coming out soon.

351
00:56:26.020 --> 00:56:28.510
Matthew mteam: and so I think that's yeah. It's kind of like a

352
00:56:29.440 --> 00:56:39.178
Matthew mteam: I mean, you're correct that like, if if we want a full synchronized ability, then we need to have the right lock to be down to one entity. It's just like the same chain at that point. That doesn't mean that the

353
00:56:39.730 --> 00:56:45.739
Matthew mteam: you can't do anything without that's that being set up.

354
00:56:45.740 --> 00:56:50.529
Orest Tarasiuk (t1): That would be a redefinition of what based based roll-up means right.

355
00:56:51.600 --> 00:56:59.489
Matthew mteam: Yes, so this is a this is a longer topic. I I don't think that the original definition of

356
00:57:00.670 --> 00:57:03.420
Matthew mteam: of base roll off from Justin is complete.

357
00:57:04.060 --> 00:57:12.620
Matthew mteam: And so I've been able to do define it in spires. Docs. Just put the link here as kind of an expansion of the idea.

358
00:57:12.750 --> 00:57:16.720
Matthew mteam: I, yeah, there's a few reasons why. But that's the

359
00:57:18.820 --> 00:57:20.720
Matthew mteam: the the big one is like the

360
00:57:20.990 --> 00:57:25.150
Matthew mteam: the way that recomp designs have evolved

361
00:57:25.300 --> 00:57:32.410
Matthew mteam: makes certainly, even from Justin have changed like, what a what a base role must mean. So there's kind of some self-conflicting things.

362
00:57:33.200 --> 00:57:37.730
Matthew mteam: let's yeah. I tried to lock it down a little bit more in that article. But I think, yeah, you're right, that

363
00:57:37.950 --> 00:57:42.759
Matthew mteam: going by that original definition, at least some interpretations of it, you'd have to have

364
00:57:43.500 --> 00:57:46.149
Matthew mteam: the the way you described earlier, with like a full right look.

365
00:57:49.920 --> 00:57:50.660
Orest Tarasiuk (t1): Thank you.

366
00:57:59.070 --> 00:58:21.090
Ahmad Bitar | Nethermind: So one thing I'm interested in asking Matthew about is the demo that spire showed about reading the base the base layers data or oracle data on the L 3 or or on the l, 2. Whatever on the roll up side. So what is your current approach from

367
00:58:21.847 --> 00:58:33.170
Ahmad Bitar | Nethermind: to to do so? Are you like implementing l. 1 l. 1 call or l 1 sload, or something like that, or what's your current approach?

368
00:58:34.140 --> 00:58:37.500
Matthew mteam: Yeah. Good question. Well, I have a lot more

369
00:58:37.820 --> 00:58:47.519
Matthew mteam: talks about this soon. We have some some stuff that's like, just in the review phase, and so I can definitely share those when that's out. But for now, like, I think, it's easiest to understand the

370
00:58:47.730 --> 00:58:50.040
Matthew mteam: the architecture as

371
00:58:51.200 --> 00:58:58.589
Matthew mteam: as collapsing all layer, 3 transactions into a single layer, 3 block, and then putting that on into a layer, 2 transaction.

372
00:58:58.700 --> 00:59:09.560
Matthew mteam: and then each layer 2. Transaction. It becomes part of the layer. 2 block, I should say. And so if you were to expand all of this, you'd have a super block and includes, like layer 2 and layer 3 transactions.

373
00:59:09.810 --> 00:59:16.130
Matthew mteam: Then what we do is we simulate that super block from like top to bottom, and every point that's

374
00:59:16.340 --> 00:59:20.300
Matthew mteam: crushing call is being made, and we have some like.

375
00:59:20.500 --> 00:59:24.660
Matthew mteam: at least with the interface for expressing that then the

376
00:59:24.950 --> 00:59:30.621
Matthew mteam: we just pretend that it's possible. So we say, if you're making a crushing call. Let's just implement it.

377
00:59:31.240 --> 00:59:37.110
Matthew mteam: on the let's run it against the the other chain state, I should say

378
00:59:37.300 --> 00:59:41.699
Matthew mteam: so. We have like a crushing simulator that can handle this. Then once we're done that we have this

379
00:59:41.900 --> 00:59:45.440
Matthew mteam: like, we know all of the all the borders, all the

380
00:59:45.600 --> 00:59:59.880
Matthew mteam: the the places that we're making crushing calls. So we know what to expect from the results. And we put those on chain into the layer. 2. With what we call priming transactions, that kind of preload state. So in the in the model that you mentioned before, of doing a

381
01:00:01.710 --> 01:00:20.299
Matthew mteam: doing a a layer, 3. Reading from the layer. 2, we'd have a special priming transaction like a system transaction for the layer. 3. That would load the state of like the expected result from that call into the layer. 3, and then the the actual layer. 3 transaction when it, when it's executed, could just read that state. And then we're

382
01:00:20.520 --> 01:00:21.180
Matthew mteam: okay

383
01:00:22.250 --> 01:00:42.319
Matthew mteam: during the settlement on the layer 2, which happens frequently because it's a base drop, we're verifying the that the call was actually correct. So if you're making a oracle read, you're gonna have to check that. The oracle actually reads what you told the layer. 3, it would read. So there's some level of prediction here, and then we have some alternate models for that. Eventually, it's not

384
01:00:42.690 --> 01:00:44.669
Matthew mteam: just reading your question from the chat. It's not

385
01:00:45.660 --> 01:00:51.379
Matthew mteam: the same as what Gwyneth is doing. There's no new precompile, and we don't change the State transition at all. We're just using

386
01:00:53.800 --> 01:00:58.449
Matthew mteam: some some tricks with the like proxying and aliases.

387
01:00:59.035 --> 01:01:00.399
Matthew mteam: But it's not.

388
01:01:01.510 --> 01:01:05.480
Matthew mteam: It's not dissimilar, either. It has some of the some of the same characteristics, for sure.

389
01:01:10.760 --> 01:01:11.510
Ahmad Bitar | Nethermind: Thanks.

390
01:01:24.090 --> 01:01:27.269
Joshua Rudolf: Anyone else any questions for M. Team.

391
01:01:33.950 --> 01:01:38.210
Joshua Rudolf: Thanks for sharing the presentation. Yeah, my quick. 2 cents for what it's worth. Not a

392
01:01:38.280 --> 01:01:54.720
Joshua Rudolf: particularly, I guess. Insightful comment. But yeah, to me, base roll ups are a no brainer in terms of exploration. Iteration. I think they've already delivered value on that front and pushed our thinking forward in many ways yourself, tyco team.

393
01:01:54.720 --> 01:02:09.769
Joshua Rudolf: I'm on Nethermind team, many others working on this. I think it's already had a yeah net. Positive outputs like you said. You know whether we call it a moonshot or something else. There's many things to still figure out around this. And where does this fit in? It's a, you know, maybe a bit

394
01:02:09.910 --> 01:02:22.340
Joshua Rudolf: of a more medium to long term effort. But yeah, I despite some of my questions or concerns. I'm I support. And it's it's been great to see. Yeah, you and others pushing this forward.

395
01:02:23.610 --> 01:02:31.089
Matthew mteam: Thank you. Yeah. I mean, I really appreciate that. I think there is a there's. There's like a

396
01:02:31.320 --> 01:02:43.493
Matthew mteam: maybe a notable thing about base reps is that there's other than Tycho. There's not a lot of large layer twos, or like established layer twos that are directly pursuing this model in the short term. And so I think

397
01:02:44.030 --> 01:03:01.239
Matthew mteam: and we had our, I think, sequencing call 17, where a bunch of big teams committed to eventually exploring this. But I think the the general consensus has been. Let's kind of wait and see how the layer one dependencies evolve and kind of. If we can do some further research here. So I think is definitely the pragmatic approach.

398
01:03:03.160 --> 01:03:04.209
Joshua Rudolf: Yeah. Makes sense

399
01:03:11.990 --> 01:03:15.030
Joshua Rudolf: cool. Well, we only have a couple of minutes left. Any other

400
01:03:15.510 --> 01:03:17.870
Joshua Rudolf: quick questions, feedback anything else for the group?

401
01:03:21.040 --> 01:03:23.369
Joshua Rudolf: If not. We can end things there.

402
01:03:27.240 --> 01:03:30.929
Joshua Rudolf: Cool. Thanks, everybody for joining, and we'll see you next time.

403
01:03:31.290 --> 01:03:32.050
Ian | Polymer Labs: Thanks. Josh.

404
01:03:32.540 --> 01:03:34.360
Joshua Rudolf: You. Bye, guys, thank you.

