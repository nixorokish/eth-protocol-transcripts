WEBVTT

1
00:04:37.830 --> 00:04:39.560
Toni Wahrstätter: Hello, everyone.

2
00:06:29.650 --> 00:06:35.230
Toni Wahrstätter: Perfect. Hello, everyone. Let's wait one more minute before we get started.

3
00:07:19.340 --> 00:07:20.310
Toni Wahrstätter: Great.

4
00:07:20.430 --> 00:07:23.789
Toni Wahrstätter: I think we're ready to go. I think we can start the stream.

5
00:07:25.900 --> 00:07:26.830
Pooja Ranjan: We are live.

6
00:07:29.780 --> 00:07:39.589
Toni Wahrstätter: Hello, everyone, and welcome to today's EAP7928 breakout call. It's the 11th breakout call, and it's 20… January 28 today.

7
00:07:40.670 --> 00:07:47.530
Toni Wahrstätter: So, looking at the agenda, let's start at the beginning, let me quickly post the agenda into the chat.

8
00:07:48.070 --> 00:07:50.040
Toni Wahrstätter: Such that everyone can have a look.

9
00:07:50.940 --> 00:07:55.970
Toni Wahrstätter: So the first two items were basically already discussed, at ACDT,

10
00:07:56.610 --> 00:08:01.470
Toni Wahrstätter: beginning of this week, but I think it would make sense to get an update from Stefan.

11
00:08:01.600 --> 00:08:05.429
Toni Wahrstätter: where we are at, there were some delays, as far as I know.

12
00:08:05.910 --> 00:08:07.650
Toni Wahrstätter: It would be great to have an update there.

13
00:08:08.720 --> 00:08:20.389
Stefan Starflinger: Yeah, sure. So, from the last ACDT, we decided to include a change that would remove the gas spent, I think, from the receipts.

14
00:08:20.600 --> 00:08:22.880
Stefan Starflinger: And,

15
00:08:23.190 --> 00:08:30.069
Stefan Starflinger: agreed that we would add it and delay the DevNet 2 until next week at the latest.

16
00:08:30.340 --> 00:08:33.500
Stefan Starflinger: Hopefully, we can get it running a little bit earlier.

17
00:08:35.440 --> 00:08:37.599
Stefan Starflinger: Yeah, it got changed.

18
00:08:38.190 --> 00:08:44.649
Stefan Starflinger: Exactly, but otherwise, also, maybe to summarize, maybe not everyone was in ACDT.

19
00:08:44.760 --> 00:08:59.020
Stefan Starflinger: from DevNet1, I think it went pretty well. We got most clients to be in agreement. We didn't have too many forks anymore, even with the EVM fuzzer running, so that's…

20
00:08:59.120 --> 00:09:13.830
Stefan Starflinger: very great, and we also got most of the clients syncing. There were still a few hiccups, but in general, it was working pretty well. And now, I hope that with DevNet2, we can look into the optimizations more.

21
00:09:13.990 --> 00:09:31.220
Stefan Starflinger: But, let's talk more about the spec clarification, because I think it would be great that we could tie everything of that up, and get everything in definite, too, of the open issues that we're gonna discuss next, and I think I've added everything to the spec sheet.

22
00:09:31.340 --> 00:09:33.469
Stefan Starflinger: From what we're gonna discuss next.

23
00:09:36.890 --> 00:09:38.670
Toni Wahrstätter: Perfect, thanks for the update.

24
00:09:38.900 --> 00:09:53.870
Toni Wahrstätter: So, just to… just to confirm, it looks like 7928 is not blocking anything regarding Def.2, and we are ready to go, basically, but, it's more about other smaller ERPs, like 7778, right?

25
00:09:56.840 --> 00:09:59.199
Stefan Starflinger: Yep, that's pretty much it.

26
00:10:00.390 --> 00:10:01.230
Toni Wahrstätter: Okay, here.

27
00:10:01.600 --> 00:10:04.119
Toni Wahrstätter: to echo what Jared is saying in the chat.

28
00:10:04.220 --> 00:10:12.270
Toni Wahrstätter: Regarding 7778, there was, recently a change that reverted it back to keeping the receipt as it is, so it should be…

29
00:10:12.560 --> 00:10:15.779
Toni Wahrstätter: done pretty soon, or pretty easy, I would say.

30
00:10:15.910 --> 00:10:16.860
Toni Wahrstätter: But let's see.

31
00:10:18.180 --> 00:10:23.989
Toni Wahrstätter: Great, so what is then… what was the latest, then? When will DevNet2 launch? Do we have a date for that yet?

32
00:10:24.880 --> 00:10:31.999
Stefan Starflinger: So, I'm aiming for next week, Wednesday, as the latest date, that I want to launch DevNet 2.

33
00:10:32.250 --> 00:10:42.709
Stefan Starflinger: And we'll see. I will be testing the clients regularly to see how we get on, but that would really, it would be great if we could launch earlier.

34
00:10:43.370 --> 00:10:51.849
Stefan Starflinger: I don't know how the development is going on, it would be great to get some client updates. I think the last update, from everyone that I got was last Wednesday.

35
00:10:53.630 --> 00:10:54.310
Toni Wahrstätter: Awesome.

36
00:10:55.290 --> 00:11:03.389
Toni Wahrstätter: Yeah, and this plays into the next topic, the client optimizations. We already saw in the Discord that Geff and Basu are both ready

37
00:11:03.710 --> 00:11:07.910
Toni Wahrstätter: Having the flags ready… to…

38
00:11:08.120 --> 00:11:13.150
Toni Wahrstätter: enable and disable the optimizations, for example, parallel execution, parallel…

39
00:11:13.350 --> 00:11:16.660
Toni Wahrstätter: batch I.O. and parallel state route computation.

40
00:11:16.910 --> 00:11:26.229
Toni Wahrstätter: Is there someone from the other clients that could provide an update on how far they are with regards to optimizations, and if they're

41
00:11:26.550 --> 00:11:29.490
Toni Wahrstätter: Will be flags to turn them on and off.

42
00:11:37.050 --> 00:11:51.109
Marc: Yeah, I can give an update for Nethermind. So working still on, parallel transaction execution, and state recommutation. I haven't started with the batch read yet.

43
00:11:51.340 --> 00:11:56.240
Marc: But yeah, just been focused on, preparing for the DevNet for now.

44
00:11:56.620 --> 00:11:57.300
Marc: Yeah.

45
00:12:04.270 --> 00:12:05.449
Toni Wahrstätter: Awesome, thank you.

46
00:12:06.140 --> 00:12:10.180
Toni Wahrstätter: Maybe someone from REF, or from… Aragon?

47
00:12:17.470 --> 00:12:19.450
Toni Wahrstätter: Otherwise, it's also not a problem.

48
00:12:20.360 --> 00:12:25.060
Toni Wahrstätter: If we don't get updates, that soon, because, importantly.

49
00:12:25.220 --> 00:12:31.590
Toni Wahrstätter: We need at least a few clients to do the benchmarks on top of a BAL.

50
00:12:31.850 --> 00:12:32.790
Toni Wahrstätter: Definite.

51
00:12:33.920 --> 00:12:38.129
Toni Wahrstätter: So, having GEF and base is already a good start, and I think we should then…

52
00:12:38.320 --> 00:12:42.160
Toni Wahrstätter: Get the benchmarking going as soon as possible, and for that.

53
00:12:42.640 --> 00:12:55.970
Toni Wahrstätter: Yeah, I mean, I will leave that to Jochen anyway, because he's the expert there, so I'm not sure how to best tackle that, but I would assume we will just have a mainnet shadow fork and do the benchmarking there.

54
00:12:56.800 --> 00:12:59.099
Toni Wahrstätter: Maybe Johan, if you're on the call.

55
00:12:59.400 --> 00:13:01.629
Toni Wahrstätter: You wanna say a few words to that?

56
00:13:03.380 --> 00:13:08.670
jochem-brouwer: Yeah, it depends, I think, on what exactly we want to test. I think we want to benchmark the,

57
00:13:09.080 --> 00:13:12.570
jochem-brouwer: the, the, the impact, what a block access list could have.

58
00:13:12.770 --> 00:13:17.900
jochem-brouwer: I also think this is… Also, like, about,

59
00:13:18.100 --> 00:13:22.509
jochem-brouwer: Because you could implement bulk access lists to just be consensus compliant.

60
00:13:22.780 --> 00:13:28.930
jochem-brouwer: And you could also implement the bulk accesses with the optimizations in there, so, like, parallel execution.

61
00:13:29.060 --> 00:13:31.809
jochem-brouwer: I think this is, at least something what we should do.

62
00:13:32.080 --> 00:13:35.580
jochem-brouwer: And what we would then do to benchmark this is we have to benchmark test.

63
00:13:35.920 --> 00:13:43.730
jochem-brouwer: But we will then benchmark the, the same client, which does not have these optimizations enabled.

64
00:13:43.900 --> 00:13:52.120
jochem-brouwer: Against the client which… sorry, the same client, against a client which has these optimizations enabled, to see what the impact of these, of the bulk access list is.

65
00:13:59.720 --> 00:14:01.339
Toni Wahrstätter: Perfect, yeah, sounds good.

66
00:14:01.790 --> 00:14:20.799
jochem-brouwer: And, oh yeah, so, and to mention, like, this should be done on, like, indeed a shadow fork of mainnet, because if we do this on empty state… oh, Karim is already asking this. So, what network is being used for this? We need a network with state, and that… the simplest way is to just do a shadow fork of mainnet, because if you would,

67
00:14:21.450 --> 00:14:37.519
jochem-brouwer: run these things on, like, empty state, or, like, consensus test-sized states, so, like, a very small pre-state, then you will see almost no influence at all, because the state reads are in there super fast, so you would not have any performance increase there.

68
00:14:37.630 --> 00:14:46.580
jochem-brouwer: So we need, like, a big network, and we can also see what we could also do is also release on top of BloatNet, so this is, like, a shadow fog off-mainnet.

69
00:14:46.710 --> 00:14:54.009
jochem-brouwer: But increased in size, to see also what the impact is if mainnet size, well, it will, of course, increase over the years.

70
00:14:54.210 --> 00:14:58.150
jochem-brouwer: But the impact is then, on even bigger size, sites.

71
00:14:58.910 --> 00:15:10.410
jochem-brouwer: And when do we expect to have the shadow fork ready? Well, I'm not sure if someone from… if PandaOps is here, Stefan is here, but I think this, the shadow fork can be done, instantly.

72
00:15:10.550 --> 00:15:13.490
jochem-brouwer: So we can just run it on top of a shadow fork.

73
00:15:13.690 --> 00:15:14.740
jochem-brouwer: Well, in an.

74
00:15:14.740 --> 00:15:26.949
Stefan Starflinger: Yeah, I think as soon as we have Definite2 running, we can focus on the optimizations, and when the optimizations are in, and they're working as expected, I think we can start the shadow work.

75
00:15:28.000 --> 00:15:35.069
jochem-brouwer: And maybe then a question, this DevNet 2, do we… is this planned to be a shadow focus of mainnet, or, like, an empty network?

76
00:15:35.490 --> 00:15:49.789
Stefan Starflinger: DevNet2 would be an empty network, but we would increase the gas limit to, I think, 150 million, so that we can also have a reasonable state after some time there, too.

77
00:15:50.690 --> 00:15:58.299
jochem-brouwer: Okay, that's it, that's fine. Yeah, like, the benchmarks are, of course, also somewhat different than just testing the networking aspects.

78
00:15:58.300 --> 00:16:07.540
Toni Wahrstätter: So we can also run these locally on, like, a shadow form to test the impact of state. Yeah, I'm not 100% sure about this, because even if we…

79
00:16:07.590 --> 00:16:20.169
Toni Wahrstätter: put the gas limit to a billion, we will not be able to generate, like, reasonable state within a short period of time. So I think we should focus those tests purely on

80
00:16:20.680 --> 00:16:25.920
Toni Wahrstätter: on Shadow Fork, or on BloatNet, especially BloatNet might be very interesting, because

81
00:16:26.080 --> 00:16:30.200
Toni Wahrstätter: It gives us already a glimpse into the future, basically.

82
00:16:30.790 --> 00:16:40.900
Toni Wahrstätter: So, and then we basically focused, Definite2 more on everything consensus-related and testing, all the new changes that come with Definite 2, for example, the

83
00:16:41.150 --> 00:16:47.520
Toni Wahrstätter: BAL payload, or the bulb EL block separation, the new engine API methods, and so on.

84
00:16:48.400 --> 00:16:49.830
Toni Wahrstätter: If that makes sense.

85
00:16:52.140 --> 00:16:53.970
Stefan Starflinger: Yeah, I agree with that also.

86
00:16:54.660 --> 00:17:12.310
jochem-brouwer: Yeah, yeah, I think that what you then do is, like, DevNet tools, because it also makes sense to not immediately stress test the DevNet, and then do the stress testing on, like, a very specific benchmark network, so, like, a shadow fork, or BloatNet, or mainnet, or whatever, and then use that for the benchmarks. Yeah, I think that makes a lot of sense.

87
00:17:13.619 --> 00:17:22.629
Toni Wahrstätter: Yeah, and just to be on the safe side, maybe we should first, clarify on ACDE or ACDT with clients, if they are actually ready for

88
00:17:23.169 --> 00:17:24.539
Toni Wahrstätter: higher guest limits

89
00:17:25.099 --> 00:17:43.549
Toni Wahrstätter: Because I don't know if we can just bump it up to 150, and then suddenly we'll run into weird RLP size limits, or whatever. So, just to double check. I assume clients will be fine with that, so every client might be fine with just bumping it up, but just to double check there.

90
00:17:44.479 --> 00:17:51.639
Toni Wahrstätter: We don't need to trigger, like, running into the 10MB, uncompressed size limit or anything.

91
00:17:54.509 --> 00:17:56.799
Toni Wahrstätter: Perfect. Anything else regarding…

92
00:17:56.899 --> 00:18:06.099
Toni Wahrstätter: this discussion point. Just to summarize, I think we will now also start a shadow fork, and probably a fork of BloatNet, and then also

93
00:18:06.799 --> 00:18:19.059
Toni Wahrstätter: basically unblock the benchmarking efforts by having two clients already ready, BASO and GEF, that can be used to test parallel execution and batch I.O.

94
00:18:19.159 --> 00:18:20.819
Toni Wahrstätter: At the same time already.

95
00:18:22.889 --> 00:18:24.219
Toni Wahrstätter: Anything to add?

96
00:18:28.310 --> 00:18:29.380
jochem-brouwer: Yeah, maybe two.

97
00:18:29.720 --> 00:18:34.659
jochem-brouwer: Clarify a bit, or maybe to ask that we are all in, like, the same,

98
00:18:34.930 --> 00:18:50.350
jochem-brouwer: line of thought. So the parallel execution is using the block access list to, well, run multiple transactions in multiple threads. And the batch I.O. is actually used to read from the ball to a parallel fetch from the disk, right?

99
00:18:52.680 --> 00:18:53.710
Toni Wahrstätter: Yeah, exactly.

100
00:18:54.320 --> 00:19:01.229
jochem-brouwer: Okay, so those are, those are, like, two different optimizations, and I think it is nice also for the benchmarking.

101
00:19:01.480 --> 00:19:06.130
jochem-brouwer: For the benchmarks to be able to test these, individually.

102
00:19:06.400 --> 00:19:17.759
jochem-brouwer: So now, not individually, but maybe, like, with only parallel execution, and with parallel execution, and the batch I.O, to see what the impact is, so we can also measure the impact of these

103
00:19:18.140 --> 00:19:19.459
jochem-brouwer: of adding the REITs.

104
00:19:19.580 --> 00:19:21.630
jochem-brouwer: To the ball, what the impact of this is.

105
00:19:21.630 --> 00:19:24.749
Toni Wahrstätter: Exactly, and this will be the very interesting comparison.

106
00:19:24.980 --> 00:19:32.780
Toni Wahrstätter: that we are… yeah, we've postponed this until we have definites, and now we're… it's time, I would say. Basically.

107
00:19:33.040 --> 00:19:45.639
Toni Wahrstätter: finally determining, do we need the state locations in the block lab access list or not? Are they actually worth it? And the best way to do so would be exactly what you said, comparing it with the batch I.O. enabled, and

108
00:19:46.120 --> 00:19:50.640
Toni Wahrstätter: Then, with Batch.io disabled, and then seeing what are the numbers.

109
00:19:50.780 --> 00:19:52.429
Toni Wahrstätter: And if we do that on a…

110
00:19:52.750 --> 00:19:58.630
Toni Wahrstätter: Realistic state size definite, plus on a higher gas limit, we should get numbers.

111
00:19:59.130 --> 00:20:01.059
Toni Wahrstätter: That's… yeah.

112
00:20:01.370 --> 00:20:03.490
Toni Wahrstätter: We should get confidence for Glamsterdam.

113
00:20:10.880 --> 00:20:12.400
Toni Wahrstätter: Great, anything else?

114
00:20:14.070 --> 00:20:19.930
jochem-brouwer: Yeah, just asking what, for Corinne, the clarification, like, the background… Are those stations?

115
00:20:20.300 --> 00:20:30.250
Toni Wahrstätter: Yeah, I think we can ignore it. I think we can ignore it at this point, because this is like an optimization that is solely dependent on the post-transaction state divs being in the block.

116
00:20:30.430 --> 00:20:35.020
Toni Wahrstätter: So, this doesn't actually tell us anything about

117
00:20:35.150 --> 00:20:38.620
Toni Wahrstätter: Should we keep the state locations or not, so…

118
00:20:38.880 --> 00:20:43.490
Toni Wahrstätter: We can use them, we can also turn them off, depending on what the client supports.

119
00:20:50.150 --> 00:20:56.149
jochem-brouwer: Yeah, I think this is, like, an optimization which, it's not really influenced

120
00:20:56.420 --> 00:21:02.139
jochem-brouwer: Like, if you just think about, like, the reads, if it would remove that or not, like, this will not influence

121
00:21:02.420 --> 00:21:07.700
jochem-brouwer: the, oh, right, the state would also have to get the visa. Yeah, okay.

122
00:21:08.220 --> 00:21:09.180
jochem-brouwer: Interesting.

123
00:21:09.730 --> 00:21:11.370
jochem-brouwer: Yeah, something to keep in mind, mate.

124
00:21:14.550 --> 00:21:15.790
Toni Wahrstätter: Yep, exactly.

125
00:21:17.970 --> 00:21:24.190
Toni Wahrstätter: Great. The second agenda item that we have on today's agenda would be spec and

126
00:21:24.390 --> 00:21:29.520
Toni Wahrstätter: Spec updates and clarifications, so there were… free updates?

127
00:21:29.910 --> 00:21:34.950
Toni Wahrstätter: Nothing new. So the first one was the engine API methods.

128
00:21:35.360 --> 00:21:43.390
Toni Wahrstätter: And there was some discussions in the PR regarding, do we need the engine API methods and for what they're used for?

129
00:21:43.730 --> 00:21:46.559
Toni Wahrstätter: Also, Mikhail had some comments there.

130
00:21:47.320 --> 00:21:50.909
Toni Wahrstätter: Michael, are you on the call? Do you wanna briefly…

131
00:21:51.990 --> 00:21:59.459
Toni Wahrstätter: tell us why the engine API methods are needed, and Your… your thoughts around it?

132
00:22:00.480 --> 00:22:03.020
Mikhail Kalinin: Yeah, okay, so, hey, everyone.

133
00:22:03.730 --> 00:22:06.210
Mikhail Kalinin: I'll try to summarize.

134
00:22:06.790 --> 00:22:11.219
Mikhail Kalinin: So, if, I believe that Ball is, will be part of

135
00:22:11.630 --> 00:22:14.659
Mikhail Kalinin: of the, CL block, of the beacon block.

136
00:22:15.290 --> 00:22:16.890
Mikhail Kalinin: Right? Is that correct?

137
00:22:16.890 --> 00:22:19.880
Toni Wahrstätter: Right, yeah, that's correct. It's in the execution period.

138
00:22:20.520 --> 00:22:32.330
Mikhail Kalinin: Yeah, it's a part of an execution payload. It's quite similar to transactions, so there is no possibility for the execution layer client to process a block without a val, right?

139
00:22:33.710 --> 00:22:42.610
Mikhail Kalinin: And, yeah, and if, we make it as a requirement, for…

140
00:22:42.800 --> 00:22:51.409
Mikhail Kalinin: to pass, BAL to, to, to EL, Alongside to… to the payload.

141
00:22:51.780 --> 00:22:55.940
Mikhail Kalinin: Then we… We have this dependency.

142
00:22:56.210 --> 00:23:02.300
Mikhail Kalinin: kind of like, that the CL block has to… has to…

143
00:23:02.720 --> 00:23:07.149
Mikhail Kalinin: keep BAL on its side, in, in its storage.

144
00:23:07.560 --> 00:23:14.550
Mikhail Kalinin: Like, it would have to keep transactions, but, we have these deduplication methods, like.

145
00:23:14.730 --> 00:23:19.159
Mikhail Kalinin: For, that allows CL to basically request,

146
00:23:19.460 --> 00:23:22.509
Mikhail Kalinin: Work payload bodies, which are…

147
00:23:23.010 --> 00:23:27.960
Mikhail Kalinin: Consisting of, transactions and withdrawals today, from EL's side.

148
00:23:28.350 --> 00:23:34.680
Mikhail Kalinin: So if we make a requirement that the value is required to pass to a new payload call.

149
00:23:34.940 --> 00:23:38.909
Mikhail Kalinin: And, EL will… will get it from CL.

150
00:23:39.110 --> 00:23:42.129
Mikhail Kalinin: Via… in the regular case.

151
00:23:42.320 --> 00:23:47.009
Mikhail Kalinin: Then we have to… Then we likely have to also introduce,

152
00:23:47.250 --> 00:23:57.569
Mikhail Kalinin: this piece of data into these, payload bodies, methods. So, some CLs really use these,

153
00:23:58.140 --> 00:24:01.830
Mikhail Kalinin: Rely on those methods to deduplicate,

154
00:24:02.290 --> 00:24:09.060
Mikhail Kalinin: Data, and, reduce the… disk storage, impact.

155
00:24:09.580 --> 00:24:16.770
Mikhail Kalinin: So, yeah. In this case, yeah, if it's required, then we have to kind of provide this additional

156
00:24:17.770 --> 00:24:27.209
Mikhail Kalinin: be, additional data that can be pulled off from EL.

157
00:24:27.710 --> 00:24:38.780
Mikhail Kalinin: So if it's… the other option, basically, yeah, make PAL as a non… as an optional field of a new payload call.

158
00:24:39.520 --> 00:24:48.160
Mikhail Kalinin: And in this case, EL will have to either execute transactions without it, or look into…

159
00:24:48.900 --> 00:24:53.289
Mikhail Kalinin: its own network, via Def B2B.

160
00:24:53.500 --> 00:24:58.190
Mikhail Kalinin: Extract ball, get Paul from there, and basic execute the block.

161
00:24:59.210 --> 00:25:06.320
Mikhail Kalinin: So… And, yeah. Optional means that sometimes CL will just have it.

162
00:25:06.590 --> 00:25:13.310
Mikhail Kalinin: When the block is just… is gossiped, it will come with a vowel included, and then

163
00:25:13.830 --> 00:25:18.690
Mikhail Kalinin: CL can pass it to EL. So there's kind of, like, two options here.

164
00:25:18.970 --> 00:25:22.840
Mikhail Kalinin: That I see. I don't know if it's clear or not, so… yeah.

165
00:25:23.970 --> 00:25:25.539
Mikhail Kalinin: Let's probably discuss it.

166
00:25:26.180 --> 00:25:30.279
Toni Wahrstätter: Yeah, thanks a lot. To me, it makes a lot of sense.

167
00:25:30.460 --> 00:25:43.270
Toni Wahrstätter: what I don't get is why the optional ball field is, like, even on the table. To me, it feels like treating the block-level access list the same as we treat the transactions, and

168
00:25:43.600 --> 00:25:51.480
Toni Wahrstätter: thereby forcing CL clients to either keep the buzz around, or blind them.

169
00:25:51.670 --> 00:26:05.930
Toni Wahrstätter: Which is, kind of what CL clients do in order to deduplicate, transactions. So basically, instead of storing the whole BAL, CL clients would only need to store the bul root.

170
00:26:06.030 --> 00:26:15.170
Toni Wahrstätter: and have those two engine API methods available in order to retrieve the full bottle if needed. To me, this feels, like, very clean.

171
00:26:15.380 --> 00:26:23.150
Toni Wahrstätter: with the optional ball field in the execution playlist, I'm not… I'm not so sure, because essentially, the block of access list will be

172
00:26:23.440 --> 00:26:30.639
Toni Wahrstätter: necessarily needed on the EL side, because you cannot validate the full block without having the block web access list.

173
00:26:30.970 --> 00:26:36.270
Toni Wahrstätter: So… Yeah, I'm having difficulties wrapping my hand around optional.

174
00:26:36.440 --> 00:26:38.690
Toni Wahrstätter: About the fact that it's optional.

175
00:26:38.830 --> 00:26:47.169
Toni Wahrstätter: I know that this is more like a technical thing here, to make sure that CL clients can just get rid of it without blinding it, is that correct?

176
00:26:49.370 --> 00:26:50.090
Mikhail Kalinin: Yeah.

177
00:26:51.350 --> 00:26:52.810
Mikhail Kalinin: Yes, it is.

178
00:26:53.810 --> 00:27:01.500
Mikhail Kalinin: So, like, for a normal case, Val will be passed from CL, because it gets it from gossip.

179
00:27:01.690 --> 00:27:07.970
Mikhail Kalinin: But in the case when, CL is, like, syncing, is in a sync mode,

180
00:27:08.190 --> 00:27:11.780
Mikhail Kalinin: Then it will just pass the payload without valve.

181
00:27:12.430 --> 00:27:17.249
Mikhail Kalinin: And then the EL side will have to fetch it from the network.

182
00:27:17.880 --> 00:27:22.429
Mikhail Kalinin: I don't know. Does it make sense or not? So…

183
00:27:22.430 --> 00:27:27.549
Toni Wahrstätter: It does… it does make sense, so it's very much… we're… we're talking about syncing here, too.

184
00:27:27.960 --> 00:27:34.630
Toni Wahrstätter: So essentially, the CL could provide other CL peers.

185
00:27:34.810 --> 00:27:42.850
Toni Wahrstätter: With beacon blocks, even though those beacon blocks would not contain a full execution payload, because the bul is missing.

186
00:27:43.200 --> 00:27:47.800
Toni Wahrstätter: and the other CL that is syncing would then pass

187
00:27:48.350 --> 00:28:00.110
Toni Wahrstätter: the beacon block execution payload to its EL without the bar, and the EL would then have to figure out where to get the ball from, and the EL could then use DevP2P for that.

188
00:28:02.820 --> 00:28:03.360
Mikhail Kalinin: And then…

189
00:28:03.360 --> 00:28:03.910
Toni Wahrstätter: What?

190
00:28:03.910 --> 00:28:05.519
Mikhail Kalinin: will happen… yeah, sorry.

191
00:28:06.040 --> 00:28:07.449
Toni Wahrstätter: Go ahead, go ahead, please.

192
00:28:08.010 --> 00:28:11.550
Mikhail Kalinin: Yeah, and then what will happen, in the case when,

193
00:28:12.170 --> 00:28:27.770
Mikhail Kalinin: There is nothing, nothing to fetch, so there is, like, imagine there is no syncing case, EL has all the data to process a block, but CL does not give a, does not pass a barrel, because it's, it's optional. It's an optional field.

194
00:28:28.140 --> 00:28:30.910
Mikhail Kalinin: then, EL…

195
00:28:31.090 --> 00:28:39.200
Mikhail Kalinin: Will not be able to synchronously execute the synchronously process block and get back with a payload status.

196
00:28:39.380 --> 00:28:43.170
Mikhail Kalinin: As it happens today, it will have to go to the network.

197
00:28:43.760 --> 00:28:49.410
Mikhail Kalinin: And it sounds like a synchronous stuff, so it will have to return syncing.

198
00:28:50.020 --> 00:28:53.000
Mikhail Kalinin: Instead of… The payload status.

199
00:28:53.300 --> 00:28:58.730
Mikhail Kalinin: Something like that. It makes the thing a bit more complicated than…

200
00:29:01.140 --> 00:29:04.319
Toni Wahrstätter: Right, yeah, and we could have done the same with transactions, right?

201
00:29:04.440 --> 00:29:06.040
Toni Wahrstätter: So there's… there's nothing…

202
00:29:06.310 --> 00:29:14.789
Toni Wahrstätter: speaking against doing the same for transactions. So we would suddenly actually introduce this new path that might be better.

203
00:29:15.340 --> 00:29:20.590
Toni Wahrstätter: But even though it's… it's, like, different from how… from existing code paths.

204
00:29:21.560 --> 00:29:27.580
Mikhail Kalinin: Right, but what… I see transactions are really necessary.

205
00:29:27.720 --> 00:29:34.240
Mikhail Kalinin: Actually, it's not… there is no possibility to process a block without transactions, but you could process a block without

206
00:29:34.450 --> 00:29:36.890
Mikhail Kalinin: Is your book-level access to this.

207
00:29:37.120 --> 00:29:38.210
Mikhail Kalinin: Couldn't you?

208
00:29:39.910 --> 00:29:47.899
Toni Wahrstätter: You can process it, their transactions at least, but you would not be able to tell if the block is valid or not, because in the end, you would still need to…

209
00:29:48.680 --> 00:29:53.030
Toni Wahrstätter: comparator. So, you would at least need the bul hash, right?

210
00:29:54.040 --> 00:29:58.319
Toni Wahrstätter: Yeah, so the CL could also provide the ball hash.

211
00:29:58.450 --> 00:30:04.160
Toni Wahrstätter: then the engine API call to the EL would also need to provide the ball hash, and then it would work.

212
00:30:06.130 --> 00:30:06.860
Mikhail Kalinin: Right.

213
00:30:09.130 --> 00:30:20.400
Toni Wahrstätter: Maybe a question to the EL clients. Is there already… has some EL team already implemented Bows into DevP2P for SnapSync, for example?

214
00:30:35.570 --> 00:30:42.369
Jared Wasinger: I'll just say on the Geth side, we've slated this to actually use these for the SnapSync.

215
00:30:42.480 --> 00:30:47.070
Jared Wasinger: That has been pushed back to something we plan to do in Q2.

216
00:30:49.520 --> 00:30:51.720
Jared Wasinger: I mean, we can, of course…

217
00:30:54.080 --> 00:30:55.890
Jared Wasinger: Yeah, I'll just leave it at that.

218
00:31:09.540 --> 00:31:10.270
Toni Wahrstätter: Okay.

219
00:31:10.640 --> 00:31:14.579
Toni Wahrstätter: Yeah, maybe we will just have to revisit that topic,

220
00:31:15.090 --> 00:31:30.860
Toni Wahrstätter: Sometime later on. I would say, correct me if I'm wrong, Mikael, but I would say, right now, it seems like the simplest approach would just be to keep it as it is, and implement those two engine API methods that are

221
00:31:30.990 --> 00:31:35.540
Toni Wahrstätter: defined in the… in this PR that I will now post into the chat.

222
00:31:36.270 --> 00:31:37.600
Toni Wahrstätter: Let me quickly through that.

223
00:31:38.250 --> 00:31:45.190
Toni Wahrstätter: So I think this was the right one, where we have defined those two new API methods.

224
00:31:45.590 --> 00:31:56.050
Toni Wahrstätter: And those would essentially be needed by the CL in order to help other CL nodes to sync, because CL will be able to prune the bulk.

225
00:31:56.500 --> 00:32:06.890
Toni Wahrstätter: But then, when it comes to helping other nodes sync, they need the ball again. And because the EL will store the ball, there needs to be this engine API method to retrieve it.

226
00:32:09.130 --> 00:32:11.220
Mikhail Kalinin: Yep, that's… that's correct.

227
00:32:11.400 --> 00:32:13.679
Mikhail Kalinin: And I think, yeah, it's easier to…

228
00:32:14.480 --> 00:32:19.590
Mikhail Kalinin: To leave it as is, and change… and probably change it later on.

229
00:32:20.760 --> 00:32:28.100
Mikhail Kalinin: So… I don't know, it's also a question to CL client developers.

230
00:32:28.560 --> 00:32:30.939
Mikhail Kalinin: What do they think about it?

231
00:32:33.740 --> 00:32:38.980
Toni Wahrstätter: Right, yeah, we don't have many serial developers here in this call, unfortunately.

232
00:32:39.360 --> 00:32:42.390
Toni Wahrstätter: I think most of them are busy with EPBS anyway.

233
00:32:43.070 --> 00:32:47.190
Toni Wahrstätter: But yeah, this will probably come up in the future again, and we should,

234
00:32:48.210 --> 00:32:52.829
Toni Wahrstätter: We should think how, like, what is the cleanest solution for such things.

235
00:32:53.450 --> 00:32:59.669
Toni Wahrstätter: And if we should just keep on doing the same that we do with transactions, or if there would be a smaller path.

236
00:33:00.990 --> 00:33:06.269
Toni Wahrstätter: Awesome. Is there anything else on that topic, on the engine EPI method?

237
00:33:10.420 --> 00:33:23.259
Toni Wahrstätter: Otherwise, we can go on to the next item, which is further clarifying what access means. We have had discussions on that, like, when do we count an account as being accessed versus not yet accessed?

238
00:33:23.690 --> 00:33:27.450
Toni Wahrstätter: Having to do with the different phases.

239
00:33:27.700 --> 00:33:33.119
Toni Wahrstätter: And this PR here, I will also post it into the agenda, just clarified that further.

240
00:33:33.320 --> 00:33:42.810
Toni Wahrstätter: Unfortunately, I saw it get merged automatically before, I could respond to Jocham's comment here.

241
00:33:43.260 --> 00:33:59.570
Toni Wahrstätter: I will… I will still do that and incorporate that, but I think right now we're in a good state because Felipe and Rahul have created tests for all those edge cases, and clients have been passing those tests, so I think we are quite aligned on that topic.

242
00:34:00.320 --> 00:34:10.219
Toni Wahrstätter: But just to make sure, is there anything on the excess topic? I know that Jared and Gary brought it up in Discord recently, is there anything we should discuss?

243
00:34:18.260 --> 00:34:25.960
Jared Wasinger: Yeah, I guess I'll just say… so, the proposal we brought up,

244
00:34:27.070 --> 00:34:35.610
Jared Wasinger: Basically, it was about, changing the… Sort of changing the,

245
00:34:36.320 --> 00:34:51.329
Jared Wasinger: The logic for whether or not we include a, like, when making a call and executing the gas handler, depending on how much gas there is, and it goes out of gas at some point in the handler.

246
00:34:51.659 --> 00:35:00.249
Jared Wasinger: We will or will not include the, the target as an axis. And…

247
00:35:00.900 --> 00:35:10.500
Jared Wasinger: the reason we made this proposal was that it greatly simplified the change there that need to be made on the side of Geth.

248
00:35:10.630 --> 00:35:24.210
Jared Wasinger: But I think, yeah, Joakim brought up, A pretty good point, regarding,

249
00:35:26.480 --> 00:35:34.959
Jared Wasinger: basically, we… I think the current spec is… is good, because we need to… we can't make it…

250
00:35:35.690 --> 00:35:47.639
Jared Wasinger: we can't create a situation where somebody can make a call with one gas, and then the target gets included in the access list. It is sort of an attack vector.

251
00:35:48.000 --> 00:35:57.580
Jared Wasinger: So, I… personally, I think that the current spec is… Is okay.

252
00:35:59.860 --> 00:36:01.129
Toni Wahrstätter: Perfect, thank you.

253
00:36:03.480 --> 00:36:04.490
Toni Wahrstätter: Awesome.

254
00:36:05.470 --> 00:36:11.929
Toni Wahrstätter: I think we have, alignment on that point in this case. And then the last agenda item

255
00:36:12.190 --> 00:36:16.629
Toni Wahrstätter: For the specs was to chase in RPC endpoints, I think clients are already…

256
00:36:16.940 --> 00:36:21.450
Toni Wahrstätter: For DEFNET2, having the JSON RPC endpoints implemented.

257
00:36:22.110 --> 00:36:27.809
Toni Wahrstätter: Is that the case for all clients, or is there a client that won't have the JSTAR PC already implemented?

258
00:36:28.450 --> 00:36:29.730
Toni Wahrstätter: Until next week.

259
00:36:40.130 --> 00:36:40.940
Toni Wahrstätter: Great.

260
00:36:44.380 --> 00:36:51.700
Toni Wahrstätter: Then we have another agenda item by Stefan. Stefan, you wanted to talk a bit about standardized ALT traces?

261
00:36:52.900 --> 00:36:58.489
Stefan Starflinger: Yeah, I just, thought about, generally, how could we approach, kind of.

262
00:36:58.790 --> 00:37:04.450
Stefan Starflinger: In a standardized way, testing the performance gains of bowels.

263
00:37:04.890 --> 00:37:12.620
Stefan Starflinger: And one of the most standard ways to capture these insights is with open telemetry traces.

264
00:37:12.990 --> 00:37:25.239
Stefan Starflinger: And I think there are two clients that have that implemented, Geth and Reth, but I think Geth is in the process of adding that. I can share the document in the chat.

265
00:37:25.530 --> 00:37:28.220
Stefan Starflinger: It's a little bit of a long shot.

266
00:37:29.100 --> 00:37:36.849
Stefan Starflinger: But I wanted to maybe see if we can just use it as a way to brainstorm exactly

267
00:37:36.990 --> 00:37:47.099
Stefan Starflinger: What kind of metrics block-level accesses will add that we want to capture, that we want to follow in a more structured fashion.

268
00:37:47.220 --> 00:38:00.449
Stefan Starflinger: And it would be good that we can get, kind of, the ball rolling and communicate, how best we can extract these metrics. I mean, this document is a suggestion to use OpenTelemetry.

269
00:38:00.800 --> 00:38:09.900
Stefan Starflinger: But of course, that's not a hard requirement, if other clients might do it differently, but in general, it would be good if we

270
00:38:10.270 --> 00:38:20.250
Stefan Starflinger: align on exactly when we capture the timings. For example, the prefetching is one of the important,

271
00:38:20.920 --> 00:38:33.870
Stefan Starflinger: like, elements of the bowel, so how long does it take to prefetch everything? Have you implemented the prefetching the same way as other clients? Does it make sense that we capture it all in a standardized way?

272
00:38:33.870 --> 00:38:42.179
Stefan Starflinger: And then, how well does the parallel execution work? Like, which… how many transactions are running in parallel? That would be really nice to see.

273
00:38:42.460 --> 00:38:50.289
Stefan Starflinger: And to visualize. I would really like to get something like that running for all of the clients in Kurtosis,

274
00:38:50.770 --> 00:38:56.119
Stefan Starflinger: So yeah, that's why I created the document, and I'm very happy to take any comments or feedback on it.

275
00:39:00.180 --> 00:39:01.610
Toni Wahrstätter: Awesome, thank you.

276
00:39:01.780 --> 00:39:04.160
Toni Wahrstätter: I see Jocham, you have your hand up.

277
00:39:04.470 --> 00:39:18.059
jochem-brouwer: Yeah, I know that, Stefano, I've already talked to Carlos, but Carlos is also… I'm not sure if this works in parallel, but he has posted this research, post about, adding some more general

278
00:39:18.510 --> 00:39:25.869
jochem-brouwer: metrics, and I think it will be helpful to coordinate this, like, maybe…

279
00:39:26.360 --> 00:39:33.099
jochem-brouwer: Getting, like, these general metrics standardized, and then also, on top of that, the ball metrics.

280
00:39:33.240 --> 00:39:36.230
jochem-brouwer: Because then, otherwise, I will do two things,

281
00:39:36.550 --> 00:39:40.289
jochem-brouwer: Not in parallel, but, yeah. I think you get the point.

282
00:39:46.840 --> 00:39:53.300
jochem-brouwer: So, the question is, yeah, maybe work together with Carlos on these metrics.

283
00:39:56.130 --> 00:40:04.649
Stefan Starflinger: Yeah, for sure. His metrics are a little bit different, than mine, because I, like, built on top of, kind of, what he was working on.

284
00:40:04.670 --> 00:40:17.399
Stefan Starflinger: And just focused on, block-level access lists. So this is just generally to identify, I think, execution metrics, but this does not, consider vows, yet.

285
00:40:17.600 --> 00:40:23.829
Stefan Starflinger: And that's kind of, the spec that I wrote, to add on top of that.

286
00:40:24.540 --> 00:40:28.859
jochem-brouwer: Okay, so it's, yeah, it's already written on top of, of this, thing.

287
00:40:29.350 --> 00:40:43.210
Stefan Starflinger: Yeah, that's the idea. And in general, it's not a… just to reiterate, it's not a requirement for DevNet2, but what I would like to have at some point is to be able to have some visualization of these metrics

288
00:40:43.330 --> 00:40:47.850
Stefan Starflinger: in Grafana or something like that, to be able to export them.

289
00:40:48.030 --> 00:40:51.890
Stefan Starflinger: And to have that in kurtosis would be the first step.

290
00:40:52.310 --> 00:40:54.129
Stefan Starflinger: That'll be very nice.

291
00:41:01.170 --> 00:41:02.670
Toni Wahrstätter: Awesome, thank you very much.

292
00:41:03.290 --> 00:41:04.830
Toni Wahrstätter: Yeah, please.

293
00:41:04.990 --> 00:41:06.090
Toni Wahrstätter: Have a look.

294
00:41:06.570 --> 00:41:10.659
Toni Wahrstätter: Let's make sure that we get those metrics implemented such that we can then

295
00:41:11.550 --> 00:41:18.749
Toni Wahrstätter: actually benchmark and test if optimizations make sense, and especially get some

296
00:41:19.550 --> 00:41:25.060
Toni Wahrstätter: certainty that clients are doing the same and getting the same out of the optimizations. This is… this is great.

297
00:41:25.370 --> 00:41:26.679
Toni Wahrstätter: Thanks a lot, Stefan.

298
00:41:28.560 --> 00:41:31.099
Toni Wahrstätter: Perfect. Anything else on that topic?

299
00:41:34.940 --> 00:41:38.679
Toni Wahrstätter: Otherwise, this would bring me to the last topic, namely…

300
00:41:38.870 --> 00:41:46.050
Toni Wahrstätter: One thing that we should discuss is how we would deal with malicious block lab access lists, basically with

301
00:41:46.290 --> 00:41:48.880
Toni Wahrstätter: Block web accesses that are wrong.

302
00:41:49.320 --> 00:41:56.109
Toni Wahrstätter: But of course, for such block of access lists, we must make sure that we are able to invalidate the block

303
00:41:56.660 --> 00:42:01.900
Toni Wahrstätter: That contains such a wrong block access list as early as possible in the process.

304
00:42:03.260 --> 00:42:06.340
Toni Wahrstätter: And let me actually quickly share my screen.

305
00:42:06.530 --> 00:42:08.460
Toni Wahrstätter: Let me actually try to do so.

306
00:42:09.370 --> 00:42:11.079
Toni Wahrstätter: Can you see my screen already?

307
00:42:12.950 --> 00:42:14.900
jochem-brouwer: I see a black screen and a mouse.

308
00:42:15.300 --> 00:42:17.059
Toni Wahrstätter: Okay, that's correct. Okay, interesting.

309
00:42:17.830 --> 00:42:19.250
Toni Wahrstätter: Interesting, though.

310
00:42:20.240 --> 00:42:25.019
Toni Wahrstätter: Because it already showed me in the preview that it will be a black screen, but…

311
00:42:30.770 --> 00:42:33.210
Toni Wahrstätter: Let me quickly try something here.

312
00:42:40.100 --> 00:42:46.130
Toni Wahrstätter: Okay, seems like the sharing is not… Working, as expected.

313
00:42:46.330 --> 00:42:52.129
Toni Wahrstätter: Then I will just post, or maybe can someone else share? Jochen does the sharing work for you?

314
00:42:53.130 --> 00:42:54.640
Toni Wahrstätter: Could you share your screen?

315
00:42:55.180 --> 00:42:56.819
jochem-brouwer: I can? Yes, I can.

316
00:42:56.820 --> 00:42:59.990
Toni Wahrstätter: Okay, could you then open a link for me?

317
00:43:00.190 --> 00:43:00.890
jochem-brouwer: Yes.

318
00:43:01.170 --> 00:43:02.980
jochem-brouwer: Let me first share my…

319
00:43:06.260 --> 00:43:06.900
Toni Wahrstätter: Perfect.

320
00:43:08.410 --> 00:43:09.979
jochem-brouwer: This shows the local time.

321
00:43:13.320 --> 00:43:14.710
jochem-brouwer: Right? Perfect.

322
00:43:15.220 --> 00:43:17.210
jochem-brouwer: Okay, great. And what's your title?

323
00:43:17.210 --> 00:43:25.439
Toni Wahrstätter: And I will not just post the short presentation I have here into the chat so everyone can even follow it live, but you should be able to open it.

324
00:43:25.690 --> 00:43:28.109
jochem-brouwer: Yes. Just, tell me, what to do.

325
00:43:29.510 --> 00:43:33.340
Toni Wahrstätter: Perfect, yeah, just click on the… on slideshow for the first slide.

326
00:43:34.810 --> 00:43:36.669
Toni Wahrstätter: Or for the second one already.

327
00:43:38.180 --> 00:43:45.770
Toni Wahrstätter: Okay, so just to quickly introduce you into the topic, we can go one slide back here often, please.

328
00:43:46.340 --> 00:44:01.570
Toni Wahrstätter: just as a quick intro, so this will… this is how I think of block execution today. So today, you don't have a block of access list, so what happens is you first do some I.O. in the block, then there might be some execution in the mean…

329
00:44:01.650 --> 00:44:08.980
Toni Wahrstätter: After that, there might be again an S load, and you have to go to disk again, and so on. And at the end, right after.

330
00:44:09.160 --> 00:44:18.580
Toni Wahrstätter: our virtual execution deadline. There is also the state route calculation. This is basically the last thing we do before we say a block is valid or not.

331
00:44:19.440 --> 00:44:21.330
Toni Wahrstätter: Now, going to the next slide.

332
00:44:21.540 --> 00:44:27.769
Toni Wahrstätter: the picture changes a bit with block exists. First of all, we can ignore the gas limit here, this is just…

333
00:44:27.980 --> 00:44:41.140
Toni Wahrstätter: a random number showing us, okay, we have now scaled from 60 to 30 million, so blocks are actually bigger already, and the best thing we get from block lab access lists is that we can now parallelize between batch I.O,

334
00:44:41.140 --> 00:44:57.009
Toni Wahrstätter: Then there is still some I.O, for example, I.O. that happens in the very first transactions, when the state is not yet cached through the batch I.O, you might still need to go to disk, and then there is execution and the state recalculation happening in parallel.

335
00:44:57.310 --> 00:45:02.810
Toni Wahrstätter: And this is essentially a block, how it might look with block web access lists.

336
00:45:03.030 --> 00:45:04.690
Toni Wahrstätter: Let's go to the next slide.

337
00:45:06.680 --> 00:45:12.380
Toni Wahrstätter: This summarizes it again. So, essentially, the state locations in the bul are very useful for batch.io.

338
00:45:12.690 --> 00:45:18.050
Toni Wahrstätter: Most of the state that we need during execution will already be pre-cached.

339
00:45:18.360 --> 00:45:24.520
Toni Wahrstätter: And the bulk gas limit can quite significantly be increased. So this is, like, the happy case.

340
00:45:24.960 --> 00:45:26.819
Toni Wahrstätter: Let's go to the next slide, then.

341
00:45:29.920 --> 00:45:44.609
Toni Wahrstätter: So now, think of a malicious proposer, or a malicious builder, and what this builder does is the following attack scenario. So you would build… so let's start at the very beginning. What… what do we try to exploit here?

342
00:45:44.720 --> 00:45:47.730
Toni Wahrstätter: So a malicious bulb would exploit the fact

343
00:45:47.890 --> 00:45:58.280
Toni Wahrstätter: That in our block level access list, we don't map state locations, so the reads, how we tend to say, we don't map them to transaction indices.

344
00:45:58.480 --> 00:46:02.900
Toni Wahrstätter: So, from the perspective of a single transaction, you cannot really know

345
00:46:03.980 --> 00:46:18.630
Toni Wahrstätter: are the state locations in the ball correct or not? Because they are not mapped to any transaction index. So, what a malicious bul would now do is, you would try to declare as many garbage storage slots as possible.

346
00:46:18.900 --> 00:46:25.250
Toni Wahrstätter: So essentially, a malicious proposer could fill the ball with garbage storage slots.

347
00:46:26.110 --> 00:46:38.029
Toni Wahrstätter: So far, so good. So if you fill it with completely garbage, and you fill it full with garbage slots, then this might be quite easy to detect for any client, because we can enforce

348
00:46:38.370 --> 00:46:57.899
Toni Wahrstätter: a maximum number of storage slots in the bulk, and this is quite easily derivable from the block gas limit, so we should probably do that anyway. Like, have a cap of how many storage slots can there be in the block level access list, just by derived from gas limit divided by the cost of accessing a storage slot.

349
00:46:58.550 --> 00:47:00.730
Toni Wahrstätter: But now, what we could do is.

350
00:47:01.720 --> 00:47:09.259
Toni Wahrstätter: what I have on this first iteration point here, creating a malicious bottle that doesn't use, like, naively the full gas limit for

351
00:47:09.630 --> 00:47:15.250
Toni Wahrstätter: That transaction, but… the full gas limit minus one max size transaction.

352
00:47:15.560 --> 00:47:26.329
Toni Wahrstätter: So, essentially, Assuming, like, 150, 200 million gas, you would use all of it except 16 million, 16.78 million.

353
00:47:26.500 --> 00:47:27.390
Toni Wahrstätter: 4…

354
00:47:27.680 --> 00:47:38.360
Toni Wahrstätter: declaring storage slots in the ball. So this is, like, the number of storage slots you would put into the ball. And then, in the same block, the transactions would actually only do heavy computation.

355
00:47:39.260 --> 00:47:48.100
Toni Wahrstätter: So this is like the attack. You would have a ball with garbage storage slots, many of them, and you would have a block with transactions that do heavy computation.

356
00:47:48.350 --> 00:47:55.939
Toni Wahrstätter: And now the question is, when is the first time that clients could figure out that this block is actually invalid?

357
00:47:59.980 --> 00:48:15.370
Toni Wahrstätter: Right, and this is something we have to think about, because, of course, now, assuming we parallelize all transactions on a separate core, right? Assuming you have an infinite number of core, or you have 8 cores and there are 8 transactions, doesn't matter.

358
00:48:16.630 --> 00:48:18.990
Toni Wahrstätter: From the perspective of each core.

359
00:48:19.240 --> 00:48:24.349
Toni Wahrstätter: you can validate that the state diff is correct, right? You have a definite

360
00:48:24.810 --> 00:48:31.240
Toni Wahrstätter: validation there. But with regards to storage keys, because they are not mapped to transaction indices.

361
00:48:31.370 --> 00:48:37.519
Toni Wahrstätter: You cannot really tell if this malicious bar that only contains garbage is actually valid or not.

362
00:48:38.330 --> 00:48:44.250
Toni Wahrstätter: on each core. So what you would need to do is you would have to actually execute all transactions.

363
00:48:44.580 --> 00:48:53.620
Toni Wahrstätter: And as said, they only do heavy computation, and only after executing all transactions, you would basically be able to sync your course

364
00:48:53.790 --> 00:48:58.780
Toni Wahrstätter: And compare which storage slots each core saw.

365
00:48:58.890 --> 00:49:07.450
Toni Wahrstätter: And only then you could tell, okay, this button must be invalid, because the transactions never accessed what is in the block web access list.

366
00:49:07.780 --> 00:49:16.860
Toni Wahrstätter: And in this malicious scenario, what you would get is basically a proposer would sacrifice his block, because you would end up with an invalid block.

367
00:49:17.180 --> 00:49:32.010
Toni Wahrstätter: But you would cause the prefetch process to be completely useless, right? The batch I.O. process would basically fetch completely useless storage keys from the disk and put them into the cache.

368
00:49:32.070 --> 00:49:42.579
Toni Wahrstätter: And at the same time, we would engage in quite expensive computation, because we would still execute those transactions, and while executing each transaction in parallel.

369
00:49:42.910 --> 00:49:51.460
Toni Wahrstätter: We would think, okay, those storage slots are not accessed in this transaction, so they must be accessed in another transaction on a different core.

370
00:49:52.010 --> 00:49:54.580
Toni Wahrstätter: And then the question is, okay, how…

371
00:49:54.770 --> 00:49:57.680
Toni Wahrstätter: Fast can clients fail such a block?

372
00:49:58.070 --> 00:49:59.810
Toni Wahrstätter: Let's go to the next slide.

373
00:50:02.570 --> 00:50:04.249
Toni Wahrstätter: Or even to the next one.

374
00:50:06.710 --> 00:50:09.669
Toni Wahrstätter: Actually, go to the next one.

375
00:50:13.210 --> 00:50:17.059
Toni Wahrstätter: Sorry, go 3 slides back, I thought I had another slide there.

376
00:50:18.880 --> 00:50:20.180
Toni Wahrstätter: Two slides, sorry.

377
00:50:22.870 --> 00:50:40.350
Toni Wahrstätter: Right, so this is how the malicious block would look like. It would come with a lot of batch I.O, and it would still require… actually, it would not come with any I.O, this is actually wrong, it should only have execution, but there would be a long tail of batch I.O,

378
00:50:40.580 --> 00:50:51.899
Toni Wahrstätter: for garbage slots, and a lot of execution happening. And if we go to the next slide, this would essentially mean that the state locations in the ball give us nothing anymore, because the worst case

379
00:50:51.900 --> 00:51:00.949
Toni Wahrstätter: having the state locations would be the same as the worst case not having the state locations. And this worst case would be an invalid block.

380
00:51:01.840 --> 00:51:08.100
Toni Wahrstätter: And this would essentially mean we cannot scale as much as we want, which is, of course, Sad.

381
00:51:08.610 --> 00:51:10.170
Toni Wahrstätter: Let's go to the next slide.

382
00:51:12.460 --> 00:51:28.649
Toni Wahrstätter: And there's 3 possible ways forward. So the first one, the simplest one, is we do nothing about this problem. It means we can… we can get quite far, I think, with having, like, caps on the bar itself. For example, in the block lab access list, we can already tell

383
00:51:28.800 --> 00:51:35.200
Toni Wahrstätter: That if we see a certain number of storage slots, that each storage slot must come at least with

384
00:51:35.710 --> 00:51:52.419
Toni Wahrstätter: 2,000 GAS, right? Because that's the least you need to access all of those storage slots. And if there is a bul that already contains too many storage slots for what is realistic within the block size, within the block gas limit, then we can already fail those balls earlier.

385
00:51:52.800 --> 00:52:08.820
Toni Wahrstätter: And then, also, a sub-point under the do-nothing is we can keep track during execution. Let's say you have, 4 cores, and there are 8 transactions, then if you keep track during execution of which

386
00:52:08.990 --> 00:52:15.920
Toni Wahrstätter: storage piece, do I already… have I already accessed? And how much gas was already spent?

387
00:52:16.190 --> 00:52:33.990
Toni Wahrstätter: then you can fail the block early on, because you would realize, okay, the transactions I just executed, they didn't touch any of the storage keys, so all the storage keys in the ball must still be touched, but there's not enough gas available at this point in time, so I can

388
00:52:34.140 --> 00:52:38.369
Toni Wahrstätter: Failed the block early on, without executing all transactions in that block.

389
00:52:38.780 --> 00:52:42.640
Toni Wahrstätter: So this is one option, and probably the simplest. I'm just not sure

390
00:52:42.770 --> 00:52:45.469
Toni Wahrstätter: If the worst case would actually be

391
00:52:45.700 --> 00:52:49.929
Toni Wahrstätter: The same as the worst case without even having the storage locations at all.

392
00:52:51.290 --> 00:53:05.189
Toni Wahrstätter: The second least complex option would be we remove the state locations, so this is basically something that is anyway, to be decided, if we keep the state locations in Nepal, and this depends on the benchmarks we get.

393
00:53:05.740 --> 00:53:18.840
Toni Wahrstätter: But one of the benchmarks we should definitely do is test such a malicious block, essentially having a malicious proposer that submits a malicious block-level access list that causes clients to

394
00:53:19.130 --> 00:53:24.340
Toni Wahrstätter: Waste a lot of time, and then figuring out that the block is invalid very late into the process.

395
00:53:24.820 --> 00:53:31.429
Toni Wahrstätter: And the last option, which would probably be the most elegant solution to this specific problem, would be

396
00:53:31.690 --> 00:53:38.109
Toni Wahrstätter: for all state locations in the BAL that are currently, of course, not mapped to any transaction index.

397
00:53:38.280 --> 00:53:44.430
Toni Wahrstätter: We actually map them to the transaction index when they are first accessed within the block.

398
00:53:45.180 --> 00:54:04.109
Toni Wahrstätter: This would mean we don't have any duplication, because if a storage slot is kind of, like, changed, it would still not appear twice as a read again, so this would not change compared to today. But what would change is that each account would come with a first access index, and each

399
00:54:04.360 --> 00:54:09.149
Toni Wahrstätter: storage read would come with a first access index. And I already did some

400
00:54:09.430 --> 00:54:15.690
Toni Wahrstätter: Experiments, and it looks like with today's gas limit, this would increase the average bottle size.

401
00:54:16.070 --> 00:54:19.010
Toni Wahrstätter: By approximately 4%.

402
00:54:19.720 --> 00:54:37.300
Toni Wahrstätter: So we are only talking about a 1, 2, 3 byte number here, so it's quite insignificant from a size perspective, but of course, add some logic again to it. Also, it touches the worst case file size, which would increase from 0.2MB to 0.97MB.

403
00:54:37.350 --> 00:54:41.159
Toni Wahrstätter: This is, like, negligible, we can totally ignore that, because

404
00:54:41.290 --> 00:54:53.810
Toni Wahrstätter: as long as the worst case ball size still stays below the call data block, and we are still, like, half a megabyte smaller than the call data block, I think we are fine, because we're not creating, like, a new dust vector.

405
00:54:54.180 --> 00:54:57.629
Toni Wahrstätter: Then, the next point, it allows clients to prefetch

406
00:54:58.450 --> 00:55:07.389
Toni Wahrstätter: Storage slots in the correct order, which might be quite nice, because today, with the storage keys, or with the state locations not being ordered.

407
00:55:07.700 --> 00:55:10.440
Toni Wahrstätter: There is another worst-case scenario where

408
00:55:10.620 --> 00:55:22.700
Toni Wahrstätter: The keys you need first are actually the lexicographically last in the vowel, so you would read them last while you need them earlier in the block, so this would be prevented. And one nice

409
00:55:22.850 --> 00:55:27.990
Toni Wahrstätter: thing is that we would still not have any duplication of addresses and storage keys, so the power would

410
00:55:28.270 --> 00:55:32.430
Toni Wahrstätter: Basically, from a size perspective, it would stay quite compact.

411
00:55:33.180 --> 00:55:40.519
Toni Wahrstätter: But yeah, it would change something, and suddenly we're not talking about removing the state locations anymore, but actually adding indices to it.

412
00:55:41.620 --> 00:55:44.090
Toni Wahrstätter: So yeah, this is, of course, a lot.

413
00:55:44.450 --> 00:55:47.200
Toni Wahrstätter: that I presented right now, I guess,

414
00:55:48.320 --> 00:55:57.990
Toni Wahrstätter: We won't find an answer about this today, but I'm curious if clients have already thought about this, like, especially how do we want to invalidate a block?

415
00:55:58.340 --> 00:56:07.670
Toni Wahrstätter: as early on in the process without risking that we do a lot of batch I.O, and we also do a lot of execution, and then only figure out

416
00:56:08.050 --> 00:56:11.240
Toni Wahrstätter: That the block is invalid very late into the process.

417
00:56:11.710 --> 00:56:14.170
Toni Wahrstätter: And… Yeah.

418
00:56:14.460 --> 00:56:16.700
Toni Wahrstätter: getting nothing out of the batch I.O.

419
00:56:18.900 --> 00:56:20.740
Toni Wahrstätter: Yeah, any thoughts on this?

420
00:56:25.440 --> 00:56:26.980
Toni Wahrstätter: Yeah, Jochen, go ahead.

421
00:56:27.170 --> 00:56:43.760
jochem-brouwer: Yeah, like, maybe, maybe one comment, which I just realized, because now we are talking about, like, we have to realize the current way where we have to, where we invalidate invalid blocks. That means that we have to first sequentially execute the entire block, and then, well, the simplest example

422
00:56:43.760 --> 00:56:48.890
jochem-brouwer: on how to construct, like, an invalid block, is to just construct a valid block.

423
00:56:48.980 --> 00:56:54.960
jochem-brouwer: But just change the state root at the end. So you would only realize at the end that the state root is incorrect.

424
00:56:55.140 --> 00:57:03.860
jochem-brouwer: And… What we are talking about here is, like, we already have the parallel execution.

425
00:57:04.330 --> 00:57:18.570
jochem-brouwer: So, if we would compare this worst case, or, like, this situation, to the current situation where we don't have the block access lists, then it likely still is, like, a very big improvement. I just wanted to raise that point for the perspective of this.

426
00:57:20.720 --> 00:57:27.269
Toni Wahrstätter: Yeah, this is very true. So it's… it's… it's not, like, setting us back that far, but it's more like…

427
00:57:28.240 --> 00:57:35.229
Toni Wahrstätter: Comparing the block-level access list with state locations, with the block-level access list without state locations.

428
00:57:35.530 --> 00:57:39.459
Toni Wahrstätter: This malicious block would essentially get us into the same spot.

429
00:57:40.610 --> 00:57:47.390
Toni Wahrstätter: Or, yeah, basically the same spot, where we waste almost all of the batch I.O, And…

430
00:57:47.560 --> 00:58:00.210
Toni Wahrstätter: still have to do, like, full execution. And of course, we can put numbers to it, right? Let's say we have 3 seconds for execution, and we can support the gas limit of 500 million, I don't know, doesn't matter that much.

431
00:58:00.500 --> 00:58:06.629
Toni Wahrstätter: But if we kind of scale the gas limit to a point where leveraging

432
00:58:06.780 --> 00:58:14.479
Toni Wahrstätter: the worst-case batch I.O. and leveraging the worst-case execution would exactly get us to that boundary.

433
00:58:15.280 --> 00:58:22.390
Toni Wahrstätter: Right? Then, suddenly, we find out that there is a worst-case block where you get nothing from batch.io.

434
00:58:22.840 --> 00:58:27.590
Toni Wahrstätter: So this would definitely mean we have to sacrifice some scaling there.

435
00:58:27.890 --> 00:58:31.399
Toni Wahrstätter: Which would, of course, be bad, because at this point, we should then

436
00:58:31.830 --> 00:58:37.910
Toni Wahrstätter: decide for removing the state locations from DePaul, directly?

437
00:58:38.080 --> 00:58:43.399
Toni Wahrstätter: without, yeah, doing nothing. Yeah, Jared, go ahead.

438
00:58:44.610 --> 00:58:58.360
Jared Wasinger: Yeah, I… so, I guess I'm having… I'm not quite understanding how adding first access, to the bowel prevents the case where we have to execute the entire…

439
00:58:58.850 --> 00:59:04.839
Jared Wasinger: A set of transactions, because with parallel execution, there's not really…

440
00:59:05.630 --> 00:59:14.580
Jared Wasinger: Any guarantee about what order transactions will be executed in, so to validate this first access, we still have to…

441
00:59:15.280 --> 00:59:19.659
Jared Wasinger: I mean, because at any given point, if we access a storage slot, it might…

442
00:59:19.820 --> 00:59:38.349
Jared Wasinger: not be the first access of that slot in the block, and so we still need to execute the entire set of transactions to validate the first access, and once we… I mean, if we have to execute the entire transaction set, then we've already read all of the state locations.

443
00:59:40.720 --> 00:59:59.139
Toni Wahrstätter: Right, yeah, I mean, this is true, but then you… you have at least a guarantee, with the first access index, you have the guarantee that after executing your first batch of transactions, so you only need to execute one single transaction, then you could already invalidate the block. Because imagine you have

444
01:00:00.820 --> 01:00:16.590
Toni Wahrstätter: you execute… you have a transaction, and you execute all of them in parallel. Then, from the perspective of each individual transaction, you don't know if the whole block is invalid, because any of the other transactions could have

445
01:00:17.720 --> 01:00:23.860
Toni Wahrstätter: read what is in the ball, right? So, from the perspective of your transaction that only does

446
01:00:23.980 --> 01:00:26.080
Toni Wahrstätter: Execution, you could not tell.

447
01:00:26.140 --> 01:00:45.520
Toni Wahrstätter: maybe the others do execute, some storage reads. But now, having at least one storage… having at least the storage keys mapped to a transaction index, you can fail after executing the first transaction, basically. Because you would then already, within the first transaction, realize

448
01:00:45.790 --> 01:00:49.350
Toni Wahrstätter: That this transaction, for example, does only compute

449
01:00:49.480 --> 01:00:57.320
Toni Wahrstätter: And as soon as you executed the first transaction, you could fail the whole block. And if you now think, okay, we have 8 transactions and 4 cores.

450
01:00:57.690 --> 01:01:03.730
Toni Wahrstätter: then this would mean you don't execute all 8 transactions until realizing you…

451
01:01:04.300 --> 01:01:14.909
Toni Wahrstätter: You can invalidate the block already, but you would only execute 4 transactions, because then after those 4 transactions, the bul would have already been invalidated.

452
01:01:17.500 --> 01:01:19.259
Jared Wasinger: Mmm, okay.

453
01:01:19.260 --> 01:01:22.210
Toni Wahrstätter: So basically, basically what helps a lot is…

454
01:01:23.120 --> 01:01:34.400
Toni Wahrstätter: Today, you give a transaction to a thread, and the thread can very clearly enforce that the state diff is correct, because there is nothing other transactions can interfere with.

455
01:01:35.240 --> 01:01:42.319
Toni Wahrstätter: from the storage read location, it's different. So they need to be brought together at the end of transactions.

456
01:01:43.110 --> 01:01:47.650
Toni Wahrstätter: Kinda collected during execution, and then compared with the ball.

457
01:01:47.840 --> 01:01:59.719
Toni Wahrstätter: So for… until we don't map storage keys to indices, we might not be able to get this isolation of being able to validate that transaction in full isolation.

458
01:02:00.320 --> 01:02:04.699
Jared Wasinger: Yeah, I think I… I think I was actually just mis… misunderstanding it. I think I…

459
01:02:05.290 --> 01:02:09.059
Jared Wasinger: I… I think it's starting to make more sense to me now.

460
01:02:15.890 --> 01:02:27.949
Toni Wahrstätter: Yeah, we don't need to take a decision on this today. I would suggest that we definitely think about such situation when setting up the test framework, such that we are actually able to test such cases.

461
01:02:28.680 --> 01:02:36.360
Toni Wahrstätter: the attack vector would basically be causing a reorg for the next proposal. So the next proposer would…

462
01:02:36.970 --> 01:02:42.300
Toni Wahrstätter: Potentially face a block that takes too long to execute, and would then be in a very uncertain…

463
01:02:42.900 --> 01:02:57.119
Toni Wahrstätter: situation where you don't really know, should I reorg the previous block because the execution took so long, or should I try to finish execution and build on top of it? So this is essentially the attack here. We could trigger, I think we could trigger reorg's,

464
01:02:57.360 --> 01:03:04.920
Toni Wahrstätter: On a definite, by doing so. And also, of course, like, scaling the gas limit very aggressively to points where

465
01:03:05.150 --> 01:03:07.169
Toni Wahrstätter: We don't have much buffer left.

466
01:03:08.150 --> 01:03:14.110
Toni Wahrstätter: But yeah, I think we… clients should just look into this problem and think how they would actually practically

467
01:03:14.550 --> 01:03:16.569
Toni Wahrstätter: Tech lit?

468
01:03:18.110 --> 01:03:24.400
Toni Wahrstätter: Such that clients are not tricked into doing a lot of batch I.O, while at the same time

469
01:03:24.730 --> 01:03:32.010
Toni Wahrstätter: Facing transactions that only do execution, and in the end, figuring out that everything was, invalid.

470
01:03:32.410 --> 01:03:36.840
Toni Wahrstätter: But figuring out That it was invalid too late into the process.

471
01:03:38.320 --> 01:03:41.360
Toni Wahrstätter: Yeah, is there any other comment regarding this?

472
01:04:09.630 --> 01:04:18.860
Toni Wahrstätter: Yeah, seems like it's not the case, and we don't need to find solutions today. Just wanted to bring it up such that we are aware of this situation.

473
01:04:20.040 --> 01:04:23.690
Toni Wahrstätter: To me, it feels like the cleanest thing right now would be…

474
01:04:23.950 --> 01:04:26.260
Toni Wahrstätter: To do nothing, and just,

475
01:04:26.370 --> 01:04:32.880
Toni Wahrstätter: I mean, for Definite 2, we will do nothing anyway, because it's, it's not worth it to change something for Definite 2.

476
01:04:33.190 --> 01:04:35.789
Toni Wahrstätter: But then for Definite 3, we should probably…

477
01:04:36.140 --> 01:04:40.259
Toni Wahrstätter: It should be the goal that we have this situation, resolved.

478
01:04:40.400 --> 01:04:41.590
Toni Wahrstätter: and Ida.

479
01:04:41.900 --> 01:04:47.660
Toni Wahrstätter: Remove the state locations from the bundle entirely, or we agree on adding, like.

480
01:04:48.120 --> 01:04:59.460
Toni Wahrstätter: first access indices, something like this, to the ball. I think it would be, from a size perspective, it would be not a big deal. It's more like additional complexity,

481
01:04:59.810 --> 01:05:03.860
Toni Wahrstätter: Though I would… Want to avoid, personally.

482
01:05:04.300 --> 01:05:05.179
Toni Wahrstätter: But yeah.

483
01:05:06.480 --> 01:05:13.899
Toni Wahrstätter: It's good that we have flagged that problem, and we can now… Collectively start figuring out solutions.

484
01:05:17.600 --> 01:05:18.550
Toni Wahrstätter: Awesome.

485
01:05:19.120 --> 01:05:22.370
Toni Wahrstätter: This is quite good timing, we're already at the end of the call.

486
01:05:22.710 --> 01:05:28.700
Toni Wahrstätter: Anything regarding this topic, how to… invalidate.

487
01:05:28.970 --> 01:05:35.960
Toni Wahrstätter: Invalid blocks as fast as possible, or anything that we forgot to… to do…

488
01:05:36.420 --> 01:05:39.050
Toni Wahrstätter: Today, on today's call. Yeah, Cherry, go ahead.

489
01:05:40.220 --> 01:05:58.130
Jared Wasinger: Yeah, I wanted to, bring up something that's a completely different subject, and it should be pretty quick. So… and maybe this is something that, should've… well, I wasn't actually aware of this by the time ACDT happened this week, so…

490
01:05:59.700 --> 01:06:04.579
Jared Wasinger: basically, and I brought it up before, but it's just kind of…

491
01:06:04.750 --> 01:06:09.959
Jared Wasinger: somewhat of a blocker. In fact, it is a blocker for Geth being able to…

492
01:06:10.120 --> 01:06:28.880
Jared Wasinger: to make progress towards DevNet 2, is that the test fixtures currently don't have receipts in them, and we're getting, a lot of receipt root mismatches, and this is related to, I think it's 7778?

493
01:06:29.290 --> 01:06:35.580
Jared Wasinger: the ETH transfer emit log EIP, so…

494
01:06:35.580 --> 01:06:40.479
Toni Wahrstätter: We have different ones, so 7778 is the one that excludes the refunds.

495
01:06:40.480 --> 01:06:51.690
Jared Wasinger: Okay, maybe, maybe it's 7708, I, I, I'm probably getting the number wrong. But, it would be great if we could get, like a…

496
01:06:51.690 --> 01:07:01.940
Jared Wasinger: A release that has the receipts themselves and the fixtures, because otherwise it's basically impossible to debug failing tests, because right now there's just…

497
01:07:03.110 --> 01:07:04.680
Jared Wasinger: Cool, okay.

498
01:07:04.880 --> 01:07:05.660
Jared Wasinger: Yeah.

499
01:07:08.530 --> 01:07:10.730
Jared Wasinger: Yeah, okay, cool.

500
01:07:11.380 --> 01:07:12.749
Toni Wahrstätter: Yeah, seems like this.

501
01:07:13.310 --> 01:07:15.160
Toni Wahrstätter: Was resolved quite quickly.

502
01:07:15.820 --> 01:07:18.690
Toni Wahrstätter: Anything else we should add?

503
01:07:18.880 --> 01:07:21.639
Toni Wahrstätter: For today, anything else people want to discuss?

504
01:07:22.890 --> 01:07:25.550
felipe: Real quick… Oh, yep.

505
01:07:26.060 --> 01:07:30.230
jochem-brouwer: Yeah, Philippe, please go ahead, because I think I want to ask exactly what you are about to be spoken.

506
01:07:30.610 --> 01:07:40.709
felipe: Yeah, real quick, I just want to get consensus on the updates that were made to both self-destruct and calls and transactions to self.

507
01:07:41.190 --> 01:07:43.730
felipe: I think we're all in agreement that

508
01:07:44.860 --> 01:07:51.749
felipe: Any transfer to self should not emit a log unless there's a self-destruct ETH burn case.

509
01:07:51.950 --> 01:07:54.619
felipe: But then also, we need to talk about…

510
01:07:54.760 --> 01:08:09.270
felipe: We need to… we need agreement for DevNet2 on whether or not it's only a self-destruct log if it's created and destroyed in the same transaction. And so, I just… I think we're all on the same page, but these are changes that have just come up recently.

511
01:08:09.540 --> 01:08:12.040
felipe: And we just need to make sure that we're all in agreement.

512
01:08:12.310 --> 01:08:13.570
felipe: For DevNet2.

513
01:08:22.990 --> 01:08:28.270
Jared Wasinger: Yeah, on the guest side, we're… We're in agreement.

514
01:08:32.310 --> 01:08:42.440
jochem-brouwer: Yeah, I wanted to ask Philippe about the receipts, like, is adding… because I don't think the fixture lease ever have, like, the receipts in them. Is it, like, easy to add this to the fixtures, or not?

515
01:08:44.109 --> 01:08:46.709
felipe: Off the top of my head, I…

516
01:08:47.169 --> 01:09:03.409
felipe: I don't think it will be too difficult, famous last words, right? But, I think we can… yeah, I think we can take care of this, and I think the request is very sensible. I think we'll… either way, we should figure out a way to do this, for some… for some of these EAPs.

517
01:09:03.929 --> 01:09:05.939
felipe: To help with testing and debugging.

518
01:09:10.429 --> 01:09:11.629
felipe: In fact,

519
01:09:12.049 --> 01:09:18.899
felipe: I'm a little late to the STEL meeting right now, and I'll bring this up, right now, and we'll find a way around it.

520
01:09:20.890 --> 01:09:21.740
Toni Wahrstätter: Perfect.

521
01:09:22.010 --> 01:09:28.500
Toni Wahrstätter: Awesome, yeah, then let's continue that conversation async, and we're at the end of the call.

522
01:09:29.100 --> 01:09:32.710
Toni Wahrstätter: If there's nothing else, then I would say thanks to everyone.

523
01:09:32.939 --> 01:09:34.070
Toni Wahrstätter: And see ya!

524
01:09:34.200 --> 01:09:36.329
Toni Wahrstätter: In two weeks at the next critical call.

525
01:09:37.960 --> 01:09:39.629
jochem-brouwer: Bye-bye. Thanks, everyone.

526
01:09:40.029 --> 01:09:40.739
felipe: Hi, everyone.

527
01:09:40.979 --> 01:09:41.839
Toni Wahrstätter: Thank you, bye-bye.

