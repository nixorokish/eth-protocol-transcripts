WEBVTT

1
00:03:53.740 --> 00:03:54.810
Toni Wahrstaetter: Hello?

2
00:03:57.460 --> 00:04:00.309
Toni Wahrstaetter: Is my audio working? Can someone confirm?

3
00:04:00.310 --> 00:04:02.020
Jason Vranek: So, yeah, it's working.

4
00:04:02.020 --> 00:04:02.810
Pooja Ranjan: Perfect, yeah.

5
00:04:02.810 --> 00:04:04.010
Toni Wahrstaetter: Okay, thank you.

6
00:05:12.800 --> 00:05:18.439
Toni Wahrstaetter: Yeah, hello everyone. Let's give people a few more minutes, and then we can start.

7
00:07:09.020 --> 00:07:11.860
Toni Wahrstaetter: Great! I would say we're ready to go.

8
00:07:12.210 --> 00:07:14.230
Toni Wahrstaetter: I think we can start this stream.

9
00:07:17.140 --> 00:07:18.390
Akash | ECH: Yep, VLA.

10
00:07:19.980 --> 00:07:32.459
Toni Wahrstaetter: Great, thank you. Hello everyone, welcome to today's EAP7928 breakout call. It's the third breakout call today, and we have three things on the agenda.

11
00:07:32.790 --> 00:07:51.200
Toni Wahrstaetter: The first thing we want to discuss, which was already kind of a little bit discussed last week, but today we wanted to decide upon it, is are we going for a block-level access list hash in the header, or do we want to switch it out for a block-level access list root, which would then, yeah.

12
00:07:51.500 --> 00:07:56.700
Toni Wahrstaetter: Mirror the existing tri structure we already use for receipts and transactions and so on.

13
00:07:56.860 --> 00:08:05.330
Toni Wahrstaetter: But of course, at the moment, we use the hash, so the default might be we just stick to that, but very open to discuss that.

14
00:08:05.810 --> 00:08:11.800
Toni Wahrstaetter: The second point is, how do we want to handle transaction self-destruct?

15
00:08:12.160 --> 00:08:25.430
Toni Wahrstaetter: There are basically two ways how to handle them. Either we include them and make it explicit that self-destruct in the same transaction is happening, or if you followed the last messages from Jared in the Discord.

16
00:08:25.610 --> 00:08:35.520
Toni Wahrstaetter: Basically, he's arguing for just including the address of the self-destructed account, And not including anything else.

17
00:08:36.659 --> 00:08:41.209
Toni Wahrstaetter: And, last thing we can discuss today is…

18
00:08:41.340 --> 00:08:56.090
Toni Wahrstaetter: an idea that Jared brought up, or Gary brought up, which is including intermediate storage account… including account storage routes into the block level access lists to speed up the hashing.

19
00:08:57.850 --> 00:09:03.249
Toni Wahrstaetter: Those are basically the three points, and then we can go into client updates as usual.

20
00:09:05.860 --> 00:09:14.160
Toni Wahrstaetter: Great, let's start with the first topic on the agenda, which is block-level access list hash versus block-level access list.

21
00:09:14.430 --> 00:09:26.679
Toni Wahrstaetter: try, or root, and putting everything into a try, and let's see, would be great, Jason, it would be great if you could give us a quick, intro into

22
00:09:26.870 --> 00:09:37.189
Toni Wahrstaetter: Why it would matter for pre-coms, and what do you actually expect getting from… from this change, from moving from the hash to a root.

23
00:09:38.560 --> 00:09:40.439
Jason Vranek: Yeah, absolutely. So…

24
00:09:40.780 --> 00:09:57.999
Jason Vranek: I guess in the world of pre-confs, there's different flavors. Like, we start with the basic being inclusion, which are pretty trivial to prove today using the existing tries, but as we move towards execution, there's different ways to do it.

25
00:09:58.020 --> 00:10:04.710
Jason Vranek: But really, an execution preconf would be a guarantee on the post state. And…

26
00:10:04.870 --> 00:10:11.919
Jason Vranek: You can do that technically today using the existing tries, like, and what I mean by that is.

27
00:10:12.180 --> 00:10:17.560
Jason Vranek: What we care about is being able to slash The proposer on-chain?

28
00:10:17.770 --> 00:10:31.970
Jason Vranek: And by proving that they broke their promise. And when we're using the existing tries today for execution, precomps, it's a very disorganized and scattered proof. Like…

29
00:10:32.000 --> 00:10:39.409
Jason Vranek: If your transaction that you're committing to affects many accounts, across these different trees, or tries…

30
00:10:39.480 --> 00:10:53.859
Jason Vranek: then it's… there's a lot more margin for error. There's kind of data availability issues if… if the proposer isn't committing to every single thing that was touched. And for all of these reasons.

31
00:10:54.180 --> 00:11:05.230
Jason Vranek: Actually, sorry, one other important reason is a lot of the times we care about the… what we really care about is post-transaction state routes, and not, like, post-block, routes.

32
00:11:05.450 --> 00:11:08.570
Jason Vranek: So… I think there's some…

33
00:11:09.030 --> 00:11:16.900
Jason Vranek: information that's lost if we're only trying to prove against the final state after the block executes. So, for all these reasons.

34
00:11:17.490 --> 00:11:20.809
Jason Vranek: Execution precoms are really done through…

35
00:11:21.070 --> 00:11:35.710
Jason Vranek: intent-style programming, and that's, like, a burden on developers, kind of adds friction. And the proposal of using roots, instead of hashes for the BALs is that it would be pretty trivial to prove

36
00:11:35.850 --> 00:11:40.780
Jason Vranek: From the smart contract. And the way that you'd organized it, Tony, would be…

37
00:11:41.070 --> 00:11:49.210
Jason Vranek: A pretty straightforward commitment to a route, to cover, like, every piece of state that's touched.

38
00:11:53.020 --> 00:12:09.339
Toni Wahrstaetter: Awesome, thank you. So, just to summarize, it feels like there are three points. It would… if we move from a block of accesses hash to a try, we would make the life of pre-conf providers easier, because the proof would,

39
00:12:10.120 --> 00:12:26.259
Toni Wahrstaetter: would not depend on transactions touching the exact same state in the meantime, but we can get more granular and prove against a certain state at a certain transaction index. Then the proof would become cheaper, because

40
00:12:26.550 --> 00:12:31.549
Toni Wahrstaetter: You don't… you wouldn't need to input that much data anymore.

41
00:12:33.030 --> 00:12:41.100
Toni Wahrstaetter: And also easier, because it would just be one single proof against one object that we have.

42
00:12:42.000 --> 00:12:53.999
Toni Wahrstaetter: So, I totally get… I can totally see those advantages. What would you say against the counter-argument that, the block of access list might be already enough, because

43
00:12:54.170 --> 00:13:04.559
Toni Wahrstaetter: In… in case you want to slash a proposal, you would just… you would just need to input the, the entire block of access list as call data.

44
00:13:06.340 --> 00:13:08.470
Jason Vranek: So, I mean, I definitely see…

45
00:13:08.930 --> 00:13:23.399
Jason Vranek: that possible, because you only have to slash them in the worst case if they did break the commitment. Maybe I'm just not as clear on, like, the size of this, like, guest-wise. Are we… is that reasonable to be able to do?

46
00:13:24.330 --> 00:13:28.559
Toni Wahrstaetter: Yeah, I think it would be, yeah, because the Block 5 accesses seems like it's around…

47
00:13:28.690 --> 00:13:34.699
Toni Wahrstaetter: 50 kilobytes to 60 kilobytes compressed. I think that's already on the upper end.

48
00:13:34.890 --> 00:13:42.469
Toni Wahrstaetter: And, let's say 2X for uncompressed, 100 kilobytes currently would support around 900 kilobytes per block.

49
00:13:42.910 --> 00:13:50.210
Toni Wahrstaetter: Compressed, no, call data, so this would be something that would still easily fit into the block.

50
00:13:53.710 --> 00:13:56.899
Jason Vranek: Yeah, then in that case, I mean,

51
00:13:57.070 --> 00:14:09.339
Jason Vranek: as long as it continues to be scalable, like, if the block size increases and the BAL also increases, if it's still able to fit in call data, I think that's definitely a good backup option, but…

52
00:14:09.340 --> 00:14:15.729
Toni Wahrstaetter: Yeah, it's not only fitting into call data, we also need to fit in the computations needed to eventually prove it on-chain.

53
00:14:15.830 --> 00:14:16.600
Toni Wahrstaetter: Right.

54
00:14:16.760 --> 00:14:17.870
Jason Vranek: I mean, yeah.

55
00:14:17.870 --> 00:14:20.949
Toni Wahrstaetter: This would not be that much, we would just hash everything.

56
00:14:21.320 --> 00:14:26.029
Toni Wahrstaetter: And compare the hashes, and then prove it against the parent, block hash.

57
00:14:26.790 --> 00:14:36.020
Toni Wahrstaetter: But yeah, I'm curious to hear of other clients what you think about this? Another point I heard from Vitalik was

58
00:14:36.140 --> 00:14:41.650
Toni Wahrstaetter: Putting it into a try would be a good idea for partial stateless nodes.

59
00:14:41.820 --> 00:14:51.689
Toni Wahrstaetter: Because imagine you're a partial stateless node, and you only care about, yeah, a certain segment of the state, for example, specific addresses.

60
00:14:51.940 --> 00:14:57.950
Toni Wahrstaetter: and you don't want to download the entire block level access list, then someone could give you

61
00:14:58.080 --> 00:15:04.299
Toni Wahrstaetter: Parts of the block line access lists that you care about, together with a proof against the parent hash.

62
00:15:05.430 --> 00:15:13.529
Toni Wahrstaetter: So, this might be another use case where, yeah, a try versus a hash might be, better suited.

63
00:15:27.820 --> 00:15:37.380
Toni Wahrstaetter: Yeah, so I'm curious, do client teams have an opinion on it, especially, since it would mean introducing yet another try, which was one of the arguments I've heard.

64
00:15:39.340 --> 00:15:46.380
Jared Wasinger: Yeah, I… I wouldn't say I'm, like, strongly against it, but I… I…

65
00:15:46.640 --> 00:15:54.800
Jared Wasinger: I can't say I fully understand the purported benefits, and yeah, it…

66
00:15:55.300 --> 00:15:59.020
Jared Wasinger: the added complexity is also… I mean…

67
00:15:59.910 --> 00:16:04.790
Jared Wasinger: The… the… the proposal is already, like, done.

68
00:16:05.760 --> 00:16:13.880
Jared Wasinger: Turning out to be complex to performantly implement and comprehensively test, so…

69
00:16:14.570 --> 00:16:23.229
Jared Wasinger: Yeah, I mean, I want to learn more, but yeah, kind of lukewarm about it right now, personally.

70
00:16:31.950 --> 00:16:33.230
Toni Wahrstaetter: Yeah, progress.

71
00:16:33.700 --> 00:16:43.629
Jared Wasinger: Sorry, just… I guess one more thing we could… there's nothing stopping us from updating the BAL format in the future to support this. I mean, it's not easy, but we don't have to…

72
00:16:43.880 --> 00:16:48.899
Jared Wasinger: package everything, all the bells and whistles in a single hard fork? No.

73
00:16:49.530 --> 00:16:50.640
Toni Wahrstaetter: This is true, yeah.

74
00:16:51.490 --> 00:16:52.490
Toni Wahrstaetter: That's right.

75
00:16:53.090 --> 00:17:09.350
draganrakita: wanted to say… wanted to say same thing. Yeah, I think ball should be minimal, and it feels that the introducing tree inside with the same fork, with the ball, seems like additional optimization that we can do later.

76
00:17:09.810 --> 00:17:21.820
draganrakita: So I would opt in with some simpler solution right now, and then decide if we need a tree, what kind of tree, maybe it's going to be binary tree, maybe some else tree.

77
00:17:22.240 --> 00:17:25.759
draganrakita: It seems, unnecessary to edit in this work.

78
00:17:29.940 --> 00:17:30.770
Toni Wahrstaetter: Thank you.

79
00:17:32.920 --> 00:17:39.490
Toni Wahrstaetter: I'm also, relaying what Marius is saying in the chat. He's also weakly against it.

80
00:17:44.270 --> 00:17:51.400
Toni Wahrstaetter: Yeah, just to summarize, it very much feels like the trade-off here is, complexity versus this additional

81
00:17:51.720 --> 00:17:57.389
Toni Wahrstaetter: Use case, or… What it enables, making certain things cheaper and easier.

82
00:17:58.030 --> 00:18:06.799
Toni Wahrstaetter: Of course, at the cost of adding protocol complexity. Also, Karim is saying here in the chat that he also prefers

83
00:18:07.080 --> 00:18:08.500
Toni Wahrstaetter: To keep it as is.

84
00:18:10.580 --> 00:18:12.870
Toni Wahrstaetter: Anyone else, an opinion on that?

85
00:18:29.920 --> 00:18:30.900
Toni Wahrstaetter: Okay.

86
00:18:31.350 --> 00:18:37.000
Toni Wahrstaetter: Then, I would say let's keep it for now as it is. I will also reach out to

87
00:18:37.300 --> 00:18:52.230
Toni Wahrstaetter: Vitalik to… maybe he can clarify his points further on the testing call, because we have a section on updates on block of access list on the testing call anyway, so it might make sense to get his input, since he's not on the call today.

88
00:18:52.340 --> 00:19:00.199
Toni Wahrstaetter: And it would be great, Jason, if you could publish, your post somewhere, so that devs have some

89
00:19:00.360 --> 00:19:04.219
Toni Wahrstaetter: Opportunity to get into the topic of pre-coms, and…

90
00:19:04.640 --> 00:19:08.400
Toni Wahrstaetter: Yeah, determine how important it would be.

91
00:19:13.560 --> 00:19:15.539
Toni Wahrstaetter: Yeah, no worries, Lukasht.

92
00:19:16.700 --> 00:19:22.100
Toni Wahrstaetter: The thing we just talked about is the first point of the agenda, the block that access is hash versus the root.

93
00:19:22.480 --> 00:19:30.120
Toni Wahrstaetter: But in this case, if there is nothing else, I would suggest we move on to the second point on the agenda.

94
00:19:31.410 --> 00:19:34.280
Toni Wahrstaetter: It's the last opportunity for anyone to…

95
00:19:34.750 --> 00:19:38.729
Toni Wahrstaetter: Voice and opinion on the hash versus root topic.

96
00:19:48.860 --> 00:19:55.230
Toni Wahrstaetter: Great, then let's move on to a second topic, which is how we want to handle self-destruct.

97
00:19:55.570 --> 00:20:09.439
Toni Wahrstaetter: So, as you might have seen in the… in the last few days, I've changed… I've modified the specs a bit, because there were some bugs around edge cases, and one of those edge cases were,

98
00:20:09.840 --> 00:20:16.519
Toni Wahrstaetter: self-destruct happening in the same transaction, so not send-all, but a real self-destruct. And…

99
00:20:17.580 --> 00:20:27.709
Toni Wahrstaetter: In the test cases, we planned to explicitly handle self-destructs by having a post nonce in the block level access list.

100
00:20:27.980 --> 00:20:29.719
Toni Wahrstaetter: That is set to zero.

101
00:20:30.070 --> 00:20:35.719
Toni Wahrstaetter: So usually, you would never see, in the block level access list, a post non-soft zero.

102
00:20:35.830 --> 00:20:47.269
Toni Wahrstaetter: But Rahul and me were thinking, okay, it might make sense to signal that a self-destruct happened by having post non-zero. What Charent was today saying in the… in the Discord chat is.

103
00:20:47.420 --> 00:21:02.460
Toni Wahrstaetter: that sims self-destructs in the same transaction are basically no ops, and they don't change any state, we should just only include them as if they were a read, so we include the address with no changes in the blocker access list.

104
00:21:03.010 --> 00:21:07.739
Toni Wahrstaetter: Of course, we include the balance changes if something was sent through the self-destruct.

105
00:21:07.890 --> 00:21:12.039
Toni Wahrstaetter: But we would not include nonce changes or code changes.

106
00:21:12.140 --> 00:21:18.040
Toni Wahrstaetter: And I wanted to double-check what clients think about it, and what would be the best way to handle a self-destruct.

107
00:21:18.170 --> 00:21:22.870
Toni Wahrstaetter: Maybe, Jared, you could also give us your rational behind.

108
00:21:23.270 --> 00:21:25.249
Jared Wasinger: Yeah, for sure.

109
00:21:25.380 --> 00:21:31.689
Jared Wasinger: just wanted to point out, also, that I don't think there would be a balance change in this case, because…

110
00:21:32.590 --> 00:21:33.940
Jared Wasinger: the…

111
00:21:35.370 --> 00:21:35.860
Toni Wahrstaetter: Right.

112
00:21:36.210 --> 00:21:43.060
Jared Wasinger: Yeah, it has to be non-existent in order for it to be deleted, created and deleted in the same transaction.

113
00:21:43.360 --> 00:21:45.690
Jared Wasinger: Yeah, I think you,

114
00:21:45.940 --> 00:21:53.850
Jared Wasinger: summarize my main point well, er, well, also, another thing that I was saying is that I feel like…

115
00:21:54.500 --> 00:22:01.330
Jared Wasinger: every other… In every other instance where we…

116
00:22:01.780 --> 00:22:11.809
Jared Wasinger: have account fields in the BAL, other… other than for storage reads. It, it's for…

117
00:22:12.220 --> 00:22:16.219
Jared Wasinger: A situation where the post state is different than the pre-state.

118
00:22:16.480 --> 00:22:25.880
Jared Wasinger: And so… Having this special case, for, for self-destructs.

119
00:22:26.260 --> 00:22:34.769
Jared Wasinger: Kind of breaks this… It's sort of just not consistent with the rest of the…

120
00:22:35.180 --> 00:22:38.410
Jared Wasinger: of the design for BALs,

121
00:22:40.230 --> 00:22:45.930
Jared Wasinger: Yeah, I'm not sure what direct effects that would have, but it's just kind of another…

122
00:22:46.380 --> 00:22:51.540
Jared Wasinger: Just seems kind of… Yeah.

123
00:22:52.650 --> 00:22:54.089
Toni Wahrstaetter: Yeah, you're totally right.

124
00:22:54.430 --> 00:23:06.259
Toni Wahrstaetter: Yeah, the question, the underlying question, maybe, would be, do we want to differentiate by just looking at the block access list, do we want to be able to differentiate between an account that is, for example.

125
00:23:06.410 --> 00:23:10.110
Toni Wahrstaetter: Accessed through balance opcode, or call opcode?

126
00:23:10.340 --> 00:23:16.479
Toni Wahrstaetter: Versus an account that is involved in a self-destruct. So, it is deployed in self-destruct.

127
00:23:16.760 --> 00:23:19.840
Toni Wahrstaetter: And it feels like there's no…

128
00:23:20.000 --> 00:23:31.270
Toni Wahrstaetter: we don't really need it, right? Because what we care about in Block Live Exorcist is really, like, what is the difference between the pre and the post state, or what actually changed, and what is the post state.

129
00:23:31.810 --> 00:23:38.959
Toni Wahrstaetter: And since there is no change involved, it might just make sense to treat it just like a read.

130
00:23:39.320 --> 00:23:41.530
Toni Wahrstaetter: Without any special meaning.

131
00:23:44.600 --> 00:23:45.200
Jared Wasinger: Yup.

132
00:23:45.400 --> 00:23:47.539
Jared Wasinger: I… I agree.

133
00:23:48.390 --> 00:23:55.439
Toni Wahrstaetter: Also, also, jargon to answer the question that you raised in the chat, why do we need special case for self-destruct?

134
00:23:55.550 --> 00:23:58.450
Toni Wahrstaetter: It does not remove the storage,

135
00:23:59.600 --> 00:24:06.230
Toni Wahrstaetter: the self-destruct that happens in the same transaction does remove the storage, right? It removes the storage that

136
00:24:06.900 --> 00:24:15.590
Toni Wahrstaetter: was there after the deployment, that you wrote to it after deployment, but compared to the pre-state, it would be the same. I guess that's what you're up to.

137
00:24:16.150 --> 00:24:17.070
Toni Wahrstaetter: So…

138
00:24:17.380 --> 00:24:25.220
Toni Wahrstaetter: If you have a self-destruct in the same transaction, then the pre-state and the post state would be the same, because the account is eventfully deleted.

139
00:24:25.570 --> 00:24:31.330
Toni Wahrstaetter: And the nonce would be reset to zero, which it was before the transaction.

140
00:24:39.150 --> 00:24:43.630
Toni Wahrstaetter: Yeah, it feels like this is, like, the cleanest way to go.

141
00:24:43.830 --> 00:24:45.740
Toni Wahrstaetter: But just to flag it.

142
00:24:47.460 --> 00:24:53.020
Toni Wahrstaetter: just reading the chat, what Philippe is saying, I guess the argument is to save space, yeah. Yeah, go ahead.

143
00:24:54.450 --> 00:25:02.289
Jared Wasinger: I guess we should also, include, like, so we should determine when you create a… an account.

144
00:25:02.890 --> 00:25:12.699
Jared Wasinger: within the same tran- and destroy it within the same transaction, but it reads storage. That kind of seems like it might be an edge case worth addressing in the specs.

145
00:25:16.250 --> 00:25:32.980
Jared Wasinger: So, an account that is deployed, and then it reads from another account, for example, the balance, and then it is… I mean, like, an account… account that is created in the transaction, it… it does something… it either writes or reads its own, storage…

146
00:25:34.270 --> 00:25:37.979
Jared Wasinger: and… and then self-destructs, like…

147
00:25:41.920 --> 00:25:45.159
Toni Wahrstaetter: Yeah, this is interesting. Yeah, go ahead.

148
00:25:45.390 --> 00:25:49.250
Marius van der Wijden: Those streets and rights would not end up in the tri anywhere, right?

149
00:25:50.370 --> 00:25:51.620
draganrakita: That's a good question.

150
00:25:51.740 --> 00:25:53.890
draganrakita: That's the questions I wanted to ask.

151
00:25:54.150 --> 00:26:00.530
Jared Wasinger: They wouldn't… I'm saying, test coverage, it's worth it to have that case be.

152
00:26:01.080 --> 00:26:04.139
Marius van der Wijden: Yeah, definitely, we need to find that.

153
00:26:04.620 --> 00:26:05.440
Marius van der Wijden: Yep.

154
00:26:05.750 --> 00:26:11.799
draganrakita: The question is, if account is created, and some storages are accessed.

155
00:26:11.910 --> 00:26:14.779
draganrakita: Does those stages get included in the bowl?

156
00:26:19.520 --> 00:26:20.510
Marius van der Wijden: Yes.

157
00:26:20.710 --> 00:26:29.539
Marius van der Wijden: If the account is not self-destructed, then yes. If the account is self-destructed, then the same… Transaction, then no.

158
00:26:31.350 --> 00:26:33.060
draganrakita: So that will be a difference.

159
00:26:33.560 --> 00:26:38.329
draganrakita: That would be a big difference, because if you just… but what if you, like…

160
00:26:38.730 --> 00:26:44.439
draganrakita: Create account, then access some… just load the storage.

161
00:26:44.650 --> 00:26:46.810
draganrakita: You still want to have it in the reads.

162
00:26:46.990 --> 00:26:48.929
draganrakita: But if you create an account.

163
00:26:49.430 --> 00:26:54.300
draganrakita: check some storage, then self-destruct. You don't want to have that storage.

164
00:26:54.830 --> 00:26:55.930
draganrakita: Indeed.

165
00:26:58.210 --> 00:27:07.199
Jared Wasinger: Honestly, I think it's… it probably is such a rare enough occurrence that it… it should just be included in the BAL, and we shouldn't have a special case.

166
00:27:10.930 --> 00:27:30.570
Toni Wahrstaetter: Yeah, I tend to agree with that. So there… it feels like there are two cases. We deploy an account that then accesses something from a different account. For example, I deploy a contract that then accesses, I don't know, USDC, and then I self-destruct. Versus, I have a contract that is deployed.

167
00:27:30.670 --> 00:27:37.029
Toni Wahrstaetter: It accesses its own storage, or writes to its own storage, And then self-destruct.

168
00:27:37.130 --> 00:27:37.890
Toni Wahrstaetter: Right?

169
00:27:38.130 --> 00:27:43.289
Toni Wahrstaetter: Because for the first case, if we change some… if we change something in a different account.

170
00:27:43.560 --> 00:27:47.770
Toni Wahrstaetter: we still want to include it in the block lab access list, even though

171
00:27:48.250 --> 00:27:51.630
Toni Wahrstaetter: The account that is calling is self-destructed.

172
00:27:51.990 --> 00:27:57.219
Toni Wahrstaetter: It's more about what do we do about the account that is, in the end, self-destructed.

173
00:27:57.470 --> 00:28:03.320
Toni Wahrstaetter: And there it feels, like what Jared just said, we just include everything that is accessed along the way.

174
00:28:03.560 --> 00:28:05.940
Toni Wahrstaetter: in the block lab access list as a read.

175
00:28:17.360 --> 00:28:21.329
Toni Wahrstaetter: Okay, great. Currently the specs are off on that.

176
00:28:21.530 --> 00:28:41.509
Toni Wahrstaetter: on that front, because we, I just pushed something to the specs, like, yesterday, so you might see those, commits with fixed self-destruct logic or something. I will revert those so that the specs actually match what we… match the ERP again, and I might also clarify that further in the ERP.

177
00:28:41.950 --> 00:28:45.890
Toni Wahrstaetter: To make sure that we include all state

178
00:28:46.640 --> 00:28:54.219
Toni Wahrstaetter: Including addresses and storage keys that are accessed during, until the self destruct in the block lab access list.

179
00:28:54.540 --> 00:28:57.200
Toni Wahrstaetter: Is there any other edge case,

180
00:28:57.520 --> 00:28:59.850
Toni Wahrstaetter: We should, think about when…

181
00:29:00.310 --> 00:29:03.499
Toni Wahrstaetter: changing the EAP or the specs that I forgot.

182
00:29:06.630 --> 00:29:09.450
Jared Wasinger: I think you mentioned it earlier, but there was the other…

183
00:29:09.580 --> 00:29:12.730
Jared Wasinger: Just the stuff about the precompiles.

184
00:29:14.180 --> 00:29:18.480
Jared Wasinger: Calling a pre-compiled address would be included as a read.

185
00:29:19.820 --> 00:29:20.780
Jared Wasinger: But, yeah.

186
00:29:22.290 --> 00:29:26.519
Toni Wahrstaetter: Yeah, this is another thing that is underspecified in the AP. Yeah, I agree.

187
00:29:26.720 --> 00:29:34.030
Toni Wahrstaetter: And it will probably be specified, like, all the precompiled addresses that are accessed.

188
00:29:34.190 --> 00:29:37.990
Toni Wahrstaetter: in a transaction must be included as a read.

189
00:29:40.380 --> 00:29:45.850
Toni Wahrstaetter: Which would mean including only the account with all MTA changes.

190
00:29:49.760 --> 00:29:57.539
Toni Wahrstaetter: The question is, do we really need it? Because, for example, we assume precompiles are warm by default, for example.

191
00:29:57.770 --> 00:30:01.659
Toni Wahrstaetter: Do we really need to know, which pre-compiles are accessed?

192
00:30:03.520 --> 00:30:08.229
Toni Wahrstaetter: Because it's different for every other part of the state that actually

193
00:30:08.650 --> 00:30:11.170
Toni Wahrstaetter: Has something on disk behind it.

194
00:30:21.360 --> 00:30:25.359
Jared Wasinger: to be honest, I'm… I'm not actually sure in Geth if we…

195
00:30:25.670 --> 00:30:34.909
Jared Wasinger: if the code path for executing precompiles would result in them being included in the BAL as a read currently. I mean, I could see…

196
00:30:35.110 --> 00:30:38.860
Jared Wasinger: The justification for… omitting them.

197
00:30:39.610 --> 00:30:49.480
Jared Wasinger: I don't… I personally don't really lean strongly either way, as long as it's… specified.

198
00:30:50.750 --> 00:30:57.670
draganrakita: What about if we transfer some value, it, to the… We compiled.

199
00:30:58.300 --> 00:31:08.840
Toni Wahrstaetter: Yeah, this is different. In that case, you must include it. So if you… if you send to the precompile, we always have the balanced diff of that precompile.

200
00:31:09.040 --> 00:31:11.139
Toni Wahrstaetter: In the block file access list.

201
00:31:11.410 --> 00:31:15.910
Toni Wahrstaetter: It's more like… Should we include the precompile?

202
00:31:16.390 --> 00:31:17.599
Toni Wahrstaetter: as a read.

203
00:31:17.750 --> 00:31:25.140
Toni Wahrstaetter: For example, if a storage key is red, then we have the storage read change in the account changes object.

204
00:31:25.280 --> 00:31:31.329
Toni Wahrstaetter: If an account is read, for example, through the call-up code, or static call, or balance, and so on.

205
00:31:31.550 --> 00:31:36.480
Toni Wahrstaetter: Then, we have an account in the block club access list with all empty changes.

206
00:31:36.600 --> 00:31:46.540
Toni Wahrstaetter: And what I would think is if we… so we don't have a mapping to a transaction index for REITs, right? This is important to, note here.

207
00:31:46.690 --> 00:31:51.670
Toni Wahrstaetter: So we don't have a mapping from reads in the block of exorcists to the

208
00:31:51.780 --> 00:31:54.979
Toni Wahrstaetter: Transaction indices, which would mean for precompiles.

209
00:31:55.090 --> 00:32:03.199
Toni Wahrstaetter: we would know, okay, this precompile will be accessed in this block, but we would not be able to map it to a transaction, just like

210
00:32:03.400 --> 00:32:14.079
Toni Wahrstaetter: we cannot map any read in the block level access list to transactions. So, I lean towards omitting the precompiles from the reads.

211
00:32:15.030 --> 00:32:17.410
Toni Wahrstaetter: Yeah.

212
00:32:18.020 --> 00:32:23.239
Toni Wahrstaetter: But I'm happy if it's, like, simpler to just add them, I'm also happy to do that.

213
00:32:24.550 --> 00:32:29.240
draganrakita: Just imagine if we have balance of code that targets pre-compiled.

214
00:32:29.690 --> 00:32:32.800
draganrakita: So, in that case, we'll have something different.

215
00:32:33.630 --> 00:32:44.550
draganrakita: Where we need to omit pre-compilers to get that case, yeah. For the calls, that's more specific to precompiles, because there is some different path, other than executing the contract.

216
00:32:46.210 --> 00:32:47.160
draganrakita: Yeah.

217
00:32:47.450 --> 00:32:53.920
draganrakita: To be honest, I would… yeah, I would include it, but I don't have strong stance here.

218
00:32:55.370 --> 00:32:57.659
Toni Wahrstaetter: Thank you very much, Lucas.

219
00:32:57.660 --> 00:33:07.939
Łukasz Rozmej: I'm for omitting it, because we don't even track it internally. I know that GEF tracks it internally, but we have a simple if in code, and we can just not track them, which…

220
00:33:08.260 --> 00:33:10.989
Łukasz Rozmej: It's just also an additional optimization.

221
00:33:11.520 --> 00:33:17.609
Łukasz Rozmej: So I would, I would admit that it's worthless information, in my opinion.

222
00:33:20.430 --> 00:33:24.779
Toni Wahrstaetter: Yeah, I agree with that, but it feels like it would be an edge case

223
00:33:25.030 --> 00:33:28.100
Toni Wahrstaetter: Compared to how we track all other calls.

224
00:33:28.210 --> 00:33:34.099
Toni Wahrstaetter: Because suddenly we would be like, okay, now a precompile is called, so we don't care.

225
00:33:39.930 --> 00:33:42.719
Łukasz Rozmej: Okay, but what's the purpose? Just completeness?

226
00:33:44.750 --> 00:33:53.179
Toni Wahrstaetter: Yeah, or using existing code. For example, if you put the tracking function on top of the call.

227
00:33:53.840 --> 00:34:00.659
Toni Wahrstaetter: Then you don't need any edge cases to handle a call to a pre-compile differently to a call to any other contract.

228
00:34:04.890 --> 00:34:15.529
Toni Wahrstaetter: At least in the specs, I think in the specs it's tracked right now, because in the specs, there is basically a tracker that wraps around all the state changes.

229
00:34:15.860 --> 00:34:24.510
Toni Wahrstaetter: And it doesn't differentiate between a pre-compiled being called or any other contract. If I remember correctly, I would also need to double-check that.

230
00:34:28.290 --> 00:34:39.939
draganrakita: And if we compare this behavior with access list, we are including only the accounts from… not all accounts from Axis, but only accounts that got, accessed.

231
00:34:41.570 --> 00:34:45.199
draganrakita: It's a slightly different version, but… Yeah.

232
00:34:49.050 --> 00:34:50.060
Toni Wahrstaetter: Right, yeah.

233
00:34:50.060 --> 00:34:56.129
draganrakita: Yeah, you can argue that you can remove all the accounts that are found inside access list.

234
00:34:58.100 --> 00:35:02.579
draganrakita: I don't think that nobody wants that, but just for the argument's sake.

235
00:35:03.870 --> 00:35:10.360
Toni Wahrstaetter: Yeah, currently we treat, for example, no matter if a balance opcode happens or a call opcode, we treat it exactly the same.

236
00:35:10.560 --> 00:35:27.589
Toni Wahrstaetter: And here, for example, if a transaction calls the balance of a precompile, then we would need to add it, right? No matter if we decide to omit the precompile reads or not, we would need to add it, because we do want to know that this contract is going to be read.

237
00:35:28.440 --> 00:35:33.310
Toni Wahrstaetter: But on the other hand, if a precompile is called, Doing some computation.

238
00:35:33.750 --> 00:35:36.729
Toni Wahrstaetter: Then we would need to manually omit it.

239
00:35:37.110 --> 00:35:42.920
Toni Wahrstaetter: And to me, right now, it feels like it would be cleaner To just keep them.

240
00:35:43.400 --> 00:35:53.449
Toni Wahrstaetter: in there, but I can see the argument why this might just be unnecessary data, if this precompile is, like, called.

241
00:35:54.290 --> 00:35:59.240
Toni Wahrstaetter: Yeah, with something like call or static call.

242
00:36:02.010 --> 00:36:04.039
Marc: I mean, it seems like it would be…

243
00:36:04.470 --> 00:36:11.819
Marc: Relatively easier to, if you are tracking it, just have an exception and not log the precompiles than to…

244
00:36:12.250 --> 00:36:15.629
Marc: Like, for… on our side to change stuff.

245
00:36:15.800 --> 00:36:19.610
Marc: So that we are tracing these accesses.

246
00:36:21.850 --> 00:36:27.629
Marc: Yeah, it just seems easier to… the other way around, I guess, and also the data isn't really useful.

247
00:36:30.710 --> 00:36:38.390
Toni Wahrstaetter: So, you would also say we should omit the reads. So, every time when a precompile is,

248
00:36:38.720 --> 00:36:41.699
Toni Wahrstaetter: Access through call or static call.

249
00:36:41.800 --> 00:36:49.679
Toni Wahrstaetter: it should not be included in the popular access list, but if it is accessed through balance, or Xcode size, or something, then we should include it.

250
00:36:50.820 --> 00:36:52.170
Marc: Yup, I think so.

251
00:37:03.320 --> 00:37:04.730
Toni Wahrstaetter: Okay.

252
00:37:06.210 --> 00:37:08.479
Toni Wahrstaetter: Any other opinions on that?

253
00:37:18.960 --> 00:37:22.349
draganrakita: Yeah, well, I'm not sure if this is to type, but yeah.

254
00:37:23.360 --> 00:37:32.400
draganrakita: In that case, we'll have, like, the different behaviors, depending on if it's call opcode, or it's balance opcode, or some else, by the opcode.

255
00:37:32.400 --> 00:37:33.150
Toni Wahrstaetter: Right.

256
00:37:34.230 --> 00:37:41.960
Toni Wahrstaetter: Yeah, I have no insight into client code, but I can definitely tell in the specs and the execution specs, this will make things a little dirtier.

257
00:37:42.210 --> 00:37:53.010
Toni Wahrstaetter: I guess there will be a simple way to change it, but this is the first time I really have to… I would really have to differentiate between call and balance, for example.

258
00:38:02.120 --> 00:38:06.700
Marc: I guess I don't have a super strong opinion, like, maybe if I could…

259
00:38:07.250 --> 00:38:11.600
Marc: Kind of look at the code a bit more, and if it turns out to be, like.

260
00:38:12.700 --> 00:38:15.229
Marc: A lot more com- complex, and…

261
00:38:15.730 --> 00:38:18.939
Marc: Yeah, I just need to review it, really, to kind of determine.

262
00:38:22.030 --> 00:38:23.399
Toni Wahrstaetter: Yeah, sounds good.

263
00:38:23.850 --> 00:38:32.150
Toni Wahrstaetter: I would say we, for now, we just keep it as is. Right now, it's kind of underspecified in the EUP, but

264
00:38:32.460 --> 00:38:38.470
Toni Wahrstaetter: I will add some proper specifications on that, but right now it would be tracked.

265
00:38:38.650 --> 00:38:54.539
Toni Wahrstaetter: So, if it's accessed through a call, it's in the block of access list, and if it's accessed through a balance, opcode, it's also in there. And if… if the precompiler even sees a balance change, it's even in there with a balance change.

266
00:38:55.920 --> 00:38:58.459
Toni Wahrstaetter: Map to the transaction index.

267
00:38:59.070 --> 00:39:08.430
Toni Wahrstaetter: We can still, re-evaluate that decision in, like, in two weeks. I think it's good that we brought it up, and clients have,

268
00:39:08.670 --> 00:39:13.339
Toni Wahrstaetter: Clients know that this is something we should look into and get some clearance on it.

269
00:39:13.950 --> 00:39:20.300
Toni Wahrstaetter: But then I would say, let's just, yeah, keep it as is, and if we decide in two weeks that

270
00:39:20.650 --> 00:39:25.080
Toni Wahrstaetter: Yeah, we were wrong, and we should actually do it differently, we can still do it.

271
00:39:38.280 --> 00:39:39.230
Toni Wahrstaetter: Right.

272
00:39:39.920 --> 00:39:52.670
Toni Wahrstaetter: Yeah, this was, the last, topic we had on the agenda. Last thing would be just client updates. Should we directly start with Jared Gaffigan?

273
00:39:54.850 --> 00:40:04.070
Jared Wasinger: Yeah, sure. I… I think we had one more thing we wanted to talk about, actually.

274
00:40:04.180 --> 00:40:11.940
Jared Wasinger: Well, I brought it up in the chat today, so there was this idea in the BAL

275
00:40:12.080 --> 00:40:21.409
Jared Wasinger: to… there's this idea to commit in the BAL to the, the post…

276
00:40:21.650 --> 00:40:35.470
Jared Wasinger: state, try root for, storage tries, and essentially what that would enable us to do is fully parallelize the account try and storage try, hashing.

277
00:40:35.660 --> 00:40:43.019
Jared Wasinger: And I had brought that up as a… because that was a suggestion from Gary on our team, but,

278
00:40:43.910 --> 00:40:48.430
Jared Wasinger: Just wanted to say that,

279
00:40:48.660 --> 00:40:55.760
Jared Wasinger: It's not clear from the guest side whether… what the benefit of that change would potentially bring.

280
00:40:55.970 --> 00:41:03.390
Jared Wasinger: But the reason I brought it up in the channel was to, to,

281
00:41:04.660 --> 00:41:10.649
Jared Wasinger: Just try and put it on people's radars as something to explore.

282
00:41:10.920 --> 00:41:17.650
Jared Wasinger: And we will definitely be doing that, yeah.

283
00:41:19.170 --> 00:41:26.150
Toni Wahrstaetter: Okay, yeah, this is interesting. Just to summarize, this would mean the block of access list would additionally

284
00:41:26.300 --> 00:41:32.769
Toni Wahrstaetter: Contain, for each account, The post-storage route of that account.

285
00:41:33.310 --> 00:41:46.749
Jared Wasinger: So, yeah, so if the account had modified storage, we would include the root. I mean, we could, of course, include the root for every account, but we could also… it could be limited to ones with modified storage.

286
00:41:48.550 --> 00:41:50.840
Toni Wahrstaetter: Okay, and it will be the post…

287
00:41:51.150 --> 00:41:55.489
Toni Wahrstaetter: State of the post, the state after the block, and not,

288
00:41:56.120 --> 00:41:56.670
Jared Wasinger: Yeah, exactly.

289
00:41:56.670 --> 00:41:58.469
Toni Wahrstaetter: Each transaction, right? Okay.

290
00:42:00.790 --> 00:42:11.910
Toni Wahrstaetter: Yeah, this is definitely interesting. Curious if other clients… we don't need to decide upon that today, and I think Gary even said he wants to keep that on client-level optimization.

291
00:42:12.520 --> 00:42:15.029
Toni Wahrstaetter: But they are curious if other clients…

292
00:42:15.190 --> 00:42:18.470
Toni Wahrstaetter: Clients have an opinion on that, or thought about it.

293
00:42:20.840 --> 00:42:28.610
Toni Wahrstaetter: I see Karim advocating Even for putting it into the popular access list, I guess?

294
00:42:33.630 --> 00:42:36.330
Karim T.: is for computation, I think it would be nice to…

295
00:42:36.580 --> 00:42:46.109
Jared Wasinger: I guess I'll just say that my impression right now is that most of our bottleneck with the state root update is in loading the intermediate nodes, so…

296
00:42:46.550 --> 00:42:55.419
Jared Wasinger: It's not clear in the end how much this… how much being able to fully parallelize the updates between the account try and the storage tries will bring, but…

297
00:42:57.530 --> 00:43:03.209
Karim T.: I think in Bezoo, we have this kind of preloading, so we can preload,

298
00:43:03.360 --> 00:43:12.610
Karim T.: Intermediate node, and today the main part is doing the… Okay, check computation of intermediates.

299
00:43:12.850 --> 00:43:17.629
Karim T.: And mainly also for the account part, because the storage are done in parallel.

300
00:43:17.780 --> 00:43:20.809
Karim T.: So I think if we can, at the same time…

301
00:43:21.120 --> 00:43:27.179
Karim T.: compute the state root of the tree account. I think it will help for performance, but I'm not completely sure.

302
00:43:35.060 --> 00:43:39.480
Toni Wahrstaetter: Yeah, this is definitely an interesting change. I think we should…

303
00:43:39.700 --> 00:43:47.130
Toni Wahrstaetter: Proceed with it, you know, and then we first get some more data, how much we would actually get from that.

304
00:43:47.340 --> 00:43:58.220
Toni Wahrstaetter: keep the design of blocker access list as it is right now, and just keep it in our… yeah, in our mind that this is, a simple optimization, because

305
00:43:58.420 --> 00:44:03.389
Toni Wahrstaetter: Just in terms of additional data footprint, it wouldn't add that much.

306
00:44:03.640 --> 00:44:10.070
Toni Wahrstaetter: So it's, it would only be, like, 32 bytes per changed account, so this would not be the problem.

307
00:44:10.440 --> 00:44:14.110
Toni Wahrstaetter: But yeah, let's keep it as it is for now, and…

308
00:44:15.380 --> 00:44:21.760
Toni Wahrstaetter: In case we ever, need to speed up, the hashing.

309
00:44:22.010 --> 00:44:23.569
Toni Wahrstaetter: Then we can still edit.

310
00:44:29.260 --> 00:44:31.000
Jared Wasinger: Yep, I agree.

311
00:44:35.700 --> 00:44:40.749
Toni Wahrstaetter: Great, yeah, thanks for reminding me, almost forgot that point. Any other opinion on that?

312
00:44:49.140 --> 00:44:54.619
Toni Wahrstaetter: If not, I would just suggest we continue with the client updates.

313
00:44:56.290 --> 00:44:59.480
Jared Wasinger: Yeah, sure, I can give a brief update,

314
00:44:59.600 --> 00:45:10.570
Jared Wasinger: there's not too much that has changed from our side to report here. We're still… we're working on improving the performance right now, and…

315
00:45:13.250 --> 00:45:23.989
Jared Wasinger: assisting where possible with the DevNet work. So right now, most of the bottleneck for us is in Geth is the…

316
00:45:24.280 --> 00:45:28.300
Jared Wasinger: state route update, so that's where…

317
00:45:29.060 --> 00:45:33.740
Jared Wasinger: That's where we have and will be focusing on in the immediate future.

318
00:45:35.140 --> 00:45:36.820
Jared Wasinger: And, yeah, that's it.

319
00:45:39.080 --> 00:45:39.960
Toni Wahrstaetter: Thank you.

320
00:45:40.540 --> 00:45:42.700
Toni Wahrstaetter: And what about Millamide?

321
00:45:46.330 --> 00:45:59.339
Marc: On my side, just, trying to get our implementation to pass the execution spec tests, just debugging a few differences in the, encoding format.

322
00:45:59.570 --> 00:46:01.170
Marc: Yeah, that's fun.

323
00:46:06.260 --> 00:46:14.569
Toni Wahrstaetter: Thanks, yeah, and just to add on that, also one of the execution spec tests is now wrong, the one affecting self-destruct, so ignore.

324
00:46:14.680 --> 00:46:18.909
Toni Wahrstaetter: this one for now, Rahul will fix that, as sooner.

325
00:46:19.320 --> 00:46:21.140
Toni Wahrstaetter: As I fix the spec.

326
00:46:22.260 --> 00:46:25.809
Toni Wahrstaetter: Just as a notice. Let's continue with Bezo.

327
00:46:27.030 --> 00:46:38.240
Karim T.: Yeah, so today we implemented the engine API, we are passing the reference test. We are trying to run a local devnet with Git and Bizu.

328
00:46:38.580 --> 00:46:48.040
Karim T.: But for the moment, we can see that the blocks created by Bezo are refused by GET, so we are trying to investigate why.

329
00:46:48.400 --> 00:46:54.869
Karim T.: But I'm not completely sure, but it seems that the block created by GET are accepted by Viso.

330
00:46:55.320 --> 00:47:01.660
Karim T.: So… so the next step is to debug and understand why our block access is not valid.

331
00:47:06.970 --> 00:47:10.700
Toni Wahrstaetter: Interesting. So you… this might be something we didn't…

332
00:47:10.930 --> 00:47:15.630
Toni Wahrstaetter: Catch, we didn't call with the… With the test yet?

333
00:47:16.370 --> 00:47:23.359
Karim T.: I think yes, but for the moment, we just saw that before the meeting, so we didn't have time to… to check more.

334
00:47:23.540 --> 00:47:27.550
Karim T.: But, I feel that, yeah, maybe we are missing something in the testing.

335
00:47:30.560 --> 00:47:32.240
Toni Wahrstaetter: Okay, thank you.

336
00:47:33.200 --> 00:47:35.060
Toni Wahrstaetter: Aragon?

337
00:47:40.590 --> 00:47:42.829
Toni Wahrstaetter: Is someone from Aragon here?

338
00:47:45.690 --> 00:47:48.299
Toni Wahrstaetter: Otherwise, let's continue with ref.

339
00:47:55.790 --> 00:47:56.590
draganrakita: Pushka?

340
00:47:57.360 --> 00:48:01.769
Ishika: Yes, not, much we got to do.

341
00:48:01.770 --> 00:48:21.639
Ishika: Concerning the changes, we were running the new sets of the, tests, and, like, it works pretty well with the consume RLP, but we have some blockers concerning the consumer engine. We are currently looking into the locks and trying to investigate the causes. We'll come to a conclusion soon, I believe. Yeah.

342
00:48:24.890 --> 00:48:33.870
felipe: I'd like to… Yep. About the test, too. The latest release, so if it's for Consume Engine.

343
00:48:34.200 --> 00:48:39.400
felipe: We do have updates there. We were using V4 instead of V5.

344
00:48:39.610 --> 00:48:47.730
felipe: And so, I'd like to get a new release out, that has all of the updates, and I'm planning on

345
00:48:47.860 --> 00:48:50.020
felipe: Getting this out by today.

346
00:48:50.270 --> 00:48:53.229
felipe: So look out for a new release of the tests.

347
00:48:59.790 --> 00:49:01.880
Toni Wahrstaetter: Awesome. Thank you very much.

348
00:49:06.690 --> 00:49:13.940
Toni Wahrstaetter: Great. Is there anything else we should discuss on this call? Something we should bring up?

349
00:49:22.660 --> 00:49:28.560
Toni Wahrstaetter: If not… I would suggest we can end the call at this point.

350
00:49:33.290 --> 00:49:34.270
Toni Wahrstaetter: Great.

351
00:49:34.830 --> 00:49:36.739
Toni Wahrstaetter: Dan, thank you very much, Erwin.

352
00:49:37.150 --> 00:49:38.850
Toni Wahrstaetter: And see you on the next one.

353
00:49:38.960 --> 00:49:40.390
Toni Wahrstaetter: Call in 2 weeks.

354
00:49:42.340 --> 00:49:42.950
Marc: Right?

355
00:49:44.060 --> 00:49:44.630
Karim T.: What?

356
00:49:46.210 --> 00:49:47.300
felipe: Thanks, bye.

357
00:49:47.300 --> 00:49:47.960
Łukasz Rozmej: Bye.

