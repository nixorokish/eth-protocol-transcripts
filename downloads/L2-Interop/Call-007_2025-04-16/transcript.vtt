WEBVTT

1
00:12:49.200 --> 00:12:50.180
Joshua Rudolf: Yeah. Then.

2
00:13:50.910 --> 00:13:52.240
Joshua Rudolf: Hello.

3
00:14:08.560 --> 00:14:10.449
Joshua Rudolf: Hello, Ellie Galen.

4
00:14:12.000 --> 00:14:13.260
Joshua Rudolf: Everybody else

5
00:14:18.050 --> 00:14:21.829
Joshua Rudolf: getting bombarded with AI requests

6
00:14:36.580 --> 00:14:40.310
Joshua Rudolf: cool. We'll just give folks another minute.

7
00:14:45.990 --> 00:14:46.839
Orest Tarasiuk (t1): Hey, guys.

8
00:14:48.080 --> 00:14:48.960
Joshua Rudolf: Hey horisto.

9
00:14:50.280 --> 00:14:50.960
Victor | RISC Zero / Boundless: Hello!

10
00:14:52.150 --> 00:14:52.740
QEDK: Okay.

11
00:14:54.070 --> 00:14:55.290
Joshua Rudolf: Hello, Hello!

12
00:14:56.370 --> 00:14:59.640
Joshua Rudolf: We'll get started here in just a few seconds.

13
00:15:22.910 --> 00:15:43.250
Joshua Rudolf: Okay, I think let's get started. So today's call will be focused on 7,786, and finding the most effective pragmatic path forward for unified message packing message passing across all of ethereum. The goal of today's call is to take a look at 7,786 as a strong candidate for this.

14
00:15:43.350 --> 00:15:52.159
Joshua Rudolf: Evaluate the bull case, and I guess, see what questions or areas of concerns people might have.

15
00:15:52.370 --> 00:16:08.240
Joshua Rudolf: I guess. I also want to note that with any standardization effort, the default, of course, is lots of debate and discussion without ever shipping anything that gets into the hands of users. So I do think we all have a shared goal and recognize the

16
00:16:08.360 --> 00:16:13.219
Joshua Rudolf: urgency to fixing the fragmentation problem. And I think the best thing we can do here is to

17
00:16:13.360 --> 00:16:19.819
Joshua Rudolf: continue to bring that sense of urgency and pragmatism to this discussion without losing track of

18
00:16:20.110 --> 00:16:41.280
Joshua Rudolf: certain key values and the need for broad buy-in, of course. So yeah, at a certain point, we'll need to pick a direction and accelerate on it so that we can continue to actually solve interop in 2025. I say that sort of tongue in cheek. Of course, you know there's it's solving. Interop is going to be a long journey. But I do think that

19
00:16:41.550 --> 00:16:53.560
Joshua Rudolf: I think we all agree that there's a lot that we will continue to do in 2025. So, yeah, thanks. All for joining. And I guess with that little intro, we can. Yeah, I'll just kick things off. I think we want to start with a brief overview of

20
00:16:53.880 --> 00:16:56.000
Joshua Rudolf: of where we are, with the with the standard.

21
00:16:58.366 --> 00:16:59.360
Ellie Davidson: Yeah. So

22
00:16:59.460 --> 00:17:18.039
Ellie Davidson: I guess to give maybe a little extra context. You know, specifically this debate. I think it should. It would be very useful if it really focuses on like the value that 7, 7, 8, 6 is providing over, like, you know, the specific implementation details which we can discuss in another forum is Sergey on to give a presentation.

23
00:17:18.780 --> 00:17:20.059
sergey: Guys. Yep, I'm here.

24
00:17:20.260 --> 00:17:27.270
Ellie Davidson: Okay, cool. So yeah, Sergey from Axilar is going to give kind of a presentation that overviews what? 7, 7, 8, 7, 7, 8, 6 is.

25
00:17:29.030 --> 00:17:33.780
sergey: Yup, happy to do that. Share a couple of slides.

26
00:17:35.120 --> 00:17:45.269
sergey: Hopefully, you guys can see. Yeah, for a little bit of context and background. You know, Sergey. I work on actually, these days, you know, prior to this, I worked on the outground protocol.

27
00:17:45.270 --> 00:18:05.360
sergey: My general view on standards is to do them only if and when necessary. I'm not a fan of standards overall, but I'll do them kind of a you know, or think there's a need for them when things are not moving fast enough. And I think for the ethereum community, it's pretty important to move fast on these things.

28
00:18:05.720 --> 00:18:28.020
sergey: A little bit of context. I also helped to standardize bls signatures. That you know, that was in the draft that ended up being adopted for the consensus at the ethereum community that was back when I was a bail grant and led a you know, cryptography group there, and there was pretty similar, you know, time horizon at that time, where I think a lot of different implementations existed

29
00:18:28.020 --> 00:18:38.739
sergey: that couldn't really agree with one another. Right? So like, I've seen cases at that time where somebody would produce signatures that would not be verified in like other implementations. And everybody was just, kinda you know, stuck. And I think

30
00:18:39.194 --> 00:18:56.700
sergey: you know we came together with the community, and you know ethereum folks and you know Stanford folks and a few others, and push that through. And I think unification of message passing for similar reasons is in a you know, need hopefully, we'll get standardized and moved along.

31
00:18:57.280 --> 00:19:00.630
sergey: So why, 7, 7, 8, 6

32
00:19:00.850 --> 00:19:12.309
sergey: In general. The way I view things is that interoperability is composed in layers. You have at the very core of it very basic primitives that are responsible for the transport of messages.

33
00:19:12.440 --> 00:19:28.180
sergey: You have security properties that interoperability provides, and security can differ based on the method of validation. You could have external validation. You can have, you know, like lines, you can have 0 knowledge proofs, and then you have application layer protocols

34
00:19:28.860 --> 00:19:33.569
sergey: if we think about it and standardize things in the right way in the modular way.

35
00:19:33.650 --> 00:19:41.403
sergey: then things can be evolving, and, you know, improving independently from one another. Right? So

36
00:19:41.970 --> 00:20:06.410
sergey: and I think that's really been has one of one of the philosophies. And how we approached. You know, this, this pack is making sure it's as minimal as possible, right? Making sure it only does the very simple things that are necessary so that other applications and other modules can be plugged in around it, and, you know, evolve and approve in an independent way.

37
00:20:06.750 --> 00:20:14.199
sergey: So all interrupt protocols at the very core of it. Rely on basic ability to be able to take a message and deliver it on the destination chain.

38
00:20:14.360 --> 00:20:23.210
sergey: all of them right intense. You have broadcast protocols, you have, you know, token, transfer protocols token, issuance, protocols.

39
00:20:24.310 --> 00:20:42.054
sergey: whether or not you they do it for every message they batch things. They all need to cross chain messaging. And you know, in the same way you can think of all the L twos whenever they post state to l 1. You know it's a message that's being delivered. So really agreeing what the message specification is.

40
00:20:42.440 --> 00:21:00.210
sergey: is, you know, very, very critical and very, very important. Once you have the consistent, essentially Api for sending messages, applications, and all kinds of middleware can be built in parallel independently and evolve, and you know, advance very very rapidly.

41
00:21:01.630 --> 00:21:26.339
sergey: Now, why, I think it's important to to standardize this Api. Well, Api by itself doesn't have any its own value, you know, regardless to what you know a lot of interrupt players will will will try to say at the very simplistic case. You can think of it as really kind of a header of an envelope. Okay? That specifies how you send the message from a source to a destination. Very simple. It

42
00:21:26.340 --> 00:21:50.591
sergey: ask things like, Who's the sender? What is the sending address? What is the destination address? What is the destination chain? You can debate, and we can discuss, and you know we should discuss and incorporate various feedback. Whether the you know data types for all these things, what are the additional fields that may be included with it? But at the end of the day. It's, you know. It's a very simple Api, and it's a very simple kind of header of the of the envelope.

43
00:21:50.910 --> 00:22:17.269
sergey: simplest way to think about. It is like IP packet. If you're familiar very, very simplistically. Who sends the packets? To whom? And then you have the rest of the you know. Tcp, IP. Stack being built on top of it that has various properties, you know, delivery on security, and so on and so forth. So you know if you're familiar with the networking stack. I think this back takes, you know, a lot of philosophical differences or philosophical similarities with the with the with the standard networking. You know. Protocols?

44
00:22:20.360 --> 00:22:45.879
sergey: yeah. So 7, 7, 8, 6, you know, opens up and led the the development of it with consultation of some of our engineers at Axler and a lot of other industry experts. And the goal has really to propose something that's neutral and agnostic of any specific vendor. So it doesn't follow directly. You know, acceler specifications it doesn't follow anybody specific implementations.

45
00:22:45.880 --> 00:22:55.879
sergey: But it is close enough to everybody in some sense, so anybody can take, and, you know, adjust their Apis inspect to follow. The same you know, header

46
00:22:56.175 --> 00:23:07.419
sergey: of this of this envelope. It's not that complicated, but as soon as we agree, then everybody can can start building their, you know their middleware and services around it and keep building on top of it.

47
00:23:08.621 --> 00:23:30.880
sergey: It's open, you know. You can take a look at it. Please comment. I don't think you know, as Ellie said, we want to get into too many, you know, technical debates, you know, on on this call primarily, its purpose is to educate. But absolutely, please comment and give any feedback that you have on top of it. And open Zeppelin team, you know, and everyone else involved. We'll we'll be happy to to iterate around.

48
00:23:33.445 --> 00:23:48.409
sergey: Why, it's important to do now, I think. So number one, I think timing is right. I think, as I opened up, like, you know, I kind of said that generally I don't like standards. I think the industries move a lot faster. In many cases.

49
00:23:48.410 --> 00:24:04.900
sergey: except when standards become a bottleneck. And I think in ethereum community a lack of the standard is really a bottleneck that I keep on seeing over and over again, and incompatibility between different products and services that people are building across the ecosystem, I think, set everything back. So.

50
00:24:05.819 --> 00:24:13.779
sergey: I think you know, standardizing it very, very simply will allow all the different vendors to keep on building

51
00:24:14.100 --> 00:24:22.022
sergey: their unique security properties, their unique, you know, Api services, intent services, everything else around it much, much faster.

52
00:24:22.600 --> 00:24:29.450
sergey: This. This spec has been in consultation with us and other internal providers like I mentioned. It's really battle tested like

53
00:24:29.870 --> 00:24:52.749
sergey: billions of dollars has been, you know, processed by the protocols. At this point we know what the Api needs to look like. We know how this Api extends to other environments evm, and non evm, so I think it has a very, very strong, you know, base base ground, and you know it can be extended further down as needed. But, I think it's as simple enough that hopefully won't won't happen too often.

54
00:24:54.506 --> 00:24:59.660
sergey: So that's it. I think that's all I wanted to cover. So I'll it didn't

55
00:25:00.370 --> 00:25:02.720
sergey: happy to answer any questions or pass it back to Ellie.

56
00:25:03.570 --> 00:25:17.320
Ellie Davidson: Yeah, I guess for the rest of this discussion. You know, people can ask questions in the chat, or, if you want to like, raise your hand, live and ask a question that's also really great, too. So maybe I'll pause here for any questions before we move into the next segment.

57
00:25:21.700 --> 00:25:23.410
Ellie Davidson: All right. No questions perfect.

58
00:25:24.600 --> 00:25:25.370
Ellie Davidson: So

59
00:25:26.047 --> 00:25:37.252
Ellie Davidson: to give kind of some context around this discussion. So many of us, you know, on this call believe that 7, 7, 8, 6 is a very good standard, and that it has a lot of value.

60
00:25:37.640 --> 00:25:54.299
Ellie Davidson: but you know there are definitely like as with any standard. There are very reasonable arguments against 7, 7, 8, 6. So you know, I want to discuss those during this call. And so maybe I can start out with just a few questions that I think we commonly get about 7, 7, 8, 6,

61
00:25:55.190 --> 00:26:17.319
Ellie Davidson: and the value of it. So I think a 1st question is, Well, why don't we standardize an existing protocol, you know, exist there? A lot of the existing interrupt protocols today are very well designed, and they're very good. And you know, could we meet our goal faster by standardizing one of them? So I don't know, Francisco, if you want to comment on this because you put it really nicely in the past.

62
00:26:19.800 --> 00:26:28.909
frangio: Yeah, sure. I think the the what you're referring to is the this idea of thinking about what

63
00:26:29.100 --> 00:26:39.790
frangio: the developers of the future interrupt. Protocols are going to be thinking of, and the decisions that they will want to make right.

64
00:26:40.340 --> 00:26:43.260
frangio: even though there are protocols out there that

65
00:26:43.570 --> 00:26:57.710
frangio: are what is called modular security, so you can sort of swap out the verification mechanisms that is used underneath to to verify whatever happened on another chain. You know.

66
00:26:58.060 --> 00:27:11.649
frangio: protocols tend to want neutrality right? They want to be sort of self-contained. They want to reduce their dependencies on on other protocols, on other businesses. They want to control their, their

67
00:27:11.850 --> 00:27:16.829
frangio: their stack and and their interfaces. And so

68
00:27:17.360 --> 00:27:37.520
frangio: it really doesn't seem to me viable to say to the interrupt protocol developers, you should use protocol X or Y to offer your functionality right? We want to have an interface that they can take off the shelf and and use to offer their protocol without relying on another party.

69
00:27:37.900 --> 00:28:01.540
frangio: And I think so far that hasn't existed, even though there have been proposals. They had problems and they had limitations. And that's why each new entry, each new party that entered this space had to come up with their own thing. And so the goal of Erc. 7,786 is to make something that is

70
00:28:01.920 --> 00:28:30.369
frangio: finally good enough to satisfy these, you know, to get over these limitations that we've had in the past and satisfy whatever needs new protocols may have, and also, you know, to make sure, for slight deviations by building in some degree of extensibility, so that protocols could, you know, slightly deviate if they really need to. But this this idea of

71
00:28:30.660 --> 00:28:44.750
frangio: you know, being able to take an interface off the shelf and use it, which is, you know, what we have seen happen with like Erc 20 erc. 4,626, all of the nfts, you know, I think it's really critical, and we haven't had it so far.

72
00:28:46.430 --> 00:28:47.700
Ellie Davidson: Yeah, that's great.

73
00:28:47.770 --> 00:29:02.679
Ellie Davidson: And if I could add just something of my own, you know, I just. It's very important that the standard be incredibly neutral, like Francisco said, it's not very realistic to expect, you know, certain interrupt protocols to adopt the protocols of their competitors.

74
00:29:02.680 --> 00:29:29.629
Ellie Davidson: I also think it's very important to, you know. Just not make the ecosystem too reliant on any single protocol. You know the protocols will always exist underneath, but it would not be good. If you know all of the infrastructure that apps use for messaging relies on a single project, and you know that project doesn't exist anymore, or, you know, is not aligned with the values of the ecosystem. So yeah, I think the big point here is that the standard should be credibly neutral.

75
00:29:29.630 --> 00:29:35.830
Ellie Davidson: which is why, you know, standardizing existing things we didn't think was a very good idea.

76
00:29:37.770 --> 00:29:39.660
Ellie Davidson: Any comments, questions.

77
00:29:43.100 --> 00:30:03.889
Joshua Rudolf: I had one question sorry, and maybe we'll get into this next. So feel free just to say, if so. But yeah, I think neutrality is obviously critical here, and I guess I would say even sort of table stakes. But I'm wondering if we can maybe help explain why we are Bullish sort of the more offensive

78
00:30:03.890 --> 00:30:14.259
Joshua Rudolf: reasons why we are confident that this solves real problems, why the customers of this will actually adopt it

79
00:30:14.330 --> 00:30:17.190
Joshua Rudolf: beyond the sort of neutrality, aspects of it.

80
00:30:17.980 --> 00:30:19.702
Ellie Davidson: Yeah, these are really good questions.

81
00:30:20.520 --> 00:30:46.170
Ellie Davidson: I will. Okay, I'll share my thoughts. And then maybe cj, you could share yours because I think that you do a good job of describing this, so I would say that the customers of 7,786 are mainly 2 things. They are the messaging protocols and the application developers. I'd say the application developers are the primary customer of 7,786, and a standard interface for messaging provides the following value for applications.

82
00:30:46.540 --> 00:30:48.050
Ellie Davidson: So 1st off.

83
00:30:48.470 --> 00:31:14.060
Ellie Davidson: it provides a single Api that can interact with any messaging protocol that currently exists and does exist in the future. This makes applications like modular. They don't have to worry about the specifics of the messaging protocol itself. They don't have to do specific integrations for specific protocols. And this just makes it a lot easier for application developers to deploy applications across a variety of different chains.

84
00:31:14.240 --> 00:31:35.100
Ellie Davidson: The other thing is that you know, chains are supported by different messaging protocols, while a lot of the Protocols are, you know, used on a lot of the chains. Certain protocols are not connected to certain chains, etc, and realistically apps want to connect to all chains. So they want to be able to use multiple messaging protocols. At the same time.

85
00:31:35.190 --> 00:31:52.050
Ellie Davidson: you know, eg. Receiving a message from chain, a uses protocol X, but receiving a message from chain B uses protocol y, they want to be able to do this. So they can actually offer this really seamless cross-chain experience to their users. So a single interface just makes all of this much easier.

86
00:31:52.220 --> 00:31:54.259
Ellie Davidson: but I'll hand it over to Cj.

87
00:31:56.560 --> 00:32:23.539
CJ Cobb: Yeah. So I see there being like 2 main customers of this interface. The 1st is apps, like Ellie said, so like, if you have one sort of interface to cross chain messaging like apps, can, you know, write their smart contract code? And then the interrupt provider is just totally modular, so like, if they want to like, move to a more secure provider, like innovation happens, and all of a sudden, like, there is just a

88
00:32:23.540 --> 00:32:47.380
CJ Cobb: way more secure messaging provider apps can move to that provider without having to like, rewrite their code and upgrade their contracts and all that. There's no like lock in, so it allows apps to inevitably be more secure. It allows cross chain to be faster, like no one's going to be locked into some like 2 year old. Interrupt provider right? Like, just as innovation proceeds like apps can just use that innovation

89
00:32:47.380 --> 00:32:50.229
CJ Cobb: right? So that's 1 thing. The second thing is

90
00:32:50.230 --> 00:33:15.629
CJ Cobb: for protocol developers themselves like having a standard Api really simplifies things. This has come up in this group itself, right? There have been several people that have proposed like novel verification mechanisms for cross chain messaging, and they were forced to also define their own interface for sending the message, which is silly. That's not where they're innovating. That's not what their work is. They shouldn't have to spend time on that.

91
00:33:15.630 --> 00:33:29.980
CJ Cobb: And like, if they define an interface like apps that already use a different interface can't use their work right if you come up with some really really novel verification scheme that's totally trustless. Best like, infinitely secure like.

92
00:33:30.660 --> 00:33:47.280
CJ Cobb: how can you push it to existing apps if they're using a different interface? Right? So the idea is like, we remove that part from the equation and say, this is the interface, and let innovation on verification, speed, trustlessness, all that like happen separate from the interface.

93
00:33:47.460 --> 00:33:48.980
CJ Cobb: So, yeah, that's it.

94
00:33:49.640 --> 00:34:13.229
Ellie Davidson: Yeah. And if I can add to that, I think one of the things I really hope to see many messaging protocols today. Do you have this like modular verification, but not all of them. And what I really think that this Api can allow is like once some of those messaging protocols start supporting like real time. Ck proofs and things like that. Applications can like very easily upgrade to those more secure verification methods, you know, without having to rework anything in their contract.

95
00:34:14.070 --> 00:34:16.919
Ellie Davidson: But anyway, does anybody have any? Oh, yeah, go ahead.

96
00:34:16.920 --> 00:34:36.080
CJ Cobb: I was gonna say, yeah, like, cross chain verification is going to continue to innovate like forever. It will never stop like there will always be people coming up with better mechanisms, more secure, faster, cheaper, right? And we just want that to just sort of happen, right? To just be plugged in and and modular, and not something that people need to move to. So.

97
00:34:36.690 --> 00:34:37.290
Ellie Davidson: Hmm.

98
00:34:38.620 --> 00:34:57.369
frangio: Yeah, I also wanna mention a particular use case, which is when as a as a smart contract developer, you are, you know, creating your protocol. You want to deploy it on many roll ups. And you have the need to use. Say, the canonical bridge of that roll up to connect talk back to the other one.

99
00:34:57.800 --> 00:35:14.599
frangio: Currently, you need to separately integrate each particular bridge. You know that each roll up uses right? That will behave slightly differently. And you know that's additional work you need to do. And this sort of unified interface would

100
00:35:14.640 --> 00:35:17.470
frangio: make that easier and and more efficient.

101
00:35:20.970 --> 00:35:24.740
Ellie Davidson: Anybody have any feedback, or, you know, disagreements.

102
00:35:26.650 --> 00:35:28.749
Joshua Rudolf: There's a couple of questions in the chat.

103
00:35:29.630 --> 00:35:33.530
Joshua Rudolf: one around. How does it compare with 7, 2, 8, 1 xcrc. 20.

104
00:35:37.285 --> 00:35:57.770
Ellie Davidson: Okay, I don't recall what 7, 8, 2, 1 is off the top of my head. I'd have to look it up. But compared to Xerc. 20. So it actually is very similar to Xerc. 20, you know. Kind of all of these like interfaces are very, very similar, like, Sergey said, I would say. The main difference is that xerc. 20 is specifically for token bridging.

105
00:35:57.770 --> 00:36:08.449
Ellie Davidson: whereas 7, 7, 8, 6 supports token bridging, but then it also can support, like arbitrary message passing of data which I think is very important to do as well.

106
00:36:12.010 --> 00:36:30.819
frangio: Yeah, we should see this as different layers. And you've got the message passing layer. And then on top of that you've got the token, bridging layer, and next Crc. 27, 8, 2, 1 also is an alternative to it. So they're also in that layer. But then.

107
00:36:30.920 --> 00:36:51.320
frangio: underneath you you have the message passing. So take kind of like an intent protocol, for example, would use Xcrc. 20 or 7, 8, 2, 1 to do like rebalancing of the liquidity across chains. But it would use 7, 7, 8, 6 for message passing of like

108
00:36:51.952 --> 00:37:00.720
frangio: notifying that a fail happened, and that you know that settlement has to happen on the other chain. So there's room for those 2 depending on exactly what you're doing.

109
00:37:02.720 --> 00:37:17.580
Ellie Davidson: Yeah. Wade has a good question, actually. And maybe Francisco, you could also answer this one. It's 7, 7, 8, 6 uses, Cape 2 and Cape 10. So do we think that you know these, those separate standards are going to be standardized as well.

110
00:37:18.380 --> 00:37:22.234
frangio: Yeah. So first, st I'll mention one of the things that

111
00:37:23.120 --> 00:37:27.122
frangio: we we really wanted to do with 17 a 6 is, make it

112
00:37:27.840 --> 00:37:32.809
frangio: very well defined how it supports different chains, different vms.

113
00:37:33.130 --> 00:37:48.929
frangio: and which is something that previous Erc attempts at message passing like unification, hadn't done successfully. And so that's why we chose Cape 2 and Cape 10 to do that.

114
00:37:49.920 --> 00:37:55.310
frangio: even though, like recognizing that they they have some some limitations and some some issues.

115
00:37:56.237 --> 00:38:00.119
frangio: But there is the Interoperable address.

116
00:38:00.380 --> 00:38:12.849
frangio: standard sort of effort working group that's currently going on. And the we are interested in adopting that because, you know it. It fixes some of the issues that Cape 10

117
00:38:13.020 --> 00:38:20.400
frangio: has for us. So even though you might see that in the spec right now it is. You know this is one of the things that is

118
00:38:20.740 --> 00:38:23.829
frangio: sort of in the in the to-do list to

119
00:38:25.630 --> 00:38:35.469
frangio: to improve. So there's definitely no consensus on Cape 10 being the Cross Chain address. Standard. I invite you to look at the interoperable address

120
00:38:35.780 --> 00:38:36.820
frangio: progress.

121
00:38:36.930 --> 00:38:39.510
frangio: There's been a very recent spec

122
00:38:39.690 --> 00:38:43.469
frangio: that was just shared there in the chat that's looking actually really good.

123
00:38:45.380 --> 00:38:51.120
Ellie Davidson: Yeah. And yeah, I guess I just also want to highlight that, you know. 7, 7, 8, 6. It has, like.

124
00:38:51.290 --> 00:39:06.219
Ellie Davidson: you know, even though it is proposed like, it's still in the process where we can still make changes to it. If you know, the community feels like certain changes are important. It's not set in stone. So yeah, I just want to like everybody should who is interested can go and provide feedback, like on

125
00:39:06.520 --> 00:39:09.049
Ellie Davidson: on the standard, you know, in Github, in Github.

126
00:39:11.060 --> 00:39:12.519
Ellie Davidson: Alright! Any other questions.

127
00:39:12.520 --> 00:39:39.490
CJ Cobb: I just wanted to second that like, really quick. Yeah, like 7 76, like we, we're still iterating on it. And like, at this point, we want to do more of like community iteration, like, because the whole point is to just get everyone to sort of agree on the packet format. Right the header. So it's not like we decided it should be this, and this is our pitch like, take it or leave it. It's like, let's just work together as a community, and agree on like a common Api for sending messages.

128
00:39:43.800 --> 00:39:47.199
Ellie Davidson: All right, any thoughts, or should I dive into some more hard questions?

129
00:39:50.250 --> 00:39:53.580
Ellie Davidson: All right. All right. So another.

130
00:39:54.180 --> 00:40:14.920
Ellie Davidson: You know another kind of question that, or, you know, very legitimate argument against 7,786 is that you know well, any sort of existing application would need to upgrade to this protocol. And that's a lot of work. It's easier if the existing applications, just, you know, stay using the protocol that they're already using.

131
00:40:15.200 --> 00:40:35.019
Ellie Davidson: And yes, so this is true. And I would say that this is kind of unavoidable. You know, current apps that are integrated with a particular messaging protocol like it is to for them to do any sort of upgrade. They will have to change their contracts, and they are already kind of like vendor locked into a certain protocol

132
00:40:35.220 --> 00:40:53.389
Ellie Davidson: which is specifically a 7,786 is trying to fix. So I think that this is kind of an unavoidable problem with any solution, you know, even if we would say, standardize like an existing protocol, all of the applications that exist that use other protocols would need to upgrade to it. So yes, this is a very fair criticism, but I think it's unavoidable.

133
00:40:53.970 --> 00:41:11.510
Ellie Davidson: And but, secondly, I think that specifically new applications can very easily adopt this, and I think that you know there will be a lot more new cross-chain applications like going forward in the future than there are today. And so all of these new applications can easily adopt it.

134
00:41:12.000 --> 00:41:27.469
Ellie Davidson: And over time, existing applications, you know, can slowly migrate to it. But yes, you know, we don't expect that existing applications will like migrate to this new Api on day one, you know, that's really not realistic. But

135
00:41:27.762 --> 00:41:48.810
Ellie Davidson: but the other option. So the alternative for exist for existing applications is they can migrate to 7, 7, 8, 6. It's difficult, but they get a lot of benefits, or they can just remain as is, which is totally fine. But then they also suffer all of the problems that we talked about, which is like this fragmentation. They can't, you know, contact certain chains like all of these things. So

136
00:41:49.352 --> 00:41:58.279
Ellie Davidson: I guess. Tldr what I just said like, yes, current applications probably will not adopt this anytime soon, but we believe new applications. Will

137
00:42:01.870 --> 00:42:02.810
Ellie Davidson: any thoughts?

138
00:42:07.760 --> 00:42:09.380
Ellie Davidson: Another thing, too?

139
00:42:10.780 --> 00:42:29.399
Ellie Davidson: that I think, is cool to point out about 7,786, and this, you know, this could be true for other other standards as well. But so open Zeppelin has, you know, been developing adapters for different messaging protocols. Because the flip side to the question is, well, why would a messaging protocol like adopt this, you know?

140
00:42:29.690 --> 00:42:51.490
Ellie Davidson: And so with these adapters 7,786 can be adapted to work with any messaging protocol, you know, without a direct integration from the protocol itself. So this will also make the adoption of it very easy because it can be adopted. You know, these major messaging protocols that are already used, you know, can basically be can work with 7,786 like day one.

141
00:42:52.476 --> 00:42:53.469
Ellie Davidson: Yeah. Victor.

142
00:42:54.120 --> 00:42:55.850
Victor | RISC Zero / Boundless: Yeah, I guess to that point.

143
00:42:56.050 --> 00:43:01.670
Victor | RISC Zero / Boundless: Have has there been any work on like case studies to show which messaging protocols could fit?

144
00:43:02.195 --> 00:43:08.200
Victor | RISC Zero / Boundless: Well beneath this interface and way, which ones might not fill fit well. Underneath this interface.

145
00:43:09.070 --> 00:43:15.159
CJ Cobb: Oh, yeah. So we sort of took like our like as our like. I don't know.

146
00:43:15.320 --> 00:43:34.920
CJ Cobb: Goal, what is. I don't know what the word is like. The the way we're thinking about this is, we take like axler, layer, 0 wormhole, and usually hyperlane, and try to make sure our interface works with those. And then, as a secondary thing, we usually try to take some Major L. 2 bridges like the Arbitrum Bridge. And what else was it, Fran? Like

147
00:43:35.730 --> 00:43:37.729
CJ Cobb: what other L. 2 bridges do we look at.

148
00:43:37.920 --> 00:43:39.080
frangio: Optimism.

149
00:43:39.270 --> 00:43:42.070
CJ Cobb: Yeah, like, arbitrary optimism. That's like our sort of

150
00:43:42.390 --> 00:44:05.070
CJ Cobb: North Star, like, we wanna make sure it works with all those things. And if we can like, then it's pretty good. We also like did add this thing called attributes into the spec that's supposed to be our way to like make it work with the long tail of interrupt providers like that. It might be slightly more difficult today. But yeah.

151
00:44:05.850 --> 00:44:24.769
frangio: I'll add a little bit to that which is that the core of this interface, which is, you have, you know you have a sender. You have a destination chain. You have a receiver, a payload. That basic thing is almost universal. Right? Quite naturally. And so

152
00:44:25.230 --> 00:44:39.619
frangio: that's also the core of 786. And so that's easy to do where it starts to differ, you know, to deviate and to differ more is in what is related to paying for gas and relaying costs. Those interfaces are

153
00:44:39.990 --> 00:44:49.889
frangio: more significantly different, and we are now in the process of also standardizing that part. And you know, we still have to

154
00:44:50.040 --> 00:44:55.360
frangio: understand how well it it maps to existing things.

155
00:44:56.723 --> 00:45:00.510
frangio: But the core of it is quite universal.

156
00:45:01.830 --> 00:45:13.790
Victor | RISC Zero / Boundless: Yeah, but actually, and actually one things I was, you know, kind of new space. But I'm just gonna kind of unsure about. When I read this specification the 1st time was the interface for execute message has payable.

157
00:45:14.040 --> 00:45:15.330
Victor | RISC Zero / Boundless: and if I send

158
00:45:15.540 --> 00:45:39.399
Victor | RISC Zero / Boundless: value to that execute message function, what happens to it is like, was it not immediately clear to me? Like, it seems my understanding after finishing it. Reading this, I'm thinking about it for a bit. It seems like it should be the case that equivalent value should be sent to the receiver, and that that payable amount is not eligible for gas like gas deductions. But maybe that's not the case. I'm curious about that.

159
00:45:40.060 --> 00:45:52.809
frangio: So. So if you read the accompanying text, you'll see it says, you know it's undefined what happens to to the value in payable. It may be rejected. So it'll depend on the protocol, and and that's there. Because, like.

160
00:45:53.080 --> 00:45:58.517
frangio: if it's a if it's a canonical bridge, you'll have a very simple way of just sending through

161
00:45:58.920 --> 00:46:25.160
frangio: the eth or the token. But in other bridges you won't be able to do that so, but it's something that I would be interested in working out more in the spec how that works, and in this in the open Pr, we have where we're working on the quoting and cast payment. I am touching a little bit of these these lines to to make that a little bit clearer, but the behavior it still depends on on the underlying bridge.

162
00:46:25.960 --> 00:46:34.509
frangio: And there was one more thing I wanted to say about how this interface a universal interface adapt to

163
00:46:34.840 --> 00:46:39.780
frangio: to this wide variety of protocols. There's 1 part where

164
00:46:39.990 --> 00:46:46.850
frangio: it is particularly hard, which is the chain Id. Because every protocol uses proprietary chain ids

165
00:46:47.020 --> 00:47:04.919
frangio: to identify the destination and source chains. This is the part where it gets really more difficult to translate interfaces, and the choice of Cape 2, which are the the chain agnostic chain, id standard

166
00:47:05.280 --> 00:47:18.229
frangio: sort of gives us the solution for that. But then to figure out the mapping to that to the proprietary chain, Id is a little bit harder, and that, I think, is the the main. The only thing about the you know, the core part of the message sending

167
00:47:18.550 --> 00:47:20.719
frangio: that is trickier to do.

168
00:47:22.950 --> 00:47:33.620
Victor | RISC Zero / Boundless: And actually kind of relate to that. I noticed that basically, there's a source chain Cape 2. And then there's also the sender Cape 10, which the Cape 10 should also include a Cape, 2.

169
00:47:33.860 --> 00:47:39.180
Victor | RISC Zero / Boundless: Chanty. If I'm understanding correctly, so why have those to be 2 separate fields.

170
00:47:40.760 --> 00:47:50.409
frangio: This is a really very technical detail that I don't think it makes sense to go into. Now, I'm happy to talk about it more later, but definitely have thought about that and

171
00:47:50.590 --> 00:47:52.090
frangio: and and considered it.

172
00:47:59.890 --> 00:48:01.339
Ellie Davidson: Yeah, if there's no other

173
00:48:01.810 --> 00:48:10.309
Ellie Davidson: other comments on that, maybe we can move forward to kind of just talking about the practicality of 7, 7, 8, 6, and getting it, you know, into production.

174
00:48:10.952 --> 00:48:16.510
Ellie Davidson: So I think with the message passing interface, you know, they're

175
00:48:16.740 --> 00:48:34.529
Ellie Davidson: we need to strike like a good balance. We need to strike a good balance between having something very soon, so that all of these cross chain apps that are going to pop up have something to use that standardized. It only becomes harder to create a standard. Api, you know, like the further we go down.

176
00:48:34.840 --> 00:48:48.929
Ellie Davidson: So that's 1 end. But on the other end we also want this Api to be good. We want it to be, you know, very future proof. We want it to be something that you know will stand the test of time over several years. So with that.

177
00:48:49.110 --> 00:49:12.439
Ellie Davidson: I think that the 7, 7, 8, 6 currently strikes a good balance, because while it's not officially standardized, yet there are implementations of these smart contracts that exist today from my understanding, you know, like these could fairly easily be made, you know, like production ready and put on mainnet

178
00:49:12.746 --> 00:49:21.320
Ellie Davidson: the adapters don't all exist today, but based on our conversations with some others in the group. It seems like creating these adapters would not take a whole lot of time.

179
00:49:21.580 --> 00:49:34.309
Ellie Davidson: So the other thing. So I guess that's not kind of another. Pro 7, 7, 8, 6, right now is that it has a lot of like actual infrastructure already built behind it, which allows us to move a lot more quickly on it, which I think is important.

180
00:49:38.570 --> 00:50:06.870
CJ Cobb: Oh, yeah, just one to second, like at at Axler, like we we will, you know, have an adapter for this. So that way like you can send messages through the Axler protocol if we don't support it natively, you know. So you can send messages through the Axler protocol using 7, 76. We're also in the process of shipping another product built on 776. That is sort of like an aggregator that you can send messages across multiple interop protocols at the same time. And they're only considered verified, based on some

181
00:50:06.870 --> 00:50:13.110
CJ Cobb: security scheme that the app defines like 2 out of 3 and that would use 7, 7, 8, 6 as well.

182
00:50:13.374 --> 00:50:24.469
CJ Cobb: That's a nice product, in my opinion, because I think that's like the most secure way to do cross chain messaging. It's hard to like hack 2 bridges at the exact same time. So. But yeah, those are just 2

183
00:50:24.520 --> 00:50:25.290
CJ Cobb: products.

184
00:50:25.810 --> 00:50:41.969
Ellie Davidson: Yeah, no, yeah. That's a good point like this kind of aligns nicely with Vitalik's blog post that he posted a while ago about kind of like proof aggregation, you know, having this interface that can easily do that. It, you know it's great, because applications can, you know, upgrade to these aggregated proofs very easily.

185
00:50:42.300 --> 00:50:43.660
Ellie Davidson: anyway. Orest. Yes.

186
00:50:43.920 --> 00:50:46.809
Orest Tarasiuk (t1): Do you have a timeline for some sort of

187
00:50:46.920 --> 00:51:02.499
Orest Tarasiuk (t1): first, st I guess, complete suite, like an alpha version for for me to take and and play with, and actually see, you know, the eap and the relaying, and and ideally also some verification

188
00:51:02.670 --> 00:51:03.860
Orest Tarasiuk (t1): work together.

189
00:51:06.000 --> 00:51:07.300
Ellie Davidson: Yeah. Maybe. Francisco.

190
00:51:07.630 --> 00:51:08.720
frangio: Yeah, well.

191
00:51:08.970 --> 00:51:27.310
frangio: that's a. It's an important question. Great question. And it really, you know, we really have to understand. Erc 7, 7 x 6 is an interface, right? So when we talk about like an end-to-end suite, we would be talking about a particular instantiation of that, and

192
00:51:27.590 --> 00:51:32.939
frangio: we could say, talk about the axler adapter for that right? And

193
00:51:33.460 --> 00:51:43.750
frangio: I can't give you a timeline right now, but it's you know we we have the adapter. We've deployed it and tested it with, you know, an end to end thing. Maybe we should talk about that offline to understand

194
00:51:45.260 --> 00:51:47.619
frangio: what you want to see, and and when we can get it done.

195
00:51:49.070 --> 00:51:50.200
Orest Tarasiuk (t1): Sure. Thank you.

196
00:51:50.820 --> 00:52:10.039
CJ Cobb: Yeah, a lot of this is sort of, I don't wanna say blocked, but like not totally prioritized, because we're trying to get like sort of community consensus around the spec itself, like. So it's like, Do you want to go the full mile to push something to production while it's still being sort of designed, you know. But if if there's

197
00:52:10.350 --> 00:52:20.909
CJ Cobb: a desire for yeah, like an alpha product that people can play with like we can prioritize that, and like that, I I don't think that should take more than like a few months really like. It's fairly simple.

198
00:52:22.430 --> 00:52:26.599
Ellie Davidson: Yeah, I do want to go back to Marissa's question in the chat.

199
00:52:26.840 --> 00:52:29.029
Ellie Davidson: So this is a question, is that

200
00:52:29.330 --> 00:52:39.520
Ellie Davidson: 7,786 does not enforce, like a certain verification mechanism. This means that all sorts of verification mechanisms can be used, and they don't all have the same security.

201
00:52:39.520 --> 00:53:04.230
Ellie Davidson: and but the security of these verification mechanisms very much affects the applications. Applications don't want to allow certain message verification types, but they do want to allow others. So yeah, this. So the apps, deciding what their own security module is, still works with 7,786. So applications would still say like, Hey, I require this certain verifier

202
00:53:04.230 --> 00:53:12.579
Ellie Davidson: a Zk proof, and they would reject any messages that that don't have that. So applications are still able to like, specify.

203
00:53:13.580 --> 00:53:20.180
Ellie Davidson: You know, very specific security parameters. Because which is, yeah, this is a very important property that we need to keep, because this is a very good point

204
00:53:26.420 --> 00:53:27.589
Ellie Davidson: any more questions.

205
00:53:32.661 --> 00:53:35.799
Wei Dai: Yeah, I just had one which I typed out in the chat.

206
00:53:35.980 --> 00:53:52.380
Wei Dai: But basically on attribute keys. It says that in the current spec what the version that's on the website. It says every key must have the format of solid function signature, which is 4 Byte. So why is that enforced. I think this may limit generalizability beyond evm.

207
00:53:53.780 --> 00:54:06.379
frangio: In the end. The only thing that matters is the resulting 4 Byte right which it acts as a tag. It's just a standardized way to generate it, and it would be generated off chain. So as far as I can tell, it wouldn't

208
00:54:06.570 --> 00:54:20.550
frangio: really be an issue to to use it in non evm context. You just need the 4 Byte constant in there. But then the rest of the the encoding can be vm. Specific.

209
00:54:23.980 --> 00:54:30.709
Wei Dai: I think it might make sense. I don't know, maybe because he also says that it's expected, for

210
00:54:31.070 --> 00:54:34.330
Wei Dai: you know certain attribute keys to be standardized via Ercs.

211
00:54:36.060 --> 00:54:47.410
Wei Dai: you know, there might be like 2 classes of of actually keys, right? One that's standardized, one that's maybe more custom. Depending on the bridge or messaging protocol? Like a basic. I think 2 questions, basically.

212
00:54:47.920 --> 00:54:51.559
Wei Dai: you know, is 4 Byte enough. Do we need more potentially

213
00:54:52.910 --> 00:54:57.240
Wei Dai: and you know. Make sure we reserve reserve some of the actual key space for like

214
00:54:58.010 --> 00:55:01.739
Wei Dai: attribute keys that need to be standardized and maybe another. Another. You know

215
00:55:02.210 --> 00:55:07.419
Wei Dai: another category. For, okay, this actually can be anything arbitrary, and there's no how do you standardized at all. And

216
00:55:07.550 --> 00:55:10.130
Wei Dai: the messaging bridges can implement whatever they want.

217
00:55:13.050 --> 00:55:19.759
frangio: My take here is like 4 Byte seems to be enough for function selectors, and I think it's roughly the same

218
00:55:20.100 --> 00:55:22.029
frangio: here, even though you know

219
00:55:22.600 --> 00:55:34.379
frangio: there are obviously the possibility of having collisions. But you're you're never thinking about this when you talk to a trusted contract. Right? You already know what its Abi is, and this would. It would be the same here with

220
00:55:34.490 --> 00:55:36.840
frangio: gateways. You sort of.

221
00:55:37.290 --> 00:55:40.830
frangio: You're sort of. You're connecting to a particular gateway, you know

222
00:55:41.210 --> 00:55:47.560
frangio: what attributes it supports. So it's a similar thing there. I don't think we should be worried about the collisions.

223
00:55:52.165 --> 00:55:54.919
Ellie Davidson: Okay? Matt asked a really good question in the chat.

224
00:55:55.490 --> 00:56:07.557
Ellie Davidson: you know, which is, I think I can summarize, as you know, like we say that applications don't have to make any changes to their contracts if they want to switch messaging protocols. But like, is that actually true? And like, what does that actually mean?

225
00:56:08.850 --> 00:56:09.850
Ellie Davidson: so

226
00:56:10.340 --> 00:56:21.788
Ellie Davidson: the changes should be very minimal. But like, there will be changes specifically in that, you know, an application will have to specify a certain verifier, you know. Verifiers

227
00:56:22.340 --> 00:56:33.199
Ellie Davidson: you know, maybe specific to certain chains, etc, so like they will have to specify that. But the idea is that this is like a configurable item. It is not changes to the core structure of their smart contracts.

228
00:56:34.280 --> 00:56:58.079
Ellie Davidson: The other thing is fee you mentioned is like fee calculations and fee calculations should ideally just be very modular and, like you should have kind of like a singular modular interface that says, like calculate cross chain gas that can be into, you know, implemented in any such way. But it's the same Api interface that all of these apps would connect with. So no, they don't have to adjust their fee

229
00:56:58.280 --> 00:57:04.029
Ellie Davidson: fee mechanism inside their app. But I don't know if Cj. Or Frangio have any more comments.

230
00:57:04.530 --> 00:57:05.130
CJ Cobb: Yeah, I was just.

231
00:57:05.130 --> 00:57:14.140
frangio: Regarding the the fees like like I said, we're in the process of of designing the the Fee Api, so we we can't

232
00:57:14.380 --> 00:57:17.980
frangio: answer the particular part about the fees just yet.

233
00:57:18.360 --> 00:57:22.330
frangio: But it's a really great point we need to look into. Actually.

234
00:57:22.780 --> 00:57:32.300
frangio: would this apply across the board? And I pasted the Pr link over there. People are invited to to let us know what they think about it. There.

235
00:57:33.860 --> 00:58:00.859
CJ Cobb: Yeah, that is the ultimate goal, though, right is to just be able to hot swap. And it all just works. There's some element of maybe that won't work in certain cases. But that's what we're working for. Fees are harder, right? Even though we are working towards that with fees. It is harder. This is something like, send a message. It? Yeah, it has proven pretty swappable in practice. You just send a message. There's like a little bit of a translation, and that's it. But the app doesn't care

236
00:58:04.870 --> 00:58:07.363
CJ Cobb: also for the fee part of things.

237
00:58:07.920 --> 00:58:11.630
CJ Cobb: we have talked about sort of like having 2

238
00:58:11.670 --> 00:58:38.009
CJ Cobb: like like 7, 7, 8, 6, sort of encompassing, like 2 interfaces where there's the message sending interface and the the fee interface. So for, like the situation, where, for some reason, some interrupt protocol like the fee interface like they, they it just cannot work with 7, 7, 8, 6, that they can still support the messaging interface, because that is generally much simpler. And and yeah, and that's like your app logic as well. So yeah.

239
00:58:43.490 --> 00:58:44.539
Ellie Davidson: Anyone have thoughts.

240
00:58:46.090 --> 00:58:52.840
Matt Cutler | Blocknative | Gas Network: Hey, guys, Matt, here. Something we've been working on. I just need to get out. There's been a lot going on on. Our end is

241
00:58:53.270 --> 00:58:57.529
Matt Cutler | Blocknative | Gas Network: protocol that will publish a suggestion around

242
00:58:57.670 --> 00:59:22.699
Matt Cutler | Blocknative | Gas Network: chains, being able to declare their gas markets, because not only do our our fees an ongoing thing, but chains regularly produce upgrades to their gas markets that change the nature of the fee structure, and so you can be working under one set of assumptions that may or may not be valid if there's been an upgrade on the target chain. So just something to consider that these are dynamic markets that change with upgrade.

243
00:59:26.790 --> 00:59:29.099
Ellie Davidson: Yeah, I think the way I see it is that

244
00:59:29.340 --> 00:59:36.879
Ellie Davidson: something like that? We could. You know, it could be very, very modular in the sense that yeah, like applications should be able to

245
00:59:37.050 --> 00:59:49.440
Ellie Davidson: like this should be abstracted from applications. It should be extracted from the messaging Api itself. But then, like different sort of gas markets can be swapped in. Or you know, gas specifications can be swapped in, you know, when they're needed.

246
00:59:52.270 --> 01:00:22.260
Matt Cutler | Blocknative | Gas Network: I think the question is discoverability. So I wanna I'm on chain A, I'm trying to pass a message, a swap to chain. B. You know, do I? Does my application have an accurate understanding of the current state of that gas market? And so maybe you know, the proposal that I'll put forward is a mechanism by which each chain can sort of specify. Here's how my gas market works. Here's the parameters, and here is the version. So that if the version has incremented the application can verify.

247
01:00:23.640 --> 01:00:43.470
CJ Cobb: Yeah. The way we're thinking about this generally is the application requests a fee estimate like before sending a message right? And so it sounds like what you're building this like gas marketing would sort of like plug in behind the fee estimate. So like the application is always getting like a correct estimate, or correct enough.

248
01:00:44.950 --> 01:00:45.840
Matt Cutler | Blocknative | Gas Network: Sounds good.

249
01:00:53.980 --> 01:01:09.500
Ellie Davidson: all right. If there's no other comments, you know, maybe it would be useful. I know we only have about 10min left to just briefly kind of discuss the properties we felt like a messaging protocol should have. So I can link this in the chat. It is still a Pr. So subject to

250
01:01:09.670 --> 01:01:12.460
Ellie Davidson: subject to change. But

251
01:01:13.280 --> 01:01:30.440
Ellie Davidson: so any sort of messaging interface, whether it's 7,786 or not, we feel like, should have safety. Obviously, as long as you assume that the message verification is honest, you know the Api should be able to deliver a message if and only if it was actually made at the source chain.

252
01:01:31.575 --> 01:01:34.909
Ellie Davidson: The Api should also have liveness.

253
01:01:35.390 --> 01:01:44.570
Ellie Davidson: So, assuming the liveness of the individual chains and the censorship of censorship resistance of the individual chains. A message should eventually be received on the destination chain.

254
01:01:44.830 --> 01:02:05.410
Ellie Davidson: We think Vm. Agnosticism is very important. As was mentioned, earlier. Previous standards have focused on only Evm Apis, which it makes sense because most use cases are Evm use cases. But I think in the future non-evm use cases are going to become quite important to support

255
01:02:06.244 --> 01:02:17.709
Ellie Davidson: secondly, or fourthly, it should support any sort of verification mechanism, so proof agnostic it should be protocol agnostic meaning, it should support any underlying messaging protocol.

256
01:02:18.830 --> 01:02:40.940
Ellie Davidson: and finally, it should be optimized for the most popular use cases. So this would be bridging tokens, even though 7,786 can very much support like an arbitrary message. Passing scheme, we recognize that bridging tokens is like the primary use case that something like this would be used for. So we are

257
01:02:41.270 --> 01:02:44.070
Ellie Davidson: taking that into consideration, you know, and

258
01:02:44.480 --> 01:02:55.150
Ellie Davidson: that, you know, for example, there are ways you could extend 7, 7, 8, 6 to kind of handle like these very certain edge cases in certain applications. But

259
01:02:55.400 --> 01:03:18.369
Ellie Davidson: realistically, we don't think it's worth that. And if an application really has this super complex thing that they need to, that they need to do, then they should just interact with the messaging protocol itself. Trying to make the messaging protocol or trying to make 7, 7, 8, 6, like you work for every single possible use. Case would just make it very complex kind of defeating the purpose. In the 1st place.

260
01:03:23.780 --> 01:03:26.289
Ellie Davidson: I see a few comments in the chat. Let me read them.

261
01:03:28.250 --> 01:03:51.960
CJ Cobb: Oh, I just wanted to double click on the all Vm point. Real quick. So this is one of our main goals with 7, 7, 8, 6, and I think is one of the actual, like technical differences between 7, 7, 8, 6, and some other previous Ercs. And we view, this is very important, like, we really tried to make the spec something that can be implemented from Solana from any sort of Vm

262
01:03:51.960 --> 01:04:14.920
CJ Cobb: or honestly, even chains that don't have a Vm. Right like at Axel. Our protocol is quite similar to 7,786, and we've implemented this coming from Xrp Ledger, which is not a smart contract chain like you can make, like smart contract calls from Xrp ledger, using an interface very, very similar to 7,786, and on ethereum. You don't know the difference, like of whether it came from there

263
01:04:14.920 --> 01:04:19.520
CJ Cobb: working from Bitcoin. Right? You could do this from Bitcoin and so that was like one of our goals.

264
01:04:21.240 --> 01:04:41.080
Ellie Davidson: Yeah. And one thing I like about this goal is that so we often focus on specifically L 2 interop, which is, I think, by far the most important thing right now, and 100. But really, in the future you want interrupt between l. 1 s. Like, there should be very clean interop between ethereum and solana, because that's actually a major pathway that users want. And it's

265
01:04:41.270 --> 01:04:50.140
Ellie Davidson: and if you can use the same interface to bridge to Solana as you're using to bridge to like arbitrum or OP like that's incredibly incredibly useful.

266
01:04:52.490 --> 01:05:00.733
frangio: Even within the L 2 sphere. Right? We want to enable alt vms, like startnet

267
01:05:01.800 --> 01:05:06.549
frangio: and the lack of of a standard that caters to them

268
01:05:06.830 --> 01:05:11.460
frangio: could really, you know, hamper that innovation. So I think this is another benefit.

269
01:05:14.750 --> 01:05:32.799
Ellie Davidson: Okay, wait. I had a question, which is that 7,786 does not actually guarantee message delivery of or guarantee that messages are actually delivered in the sense that it's more Udp like Tcp. So what I would say is that, like actual message, delivery is really

270
01:05:32.930 --> 01:05:53.920
Ellie Davidson: for the messaging protocol level like an Api itself can't really enforce it. So you have to trust that the protocol will enforce message delivery, and that the chains themselves are like live. But I guess another way to put it is that the Api should not prevent that. Like there should be no situation where an Api prevents a message from being delivered that was.

271
01:05:54.190 --> 01:05:56.739
Ellie Davidson: you know, actually sent from the source chain.

272
01:05:57.980 --> 01:06:27.759
CJ Cobb: Yeah, liveness is generally provided by a relayer, right? Like which is like somewhat I don't wanna say outside the protocol, but it's like a higher level than the protocol itself like than verification. However, like Ellie said, messages should be deliverable right like there's no there's nothing that like a message should be like blocked on some like centralized entity. It should be like once the message is sent like it, it can be delivered. You could deliver it. The relayer could deliver it like it's it's valid.

273
01:06:27.890 --> 01:06:43.379
Wei Dai: I guess my question is more regarding like, let's say, if you want to, you know, do like a lock a mint where I kind of unlock operation we'll have to basically from the source, from target chain. Send back to the source chain before I do the unlock operation, because I cannot assume that message have been delivered right.

274
01:06:44.230 --> 01:06:45.680
Ellie Davidson: Yes, this is true. Yeah.

275
01:06:45.980 --> 01:06:57.670
CJ Cobb: Yeah. Yeah. But there should never be a case where, like, if you lock on the source chain like it should be mintable on the destination chain. It's just a question of like, when right does that make sense.

276
01:07:01.170 --> 01:07:06.550
Wei Dai: Yeah, I was wondering whether you know, a Tcp like extension should also be

277
01:07:08.040 --> 01:07:16.300
Wei Dai: you know, like standardized. But it seems yeah, like, if if it's really just to a message passing, we don't have to. It can just be epic level.

278
01:07:16.720 --> 01:07:17.370
CJ Cobb: Hmm.

279
01:07:19.300 --> 01:07:32.500
Ellie Davidson: Yeah, I think maybe that's also a good question, which is like, you know, why don't we standardize a messaging protocol itself? Because then we could standardize something like a, you know, guaranteed delivery mechanism within like a certain time bound, and the answer to that is that

280
01:07:32.800 --> 01:07:38.060
Ellie Davidson: messaging protocols which often are combined with verification. Layers as well are.

281
01:07:39.060 --> 01:08:07.640
Ellie Davidson: I think, would be something that is very difficult to standardize. Maybe in the future we can, but I don't think it's it's at all realistic to standardize that in the near term, because there are very many valid, you know, design trade-offs and decisions to be made. Also the messaging protocol standard would need to support every single use case which makes it, you know, even more complex. So anyway, that's like the benefit of just focusing on the Api instead of kind of going down the rabbit hole of actually, you know, standardizing

282
01:08:07.640 --> 01:08:09.830
Ellie Davidson: the the messaging protocol itself.

283
01:08:13.990 --> 01:08:18.610
Ellie Davidson: All right. We only have 5min left. Does anybody have some final thoughts? Oh, yeah, Josh.

284
01:08:19.600 --> 01:08:24.060
Joshua Rudolf: Yeah, sorry. I just had I guess maybe one final question from my side at least.

285
01:08:24.590 --> 01:08:38.800
Joshua Rudolf: and we already touched on this a little bit. But maybe we could. Yeah, quickly come back to what is the success? Criteria for 7, 7, 8, 6, 1218 months from now, whatever assuming the bulk case. What do we think? Success looks like.

286
01:08:40.460 --> 01:08:42.669
Ellie Davidson: This is a really good question. Go ahead. Cj.

287
01:08:42.670 --> 01:09:07.039
CJ Cobb: So 1st success criteria is the products that I mentioned before, right like from from my side, from the axler side, like we want to make sure we ship the adapters for this. It's usable, it's workable. It's running in production. Also, the aggregator, right? That uses 7, 7, 8, 6, usable, workable running in production. Those 2 things. The other thing that I think would be a success criteria is, if we see new interrupt protocols like coming out or being designed.

288
01:09:07.040 --> 01:09:21.599
CJ Cobb: they use the 7, 7, 8, 6 interface. They don't feel the need to like design their own interface for no real reason that say, okay, like 7, 76, I'm going to use it. And behind that will be my novel verification scheme.

289
01:09:21.670 --> 01:09:26.099
CJ Cobb: whatever my innovation is. So yeah, that's what I think.

290
01:09:26.800 --> 01:09:56.030
Ellie Davidson: Yeah, yeah. For me, the success, rate or success criteria is very similar. If we can have adapters for Axel, wormhole, layer 0 and hyperlink, since those are the most popular protocols. Right now, if we can have those within like 6 months and deployed in production and apps can start using them that would be very successful. My hope is that we could actually do it faster than that. And then the next step of success criteria would be like how many new applications are actually using this interface.

291
01:09:59.230 --> 01:10:09.520
frangio: Yeah, I I mine are are similar to Cj's which is, you know, I want to see new interrupt protocols using this interface for their message

292
01:10:09.640 --> 01:10:11.660
frangio: sending feature.

293
01:10:12.008 --> 01:10:17.730
frangio: But I, you know, plus one to at least as well like I want to see applications, you know, being able to use that successfully.

294
01:10:19.300 --> 01:10:26.109
Jonathan Alexander: I'll just say it. Just yep, plus one on Elise, that I think we will do them.

295
01:10:26.400 --> 01:10:30.399
Jonathan Alexander: Once we settle on some of these final issues. We'd want to

296
01:10:31.293 --> 01:10:34.160
Jonathan Alexander: add support for all those

297
01:10:34.670 --> 01:10:46.770
Jonathan Alexander: message messaging systems sooner than 6 months. And then the other thing that we are going to be looking for for success. Criteria is, we want to start enabling more of the

298
01:10:47.220 --> 01:10:56.330
Jonathan Alexander: opens upland contracts to enable embed cross chain messaging, and then we will be success. Criteria for us will be to see

299
01:10:56.570 --> 01:11:02.840
Jonathan Alexander: beginning to see adoption of those contracts and use of them and deployment of them. So

300
01:11:05.180 --> 01:11:05.950
Ellie Davidson: Yep.

301
01:11:07.180 --> 01:11:24.759
Ellie Davidson: and maybe as a as like a final thought on timelines so the like. The exact timelines kind of depend on how much, you know. Further iteration we need on 7, 7, 8, 6, and you know other things. But what I would like to propose now that we've had this discussion is that you know, we

302
01:11:24.780 --> 01:11:39.610
Ellie Davidson: or at least I feel that 7, 7, 8, 6 is a very good way to go forward. Going forward, we should. We can iterate on like the very minor details of 7, 7, 8, 6, that some people brought up here. I think maybe we can do that over the next.

303
01:11:39.960 --> 01:11:52.220
Ellie Davidson: I'm well, I don't know. I want to give people enough time to do that, but like at the latest, like the next month at most, and then I think we should, you know, like standardize 7, 7, 8, 6, unless we have some major reason not to.

304
01:11:54.500 --> 01:11:56.759
Ellie Davidson: I don't know if anybody agrees or disagrees with that.

305
01:12:00.110 --> 01:12:01.280
frangio: That sounds good to me.

306
01:12:01.750 --> 01:12:02.330
Ellie Davidson: Hmm!

307
01:12:07.190 --> 01:12:12.046
Ellie Davidson: I guess to Josh's question. In the chat when we say new interrupt protocols.

308
01:12:12.870 --> 01:12:23.300
Ellie Davidson: does anyone have thoughts on? What sort of protocols, I think, like an example which you yourself brought up would be bases erc.

309
01:12:23.560 --> 01:12:36.480
Ellie Davidson: which is itself really just the verification part like that's the main part, but it has its own interface, you know, if, like that protocol would adapt to the 7, 7, 8, 6 interface like that would be really really successful. I think.

310
01:12:38.190 --> 01:12:47.840
frangio: For me when that comes to mind, is the super chain right? And I would also say, espresso right as a way to communicate between

311
01:12:48.320 --> 01:12:49.280
frangio: roll-ups.

312
01:12:51.041 --> 01:12:58.840
Ellie Davidson: Yes, espresso you know, assuming there's nothing crazy that happens when we end up. Not standardizing this espresso will adopt 7, 7, 8 6,

313
01:13:03.410 --> 01:13:32.229
Ellie Davidson: all right. We're at the top of the hour, so I appreciate everybody joining if you have any comments like definitely put them in the telegram chat, or you can put them directly on the on Github. You can put them in like the L 2 interop repo, or on the 7, 7, 8 6 repo as well. I would just like, I mean, really, if anybody has like any thoughts, I think the most useful thing right now is for us just to get as much feedback as possible.

314
01:13:32.480 --> 01:13:38.279
Ellie Davidson: So I very, very much appreciate it. If anybody does that. If anybody thinks of, you know.

315
01:13:38.410 --> 01:13:43.118
Ellie Davidson: arguments against 7, 7, 8, 6 that they want to discuss. Like, yeah. Put them in the chat.

316
01:13:43.560 --> 01:13:49.190
Ellie Davidson: we would like to work through all of them. But I appreciate everybody who asked questions, and everybody who listened.

317
01:13:51.020 --> 01:13:51.920
frangio: Thank you.

318
01:13:51.920 --> 01:13:54.729
Orest Tarasiuk (t1): Thank you for running this session, Ellie. Bye-bye, guys.

319
01:13:54.730 --> 01:13:55.139
Joshua Rudolf: And so.

320
01:13:55.640 --> 01:13:56.390
CJ Cobb: Thanks.

321
01:13:56.790 --> 01:13:57.510
Ellie Davidson: Bye.

322
01:13:58.010 --> 01:13:58.840
QEDK: Cheers, everyone.

323
01:13:58.840 --> 01:13:59.290
Victor | RISC Zero / Boundless: Bye, all.

