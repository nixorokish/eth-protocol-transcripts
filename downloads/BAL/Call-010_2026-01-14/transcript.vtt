WEBVTT

1
00:02:40.350 --> 00:02:41.340
jochem-brouwer: Hey, eight.

2
00:04:14.380 --> 00:04:18.579
Toni Wahrstätter: Hello, everyone. Let's give people a few more minutes to join.

3
00:05:05.410 --> 00:05:09.349
Toni Wahrstätter: Great, I think we can get started. Is the stream ready?

4
00:05:12.530 --> 00:05:15.520
Akash | ECH: Yeah, I'm ready, just give me 5Hz.

5
00:05:16.200 --> 00:05:17.450
Toni Wahrstätter: Yeah, let's go.

6
00:05:21.090 --> 00:05:22.220
Akash | ECH: Yeah, we are live.

7
00:05:23.700 --> 00:05:33.210
Toni Wahrstätter: Great, thank you very much. Hello, everyone. Welcome to the 10th EAP7928 breakout call. Today is January 14th.

8
00:05:34.170 --> 00:05:37.459
Toni Wahrstätter: And yeah, let's directly get started. We have…

9
00:05:37.860 --> 00:05:46.130
Toni Wahrstätter: quite some items on today's agenda, and I would say we directly get into the first one, which includes DevFlat 1 updates.

10
00:05:47.070 --> 00:05:55.719
Toni Wahrstätter: Would be great if Stefan is on the call, I see he is. Maybe, Stefan, could you give us maybe some quick update on Definite One?

11
00:05:55.720 --> 00:06:00.520
Stefan Starflinger: Yeah, sure. So, Happy New Year, also.

12
00:06:00.700 --> 00:06:14.710
Stefan Starflinger: DevNet1 is going pretty strong currently. There were a few hiccups, a few syncing problems, but, we managed to figure pretty much most issues out.

13
00:06:14.950 --> 00:06:18.369
Stefan Starflinger: Right? Currently, I think we're still on holiday.

14
00:06:19.130 --> 00:06:27.580
Stefan Starflinger: They're still working on figuring out their syncing issue, but otherwise, MetaMind is pretty stable. Let me change my audio.

15
00:06:28.190 --> 00:06:29.799
Stefan Starflinger: Can you hear me better now?

16
00:06:31.390 --> 00:06:32.539
Stefan Starflinger: Yeah, it's better.

17
00:06:32.540 --> 00:06:34.100
Toni Wahrstätter: It was okay, but now it's better.

18
00:06:34.710 --> 00:06:43.389
Stefan Starflinger: Okay, great. So, NetherMind has managed to fix most of the inconsistencies, and is doing pretty well now.

19
00:06:43.400 --> 00:06:55.639
Stefan Starflinger: We're running the EVM fuzzer, and we're running Uniswap transactions consistently, and it seems there are no errors that we can find with these two strategies anymore.

20
00:06:55.860 --> 00:07:00.339
Stefan Starflinger: And most clients seem to have solved the issue.

21
00:07:00.450 --> 00:07:04.579
Stefan Starflinger: That they were facing over the holidays, so that's great.

22
00:07:05.040 --> 00:07:09.340
Stefan Starflinger: Now I think we're ready for, talking about DevNet 2.

23
00:07:09.600 --> 00:07:15.119
Stefan Starflinger: And I think we can leave the definite one behind once Reth manages to sync up again.

24
00:07:18.500 --> 00:07:26.319
Toni Wahrstätter: Awesome. Thank you very much for the update. Is there anything from client teams that someone would like to add regarding Definite One?

25
00:07:32.930 --> 00:07:40.460
Toni Wahrstätter: Or maybe Rahul or Felipe, you guys have, great insights into testing, anything that you guys would like to…

26
00:07:40.860 --> 00:07:42.909
Toni Wahrstätter: mention regarding Definite One?

27
00:07:45.840 --> 00:07:53.030
felipe: I think only… that… you know, a couple of the issues that arose from DevNet 1.

28
00:07:53.370 --> 00:07:58.039
felipe: We're used to create tests, but these were not, there was no release

29
00:07:58.550 --> 00:08:05.419
felipe: that targeted DevNet1 with these tests, but these test cases are now included in the next test release.

30
00:08:10.590 --> 00:08:12.489
Toni Wahrstätter: Awesome. Thank you very much.

31
00:08:14.520 --> 00:08:19.959
Toni Wahrstätter: Great, yeah. The second agenda point would… would already be definite 2.

32
00:08:20.170 --> 00:08:23.689
Toni Wahrstätter: I'm not sure if everyone has seen it, on…

33
00:08:24.150 --> 00:08:28.720
Toni Wahrstätter: Tuesdays, Mondays, I forgot. Testing call.

34
00:08:29.200 --> 00:08:35.890
Toni Wahrstätter: 4 additional ELPs were slated for DEFNET 2 for the BAL DEFNET 2.

35
00:08:36.200 --> 00:08:40.340
Toni Wahrstätter: I think it's the slot num app code, it's,

36
00:08:41.470 --> 00:08:46.149
Toni Wahrstätter: EVE transfers emitting a lock, and two more EIPs, I forgot now.

37
00:08:46.680 --> 00:08:49.090
Toni Wahrstätter: What do you think? Is this something…

38
00:08:49.240 --> 00:09:03.049
Toni Wahrstätter: we should already put on Defnet 2, or do clients feel it would be smarter to not yet add any ERPs to DEFNET2? Of course, considering that, at some point we need to add some more ERPs, just to…

39
00:09:03.150 --> 00:09:05.170
Toni Wahrstätter: Make sure we… we stay in time.

40
00:09:08.230 --> 00:09:26.110
Karim T. (matkt): I think it's too early, because we wanted to use DevNet2 to verify if the batch reading is useful or not. We also… we will also add separation between block access list and body, etc. So…

41
00:09:26.810 --> 00:09:34.740
Karim T. (matkt): In my opinion, I would prefer to have the DevNet2 only focusing on block access list, and maybe the next one

42
00:09:34.930 --> 00:09:37.890
Karim T. (matkt): We'll be, able to…

43
00:09:38.200 --> 00:09:47.899
Karim T. (matkt): to integrate more EIPs, but my feeling is maybe it's too soon to add additional EIPs that are not related to block access lists in DevNet 2, but…

44
00:09:49.870 --> 00:09:54.480
Jared Wasinger: Yeah, I lean towards agreeing with that, from the Geth's side.

45
00:09:55.170 --> 00:09:58.589
Jared Wasinger: There's a possibility we could make the…

46
00:09:58.970 --> 00:10:10.370
Jared Wasinger: the deadline, or the intended start date, but we still haven't even, to my knowledge, nobody has started implementing, the EIP for the…

47
00:10:10.750 --> 00:10:20.279
Jared Wasinger: ETH transfers on log, and I'm personally not very familiar with that, not sure what the complexity is, so it's hard for me to, give a…

48
00:10:20.520 --> 00:10:24.460
Jared Wasinger: Firm thumbs up to the, that date.

49
00:10:26.160 --> 00:10:30.280
Toni Wahrstätter: Yeah, I can, I can definitely see that perspective, too.

50
00:10:30.640 --> 00:10:35.239
Toni Wahrstätter: Maybe a question to, Stefan. Like, how…

51
00:10:35.420 --> 00:10:41.169
Toni Wahrstätter: set in stone is the date of the 21st of January, versus could we just…

52
00:10:41.450 --> 00:10:46.179
Toni Wahrstätter: delay DevNet 2, or what would that mean for you guys?

53
00:10:49.720 --> 00:10:58.909
Stefan Starflinger: Nothing necessarily is set in stone. We're happy to adjust, that we can move block-level accesses further as quickly as possible.

54
00:10:59.140 --> 00:11:14.730
Stefan Starflinger: Depending on how the clients, are progressing. We can also have a definite 3 as well, so I think we just need to agree on, exactly how we want, and what we want to have in the definites, such that we can move fast.

55
00:11:17.100 --> 00:11:24.009
Toni Wahrstätter: Right, yeah. As Karim said, we wanted, definitely two to definitely include, like, batch reading.

56
00:11:24.160 --> 00:11:27.519
Toni Wahrstätter: At least for a few clients, such that we're able to benchmark

57
00:11:27.910 --> 00:11:41.290
Toni Wahrstätter: the state locations, and finally decide if we want to keep the state locations slash the reads in the block lab access list or not. How far are clients with that? Is there a client team that has already implemented batch reading?

58
00:11:41.790 --> 00:11:44.129
Toni Wahrstätter: Using the state locations from the bul.

59
00:11:45.750 --> 00:11:54.129
Karim T. (matkt): On Bezoo, we have a first implementation. I wanted to do some tests next week to be sure it's working correctly.

60
00:11:54.440 --> 00:12:04.950
Karim T. (matkt): But yeah, on Bezu, we have a first PR, and maybe we'll be able to merge it next week, or at the end of the next week, or something like that.

61
00:12:10.750 --> 00:12:15.879
Toni Wahrstätter: Okay, yeah, this is great. Is there another client team that has already looked into batch reading?

62
00:12:32.440 --> 00:12:42.140
Toni Wahrstätter: Okay, I interpret that as a no. How far are clients in general with the batch reading? Is this something that clients are working on right now?

63
00:12:42.560 --> 00:12:45.310
Toni Wahrstätter: Just to give you some context for…

64
00:12:45.420 --> 00:12:48.190
Toni Wahrstätter: Some of the repricing work that…

65
00:12:48.520 --> 00:12:52.340
Toni Wahrstätter: or some of the repricing EAPs that have been CFI'd for Glamsterdam.

66
00:12:53.370 --> 00:12:59.389
Toni Wahrstätter: They're still waiting for benchmarks, and be… before, we don't figure out, like.

67
00:13:00.630 --> 00:13:12.660
Toni Wahrstätter: how much we actually get from block accesses, it's difficult for them to do the benchmarking, which means we… the boss is basically blocking some of the repricing work.

68
00:13:12.790 --> 00:13:17.369
Toni Wahrstätter: So this is, like, why… It's maybe pressuring that we get the…

69
00:13:17.600 --> 00:13:20.849
Toni Wahrstätter: BatchIO implemented in order for us to figure out

70
00:13:20.980 --> 00:13:23.469
Toni Wahrstätter: How the final part design will look like.

71
00:13:27.060 --> 00:13:29.239
Toni Wahrstätter: Is there a client team that,

72
00:13:29.410 --> 00:13:33.709
Toni Wahrstätter: is planning to start, implementing that soon, apart from Bezo.

73
00:13:49.410 --> 00:13:50.830
Jared Wasinger: I…

74
00:13:50.890 --> 00:14:04.520
Jared Wasinger: So, I can just give a, like, a very brief summary of what this roadmap looks like for Geth. Right now, we're just trying to get the existing, like, a…

75
00:14:04.580 --> 00:14:15.150
Jared Wasinger: most of the BAL, changes, with the exception of the performance-related changes in… merged into the master branch,

76
00:14:15.810 --> 00:14:20.900
Jared Wasinger: And… yeah, I mean, I intend to look into it,

77
00:14:21.000 --> 00:14:26.460
Jared Wasinger: I'm hoping we can get this merging process done in the next week or so.

78
00:14:26.750 --> 00:14:33.360
Jared Wasinger: But, yeah, we haven't… I haven't, made any headway on that.

79
00:14:36.450 --> 00:14:42.419
Toni Wahrstätter: Okay, thank you. Also, just to relay the message from Mark, from NetherMind is also saying.

80
00:14:42.530 --> 00:14:48.489
Toni Wahrstätter: Netherland hasn't looked into it yet, but they were more focused on the parallel execution.

81
00:14:50.930 --> 00:15:00.630
Toni Wahrstätter: Yeah, and Karim is saying, seems like 21 for Definite will be too soon. That's my… my feeling, and that's… my feeling too, especially if we…

82
00:15:00.820 --> 00:15:09.549
Toni Wahrstätter: want to get the benchmarks for DevNet 2, we might want to at least wait until at least one client team has implemented the batch I.O, such that we can

83
00:15:10.020 --> 00:15:12.510
Toni Wahrstätter: Yeah, get the benchmarks.

84
00:15:19.240 --> 00:15:37.219
Karim T. (matkt): Also, for DevNet 2, we are working… we are trying to do the separation between block access list and body, and we wanted to have more clarification regarding how the test will work. More exactly, if we remove block access list from the block.

85
00:15:37.280 --> 00:15:41.749
Karim T. (matkt): Who will, do the import in the test? In the Hive test?

86
00:15:47.040 --> 00:15:51.540
felipe: Yeah, I… I assume you're talking about the RLP tests, correct?

87
00:15:52.040 --> 00:15:52.730
Karim T. (matkt): Yes.

88
00:15:53.810 --> 00:15:59.850
felipe: Yeah, this is something that's worth discussing with the client teams if… If we have a separate…

89
00:16:00.510 --> 00:16:06.189
felipe: file with the bell, just as we do with the blocks.

90
00:16:06.900 --> 00:16:11.720
felipe: Yeah, we'll have to discuss and figure something out that works for everyone.

91
00:16:14.180 --> 00:16:20.110
felipe: Because, yeah, from Amsterdam on, this is going to change the entirety of the RLP tests.

92
00:16:24.820 --> 00:16:28.630
Karim T. (matkt): Yeah, because if we want to have maybe that for the next DevNet,

93
00:16:29.070 --> 00:16:32.779
Karim T. (matkt): Huh, just to… we need to find a way to test that.

94
00:16:36.620 --> 00:16:37.730
Karim T. (matkt): Yeah, that…

95
00:16:37.730 --> 00:16:44.170
felipe: The engine API still has, like, Consume Engine is still testable, is this correct?

96
00:16:58.340 --> 00:17:02.240
felipe: Is the… sorry, is the issue only with the RLP tests, or…

97
00:17:02.940 --> 00:17:04.280
Karim T. (matkt): Oh, yeah, yeah, yeah, yeah.

98
00:17:04.280 --> 00:17:05.919
felipe: Yeah. Yeah, so…

99
00:17:06.349 --> 00:17:10.899
felipe: So we wanted to get the test release out so at least Consume Engine can be tested.

100
00:17:11.299 --> 00:17:16.809
felipe: If… okay, so if… if we have a separate file that has the VAL as an ROP,

101
00:17:17.449 --> 00:17:22.119
felipe: Is this a good way to do it? How do client teams feel about this?

102
00:17:29.679 --> 00:17:31.869
Karim T. (matkt): I don't know if we want to…

103
00:17:32.259 --> 00:17:36.489
Karim T. (matkt): to talk about that, no, but just, yeah, just wanted to raise that,

104
00:17:37.249 --> 00:17:44.749
Karim T. (matkt): Because today, Miroslavi did the PR, and, he asked this question, so…

105
00:17:45.219 --> 00:17:49.319
Karim T. (matkt): I wanted to be sure we… We're syncing both up.

106
00:17:51.870 --> 00:17:55.920
Karim T. (matkt): Yeah, we… we can definitely figure this out async as well.

107
00:17:55.920 --> 00:17:59.239
felipe: But it'll be important to… to get this answered, for sure.

108
00:18:00.330 --> 00:18:00.940
Karim T. (matkt): Thank you.

109
00:18:04.660 --> 00:18:05.290
Toni Wahrstätter: Right.

110
00:18:05.650 --> 00:18:09.890
Toni Wahrstätter: Just to answer Banaba's question here in the chat.

111
00:18:10.360 --> 00:18:28.660
Toni Wahrstätter: So, what is… the state locations are useful for two things. First of all, we want to find out if… so the batch reading is useful for two things. We want to find out if the state locations are worth it, because the state locations are, like, 50% of the ball size.

112
00:18:28.760 --> 00:18:38.050
Toni Wahrstätter: And removing them would, of course, improve bulb propagation and stuff. So, we have to have some certainty that the

113
00:18:38.180 --> 00:18:48.849
Toni Wahrstätter: knowing all the state locations that are not even changed is actually worth it to have in the ball. So this is the… the main thing we try to achieve here. And second.

114
00:18:49.530 --> 00:18:53.029
Toni Wahrstätter: Some of the repricing work is blocked, in a sense that

115
00:18:53.360 --> 00:19:04.520
Toni Wahrstätter: it's not even clear which repricings EAP are needed, because, of course, if block access lists help you a lot with, fetching data from the state.

116
00:19:05.040 --> 00:19:12.569
Toni Wahrstätter: Then we might not meet aggressive state repricings, as they are proposed in some of the

117
00:19:12.670 --> 00:19:15.780
Toni Wahrstätter: state repricing EAPs that are up for discussion.

118
00:19:17.500 --> 00:19:23.630
Toni Wahrstätter: So yeah, I was talking with Maria, who is, very involved in that effort, and she was, saying that

119
00:19:24.210 --> 00:19:29.680
Toni Wahrstätter: That this is the case for them, that they can't really get, it's not only about final numbers, but

120
00:19:30.150 --> 00:19:38.450
Toni Wahrstätter: basically get any number to even know is a certain repricing EAP, very much needed, or can it be delayed, for example?

121
00:19:41.440 --> 00:19:43.249
Toni Wahrstätter: Just as some context.

122
00:19:47.820 --> 00:19:59.510
Toni Wahrstätter: Regarding the replayable Baal benchmark question that I see here from Lukash, let me check if Jocham is actually on the call, because Jocham has some great insights into

123
00:19:59.910 --> 00:20:06.079
Toni Wahrstätter: that topic. Yochma, you on the call-in could give us some… Some details on ballot benchmarking.

124
00:20:07.010 --> 00:20:13.290
jochem-brouwer: Yes, so what is the… okay, the question is, like, how do we actually want to test this?

125
00:20:15.140 --> 00:20:15.960
Toni Wahrstätter: Exactly, yeah.

126
00:20:15.960 --> 00:20:19.949
jochem-brouwer: Do we have some good replayable ball benchmarks? That's the question, right?

127
00:20:23.710 --> 00:20:29.009
Toni Wahrstätter: Yes, exactly. Like, how would we test the parallelization and that everything is working?

128
00:20:29.250 --> 00:20:34.480
jochem-brouwer: Yes, yes. So, what we do here is, what we want to do is…

129
00:20:35.390 --> 00:20:38.039
jochem-brouwer: If you want to parallelize transactions now.

130
00:20:38.700 --> 00:20:43.060
jochem-brouwer: What clients do is optimistically execute transactions in parallel.

131
00:20:43.640 --> 00:20:52.479
jochem-brouwer: So what we want to do for the benchmarking effort here is we want to create tests which cannot be parallelized without the block-level access list.

132
00:20:52.710 --> 00:20:56.079
jochem-brouwer: So how do you do that? Well, a very simple example would be…

133
00:20:56.340 --> 00:21:13.040
jochem-brouwer: in the first transaction, you would keep hashing something, and then you would store the hash result in the storage slot. Then in the second transaction, you would read the hash from the storage slot, and you would keep hashing it again, and you would store it again in the storage slot.

134
00:21:13.270 --> 00:21:22.669
jochem-brouwer: So what is the end result of this storage slot? Well, it's basically being a slot which has been hashed, like, over multiple transactions.

135
00:21:22.880 --> 00:21:27.870
jochem-brouwer: So, if you would execute this optimistically, without block-level access lists.

136
00:21:27.950 --> 00:21:47.320
jochem-brouwer: then every transaction would point to the same… or would end up with the same storage slot, so let's say we would store that key 0, then every transaction would end up with the same hash. But, obviously, in this case, we have to keep hashing this item, so without the block-level access, we cannot do this in parallel.

137
00:21:47.630 --> 00:21:52.399
jochem-brouwer: Because if we have the block-level access list, then we can actually read the storage slots

138
00:21:52.490 --> 00:22:12.010
jochem-brouwer: from the block-level access list, and we can start hashing from there, and therefore we can execute these things in parallel. And we can also do this for, like, anything which has to do with storage, so we'll break up these tests in tests which cannot be executed in parallel without the block-level access list.

139
00:22:12.120 --> 00:22:14.320
jochem-brouwer: If that makes, sense.

140
00:22:24.290 --> 00:22:28.139
Łukasz Rozmej: Yeah, but, if I can, say something,

141
00:22:28.380 --> 00:22:32.359
Łukasz Rozmej: That doesn't really tell us much about the…

142
00:22:32.640 --> 00:22:37.440
Łukasz Rozmej: Red addresses, red slots, right?

143
00:22:37.610 --> 00:22:40.910
Łukasz Rozmej: Should we include it or not? Because this is a bit different.

144
00:22:41.030 --> 00:22:42.060
Łukasz Rozmej: problem.

145
00:22:43.080 --> 00:22:52.230
Łukasz Rozmej: Also… if we, like, run those kind of benchmarks on a relatively empty state, That's…

146
00:22:52.650 --> 00:23:03.329
Łukasz Rozmej: also pretty easy, right? Because empty state is fast to read, or almost empty state is fast to read, while if the state is big, it's slower to read.

147
00:23:03.610 --> 00:23:09.369
Łukasz Rozmej: So… Yeah, I don't think it's that simple.

148
00:23:10.490 --> 00:23:14.599
jochem-brouwer: Yeah, okay, so for this example, I took, like, a hashtag,

149
00:23:14.980 --> 00:23:24.009
jochem-brouwer: Can someone inform me, like, about these slots? Because I think, Tony, this is about adding the slot keys which are being read to the block level accesses, right?

150
00:23:24.810 --> 00:23:28.779
Toni Wahrstätter: Exactly, yeah, and the addresses that are accessed but not changed.

151
00:23:29.210 --> 00:23:40.539
jochem-brouwer: Right, and the question is, do we want to add these slots, because it adds, like, a lot of data, or do we not want this, and we want to test in the benchmarks if this is, well, what the benefits of it will be, right?

152
00:23:41.600 --> 00:23:46.719
Toni Wahrstätter: Exactly, yeah. Right now, they are part of the ERP, and they're part of the specs, and…

153
00:23:46.950 --> 00:24:00.730
Toni Wahrstätter: So far, clients have signaled that it might be worth to have those, but of course, we… I think in Buenos Aires, we said we want to actually wait for final numbers before we lock that in.

154
00:24:02.030 --> 00:24:05.720
jochem-brouwer: Yes, okay, so I'm just thinking out loud, then.

155
00:24:05.830 --> 00:24:09.680
jochem-brouwer: So to test this, we would basically…

156
00:24:10.120 --> 00:24:22.660
jochem-brouwer: Okay, yeah, first, Lucas, because you also mentioned, like, are we going to benchmark this on empty state? No, we will not do that, because if you would benchmark it on empty states, you are absolutely right.

157
00:24:22.660 --> 00:24:38.829
jochem-brouwer: you can basically cache the entire Merkle tree into your memory, and then it's obviously, like, very fast. So, if we'll benchmark this, we will benchmark this on a mainnet fork, or maybe a load net, so that's, like, two times the size of a mainnet to actually simulate

158
00:24:38.920 --> 00:24:45.130
jochem-brouwer: Well, big-sized networks, and also take care of, like, the lookup time of these, of this data.

159
00:24:45.590 --> 00:24:52.869
jochem-brouwer: And then for the benchmarking itself, for what I would want to see, it's like the impact of reading these storage slots.

160
00:24:55.140 --> 00:25:04.850
jochem-brouwer: So, in that case, I think we can come up with, like, a variant also of, like, a hash chain, where we also have to read multiple storage slots first, and then also write to them.

161
00:25:04.990 --> 00:25:10.040
jochem-brouwer: You're right, it's not… As simple as, like, writing a hash chain, but,

162
00:25:10.390 --> 00:25:15.239
jochem-brouwer: Yeah, we can do that, we can do that. I will, I will think about this, but we,

163
00:25:15.730 --> 00:25:17.479
jochem-brouwer: Maybe already have some countries.

164
00:25:17.480 --> 00:25:30.440
Łukasz Rozmej: Generally, yes, but what I want to say is that it's hard to reliably benchmark those kind of things, because you basically have to create some snapshots for each client.

165
00:25:30.590 --> 00:25:41.519
Łukasz Rozmej: To be able to replay the same blocks over and over, right? Etc. And create those blocks, so it's not trivial, that's what I want to say.

166
00:25:42.140 --> 00:25:52.699
jochem-brouwer: Yes, I completely agree. It's also, like, hard to measure this, but as part of the cash benchmarking effort, the Netamind team,

167
00:25:52.700 --> 00:25:56.069
Łukasz Rozmej: It's, like, working on this gas benchmark tool.

168
00:25:56.070 --> 00:26:05.070
jochem-brouwer: And… What is doing… what people are doing there, is… That's… we,

169
00:26:05.220 --> 00:26:08.699
jochem-brouwer: Try to keep, like, the cash out, we can,

170
00:26:10.800 --> 00:26:19.600
jochem-brouwer: If we would benchmark these things, we would also read, we would, like, start, keep starting and stopping these slides to actually get, like, these reliable results.

171
00:26:19.600 --> 00:26:28.590
Łukasz Rozmej: Yeah, I know, I know, we have this kind of things, but, yeah, I wanted to actually ping that out, that you should maybe talk with Camille, etc, but okay, we're already covered.

172
00:26:28.810 --> 00:26:35.789
jochem-brouwer: Yes, yes, yes, exactly, yeah, Kabulus indeed working on this, yeah. So that will indeed be, yeah, how to measure these, these kind of things, yeah.

173
00:26:40.270 --> 00:26:48.130
jochem-brouwer: And then, of course, we need, like, these benchmarks to specifically test, like, what's, like, the benefit of these state reads and state flights.

174
00:26:48.430 --> 00:26:53.630
jochem-brouwer: I will think about this. It should be not super hard, but also not super easy.

175
00:26:58.130 --> 00:26:59.460
Toni Wahrstätter: Thank you very much.

176
00:26:59.460 --> 00:27:00.300
jochem-brouwer: Yes.

177
00:27:00.960 --> 00:27:15.509
Toni Wahrstätter: This is great, and especially, yeah, I think it's a good idea to have it on a shadow fork of mainnet, and then also test it on BloatNet, just to make sure that things don't look very different as soon as the state increases.

178
00:27:16.700 --> 00:27:20.220
Toni Wahrstätter: I see Barnabas has his hand up. Please go ahead.

179
00:27:20.990 --> 00:27:39.810
Barnabas: Yeah, so you guys talked a bunch about repricing and how it will affect future repricing EIPs, and you need benchmarking, but in terms of the scope of DevNet 2, none of this matters. We're introducing four EIPs, none of them are,

180
00:27:40.380 --> 00:27:50.039
Barnabas: none of them require benchmarking, basically. I feel like, the ball.net, should work on, implementation.

181
00:27:50.140 --> 00:28:08.920
Barnabas: featuredness, and making sure all the EIPs that own touch the ELs, are done and implemented by every single EL team, and then once it's coming to the actual repricing values, that should be a parallel discussion, that's not really related to DevNet progression.

182
00:28:09.680 --> 00:28:16.909
Barnabas: So, like, we shouldn't be blocking DevNet2 just because we don't have the, exact numbers for, repressing EIP.

183
00:28:17.120 --> 00:28:20.579
Barnabas: Especially because there's no repressing EIP proposed for .NET2.

184
00:28:21.280 --> 00:28:25.110
Barnabas: have the spec sheet, that Stefan made.

185
00:28:25.330 --> 00:28:27.350
Barnabas: for the DevNet2 scope.

186
00:28:27.560 --> 00:28:30.389
Barnabas: Yeah, as you can see, it's,

187
00:28:30.670 --> 00:28:40.429
Barnabas: It's basically new instructions, the e-transfer emit, a log, a new opcode, and, excluded refunds from log S.

188
00:28:41.860 --> 00:28:46.490
Barnabas: But none of these are benchmark-related questions.

189
00:28:47.020 --> 00:28:55.190
Barnabas: So, that's why I suggested that we could probably launch DevNet2 next week, because these are all,

190
00:28:55.350 --> 00:28:58.610
Barnabas: fairly small implementation, VIPs.

191
00:29:01.250 --> 00:29:12.489
Toni Wahrstätter: Yeah, this is true, like, all those four EIPs won't affect Block Live Access List, so nothing new for the Block Live Access List specs happening there. It's more like

192
00:29:12.720 --> 00:29:20.770
Toni Wahrstätter: for example, tomorrow we will, again, CFI, DFI a few EAPs in the Alcadvs call.

193
00:29:20.860 --> 00:29:33.319
Toni Wahrstätter: And it's hard to make that decision without knowing how much we actually need to change the state pricing, for example. So it's not really about those smaller EAPs, it's more like

194
00:29:34.370 --> 00:29:42.129
Toni Wahrstätter: yeah, giving us earlier information such that we can take a good decision on what EAP to CFI and which one not.

195
00:29:42.400 --> 00:29:57.120
Toni Wahrstätter: Because currently, it's not super clear how much block-level access list will help with state-related stuff, and if it helps a lot, the repricing might not be needed, or might be less aggressive. If it's not…

196
00:29:57.460 --> 00:30:05.299
Toni Wahrstätter: that impactful for a state, then we need a potentially more aggressive repricing. So it's more about,

197
00:30:05.470 --> 00:30:09.079
Toni Wahrstätter: Yeah, about the repricing work that is still undecided.

198
00:30:09.240 --> 00:30:29.220
Barnabas: But this is, again, a totally different parallel discussion. What the value of the repressing should be can be decided, by the benchmarking guys, but in terms of progression, we want to have all the EIPs that are CFI'd implemented, because that is the whole point of, having CFI'd.

199
00:30:29.370 --> 00:30:40.870
Barnabas: So, we implement the EIP that was proposed for the change, and then we can evaluate if the given values that were CFI'd are correct or not in a much later DevNet.

200
00:30:41.020 --> 00:30:52.339
Barnabas: But for now, I would just propose that we implement what is, what has been proposed and accepted as a CFI candidate, and then if those values

201
00:30:52.480 --> 00:30:58.110
Barnabas: deemed to be incorrect, then we can adjust them, and we can roll it out for the next following that.

202
00:30:58.740 --> 00:31:05.980
Barnabas: Especially for the, where it's just a single… changing a single value in a repressing ERP.

203
00:31:06.460 --> 00:31:07.520
Barnabas: Fairly easy.

204
00:31:08.010 --> 00:31:17.939
Toni Wahrstätter: Yeah, fair enough. I very much agree with you. So, I don't think the repricing should block us at all when it comes to launching Ball Defnets, I would say

205
00:31:18.020 --> 00:31:37.970
Toni Wahrstätter: it's definitely worth it to wait, if it only… if it's only a few more days, to wait until at least one client has implemented the parallel batch I.O, because this will already give us, like, very, good numbers for, not only for the repricing work, but also for block lab access lists itself.

206
00:31:38.120 --> 00:31:40.930
Toni Wahrstätter: Deciding if we keep the state locations or not.

207
00:31:41.050 --> 00:31:47.149
Toni Wahrstätter: But apart from that, I totally agree. Like, the repricing work, is not blocking us here.

208
00:31:48.060 --> 00:31:59.640
Barnabas: But there's also the parallel I.O. stuff is not a consensus change, so it can be just rolled out. Let's say we launch MNT2 on Wednesday, it could be rolled out on Thursday, if one client is ready there.

209
00:32:02.000 --> 00:32:18.999
Toni Wahrstätter: Yeah, I'm fine with that too, yeah. I was just thinking that we… okay. Okay, this is good to know, so we can launch DEFNET 2 on the 21st, and if clients finish BatchIO implementation after that, we could still integrate it, right?

210
00:32:21.190 --> 00:32:28.039
Barnabas: Yeah, we just need to make sure the ball is rolling forward and not getting blocked on stuff that is not an actual blocker.

211
00:32:30.310 --> 00:32:31.010
Toni Wahrstätter: Perfect.

212
00:32:34.390 --> 00:32:45.739
Toni Wahrstätter: Yeah, then the question is, of course, like, will clients be able to, implement those four ERPs until the 21st, which, Karim and Jared were, yeah, pessimistic about?

213
00:32:46.400 --> 00:32:53.589
Toni Wahrstätter: We can… We can, of course, delay the definite to get those four EIPs ready.

214
00:32:56.400 --> 00:32:58.159
Toni Wahrstätter: I guess that's what we are.

215
00:32:59.430 --> 00:33:01.560
Toni Wahrstätter: about to do, or is there?

216
00:33:01.940 --> 00:33:04.770
Toni Wahrstätter: Or what do you think, Karim or Jared,

217
00:33:05.830 --> 00:33:07.500
Toni Wahrstätter: What do you think about this?

218
00:33:12.670 --> 00:33:19.990
Karim T. (matkt): I think I would prefer to delay a bit, honestly. We still have some stuff to finish.

219
00:33:20.240 --> 00:33:26.230
Karim T. (matkt): For example, separation of the local faces and body is not completely merged.

220
00:33:26.930 --> 00:33:28.530
Karim T. (matkt): And,

221
00:33:28.630 --> 00:33:34.289
Karim T. (matkt): RPC method, we just started to work on it today. I don't know, maybe it will be ready for 21.

222
00:33:34.680 --> 00:33:41.480
Karim T. (matkt): But, for me, it seems to be a really… smaller…

223
00:33:41.600 --> 00:33:44.569
Karim T. (matkt): Period to finish everything correctly, but…

224
00:33:47.990 --> 00:33:50.650
Karim T. (matkt): I don't know what the other clients think, but…

225
00:33:52.120 --> 00:33:55.809
Jared Wasinger: Yeah, I agree with that. I would prefer to delay it.

226
00:34:00.440 --> 00:34:05.619
Toni Wahrstätter: What was the last thing? You're for delaying it, or for not delaying it, and then we roll out?

227
00:34:05.740 --> 00:34:08.119
Toni Wahrstätter: Any changes later into the dev.

228
00:34:12.750 --> 00:34:14.930
Toni Wahrstätter: I guess you said delaying it, right?

229
00:34:17.719 --> 00:34:18.749
Toni Wahrstätter: Okay, yeah.

230
00:34:20.179 --> 00:34:21.869
Toni Wahrstätter: Yeah, I can totally see that.

231
00:34:22.729 --> 00:34:34.349
Toni Wahrstätter: I would say, we can coordinate, on that async, especially, also with Stefan, what Stefan thinks about this, and see where we're at on the 21st next week.

232
00:34:34.929 --> 00:34:37.689
Toni Wahrstätter: But, yeah, I think it's good for now.

233
00:34:37.839 --> 00:34:46.099
Toni Wahrstätter: We can keep the 21st for now, and then see where we are in a week, and if it takes a few more days, we will just delay the launch of Definitely2.

234
00:34:47.810 --> 00:34:53.069
Jared Wasinger: Yeah, so like I, said earlier, I'm not,

235
00:34:53.090 --> 00:35:01.520
Jared Wasinger: I'm not the one on the death side implementing the other EIPs that are being bundled into this, so it's hard for me to…

236
00:35:01.530 --> 00:35:13.369
Jared Wasinger: give a firm commitment. I do think if the DevNet only… if DevNet2 only included the, the decoupling changes that were made,

237
00:35:13.660 --> 00:35:18.660
Jared Wasinger: I think it would be… Perhaps a reasonable timeline?

238
00:35:18.800 --> 00:35:24.750
Jared Wasinger: But yeah, I'm also for,

239
00:35:26.290 --> 00:35:32.060
Jared Wasinger: I think as it's planned right now, it's… very…

240
00:35:33.590 --> 00:35:36.819
Jared Wasinger: possible that we, I won't be able to make that deadline.

241
00:35:45.170 --> 00:35:48.480
Toni Wahrstätter: Perfect. I think, everything's clear now.

242
00:35:48.680 --> 00:35:50.770
Toni Wahrstätter: Then let's stick to that, we will…

243
00:35:51.360 --> 00:36:01.590
Toni Wahrstätter: see where we are on the 21st, and if it takes a few more days, we will just delay DevNet too, such that we can have those four EAPs implemented on top of the bar Defnet.

244
00:36:05.670 --> 00:36:12.439
Karim T. (matkt): Just, not sure how long it will take to have this EAP site, but maybe we should ask people that are working on it.

245
00:36:14.430 --> 00:36:25.870
Toni Wahrstätter: Yeah, I quickly talked with Marios yesterday about those four ERPs, so Marios was saying the complexity coming from those ERPs is rather low. I think the ETH transfers is the most complex one, and the other ones are…

246
00:36:26.370 --> 00:36:27.380
Toni Wahrstätter: Okay-ish?

247
00:36:27.730 --> 00:36:32.930
Toni Wahrstätter: But of course, this is, only one data point. Yeah, we will have to see.

248
00:36:35.050 --> 00:36:39.870
Karim T. (matkt): Because if it's just stealing too much, maybe it's just better to start without that, and…

249
00:36:42.250 --> 00:36:43.519
Toni Wahrstätter: Yeah, I agree.

250
00:36:45.070 --> 00:36:51.830
Toni Wahrstätter: yeah, let's see where we are next week. We have more clarity, I would say, and then we can take a decision on that.

251
00:36:53.490 --> 00:36:54.270
Toni Wahrstätter: Great.

252
00:36:54.880 --> 00:37:02.109
Toni Wahrstätter: Yeah, and this already brings us to the… to the next agenda item, which is what changed, with block access lists recently.

253
00:37:02.980 --> 00:37:22.130
Toni Wahrstätter: As already said, the block lab access list was moved out of the execution block, and is now separate. It's still in the execution payload, so passed from the CL to the EL via the execution payload, so this didn't change, but it's not, part of the block body anymore.

254
00:37:22.150 --> 00:37:26.989
Toni Wahrstätter: And this should definitely be something we roll out with Definite2 already.

255
00:37:28.020 --> 00:37:29.630
Toni Wahrstätter: Same for…

256
00:37:29.840 --> 00:37:46.439
Toni Wahrstätter: What else do we have on the agenda here? Same for the JSON RPC methods. That would also be part of the scope of DefNet2 already. So, to summarize, moving the block-level access list out of the block, and the JSON RPC method.

257
00:37:50.600 --> 00:37:54.070
Toni Wahrstätter: Those would be the changes, compared to FNET1.

258
00:37:54.920 --> 00:37:57.139
Toni Wahrstätter: Is there any other change that I forgot now?

259
00:38:01.690 --> 00:38:02.810
Toni Wahrstätter: Don't think so.

260
00:38:11.140 --> 00:38:12.110
Toni Wahrstätter: Perfect.

261
00:38:13.140 --> 00:38:21.820
Toni Wahrstätter: Yeah, looking at the agenda, then there's a… let me actually post the agenda quickly in the chat, such that everyone can have a look.

262
00:38:23.200 --> 00:38:25.029
Toni Wahrstätter: As you can see on the agenda.

263
00:38:25.380 --> 00:38:40.610
Toni Wahrstätter: Under specs, updates, and Clarification, there was a comment by LightClient that we should further clarify what we mean with access. This has already been a topic last week and, two weeks ago, or a few weeks ago in the last Block Live Access List call.

264
00:38:40.610 --> 00:38:46.950
Toni Wahrstätter: Like, when do we actually put an account onto the block-level access list versus…

265
00:38:47.080 --> 00:38:49.999
Toni Wahrstätter: Versus not, and it has to do with…

266
00:38:50.640 --> 00:39:03.450
Toni Wahrstätter: doing all the static gas checks up front, and only when we actually need to go to state, we put the block level access list on… We put the account on the block level access list. And since this has never been

267
00:39:03.680 --> 00:39:08.480
Toni Wahrstätter: Clearly specified, so clients could do different things here.

268
00:39:08.810 --> 00:39:24.710
Toni Wahrstätter: we saw some issues with testing. I think most of them are resolved, but as you can see in the EAP, there is a new section further clarifying what we mean with access for each different opcode, and when we actually

269
00:39:24.800 --> 00:39:37.660
Toni Wahrstätter: put the account into the block lab access list. So if you haven't seen that yet, please check that out. I think clients are already doing it correctly by now, because otherwise we wouldn't pass those tests.

270
00:39:37.920 --> 00:39:39.480
Toni Wahrstätter: But just as a heads up.

271
00:39:45.710 --> 00:39:46.540
Toni Wahrstätter: Great.

272
00:39:47.180 --> 00:39:51.189
Toni Wahrstätter: Then, let's move on to the next item, which is testing updates.

273
00:39:51.610 --> 00:39:58.160
Toni Wahrstätter: We already talked a bit about testing now, but Felipe, could you give us a quick update? Also.

274
00:39:58.290 --> 00:40:04.750
Toni Wahrstätter: potentially focusing on DEFNET2 already. Is there anything we should, consider for testing?

275
00:40:07.400 --> 00:40:09.530
felipe: Yeah, yeah, we talked about the…

276
00:40:10.040 --> 00:40:18.349
felipe: these consume RLP changes that are going to need to happen. I already… I created a thread in the block file-level access list channel.

277
00:40:18.830 --> 00:40:22.159
felipe: That we should start discussing that, I think.

278
00:40:22.390 --> 00:40:25.840
felipe: It'll be nice to get input from clients on that… on that front.

279
00:40:26.570 --> 00:40:28.099
felipe: I'm best to…

280
00:40:28.410 --> 00:40:36.490
felipe: to go about that new, consumer interface for ROP. But as far as a test update,

281
00:40:37.190 --> 00:40:41.000
felipe: Related to this… This, this update.

282
00:40:41.300 --> 00:40:42.890
felipe: For the gas boundaries.

283
00:40:43.020 --> 00:40:44.720
felipe: There was an issue.

284
00:40:44.970 --> 00:40:54.950
felipe: on the… on the DevNet that, was related to this for self-destruct, and we had included all of the gas boundaries for… for the call-off codes already.

285
00:40:55.050 --> 00:41:00.940
felipe: In the tests, and this latest Test release has,

286
00:41:01.830 --> 00:41:16.070
felipe: all… I believe all, the gas boundaries and all sorts of cases for self-destruct as well, because this was related to the issue. So that coverage got increased greatly,

287
00:41:16.320 --> 00:41:20.309
felipe: And we also turned on all of the old Ethereum tests.

288
00:41:21.170 --> 00:41:28.469
felipe: They used to live inside the Ethereum tests repo. They now live in the execution specs repo as static tests.

289
00:41:28.900 --> 00:41:39.389
felipe: And these were all filled for Amsterdam in this last release as well, and so we have greatly increased the test coverage, since the last release in this… in this one.

290
00:41:43.690 --> 00:41:49.299
Toni Wahrstätter: Awesome, thanks for the update. Is there anything… any questions someone has, client teams have?

291
00:42:05.290 --> 00:42:07.890
Toni Wahrstätter: Okay, I just thought a question by…

292
00:42:09.220 --> 00:42:17.970
Toni Wahrstätter: BirdNet, do we need the nchain getBAs by hash V1, nChain get balls by range? For definite 2.

293
00:42:18.870 --> 00:42:20.920
Toni Wahrstätter: And this is a good question.

294
00:42:21.070 --> 00:42:26.500
Toni Wahrstätter: What do clients think about this? Do we already want to include that for DEFNET2?

295
00:42:27.220 --> 00:42:30.820
Toni Wahrstätter: I would default, by default, say yes, but,

296
00:42:31.310 --> 00:42:33.879
Toni Wahrstätter: Happy to hear, other opinions.

297
00:42:34.670 --> 00:42:40.519
Jared Wasinger: Can you just… shortly explain how those are used by the CL?

298
00:42:47.220 --> 00:42:53.949
Toni Wahrstätter: Yes, so… Get lost by hashing one. Let me quickly think about it.

299
00:42:54.230 --> 00:43:12.530
Toni Wahrstätter: So, recently, this is different, but recently, I've created a PR regarding DevP2P, because we need DevP2P for the syncing of block-level access lists. For example, if your node falls behind and you want to request the block-level access lists independently from the block, or if you just want to

300
00:43:12.530 --> 00:43:15.399
Toni Wahrstätter: Use it to update your state.

301
00:43:16.290 --> 00:43:21.979
Toni Wahrstätter: Regarding engine… get pulse by hash. This was basically,

302
00:43:22.720 --> 00:43:25.100
Toni Wahrstätter: Doing the same as we do for blocks.

303
00:43:25.470 --> 00:43:34.670
Toni Wahrstätter: So you would basically use it as you use it for blocks today. It would give you the same, and since blocks and block access lists were decoupled.

304
00:43:35.130 --> 00:43:43.010
Toni Wahrstätter: We would need this… this function to actually allow… allow you to get the block level access list, in addition to the block.

305
00:43:47.610 --> 00:43:55.360
Jared Wasinger: Okay, maybe I'm misinformed. I thought the… that the BAL was still part of the…

306
00:43:57.520 --> 00:44:07.539
Jared Wasinger: execution payload, okay, I'll… I'll… I'll take a look at the, proposed changes.

307
00:44:12.350 --> 00:44:13.230
Toni Wahrstätter: Great, yeah.

308
00:44:14.620 --> 00:44:18.120
Toni Wahrstätter: Yeah, I would also have to double-check that. Maybe we don't even need them?

309
00:44:18.510 --> 00:44:21.580
Toni Wahrstätter: Definitely something to double-check.

310
00:44:25.850 --> 00:44:27.580
Toni Wahrstätter: Someone has an opinion on that?

311
00:44:28.080 --> 00:44:29.849
Toni Wahrstätter: on the engine API methods.

312
00:44:43.780 --> 00:44:48.210
Stefan Starflinger: Is the implementation very different from implementing the RPC methods?

313
00:44:48.620 --> 00:44:50.259
Stefan Starflinger: For the engine methods?

314
00:44:52.890 --> 00:44:55.060
Toni Wahrstätter: It's definitely different, yeah.

315
00:44:56.170 --> 00:45:02.090
Toni Wahrstätter: So, the CL is not storing the block lab access lists, right? The CL will just, like…

316
00:45:02.550 --> 00:45:10.189
Toni Wahrstätter: store the block-level access list hash, the block-level access list root, just as they do with transactions, such that we don't have

317
00:45:10.340 --> 00:45:11.830
Toni Wahrstätter: duplicated data.

318
00:45:12.100 --> 00:45:18.570
Toni Wahrstätter: So, where you would need those engine API methods is if a node requests,

319
00:45:18.730 --> 00:45:26.990
Toni Wahrstätter: the execution payload from you, so this, a CL node would request the execution payload from another CL,

320
00:45:27.340 --> 00:45:35.700
Toni Wahrstätter: And the CL doesn't store the ball, so the CL would need a way to request the block level access list from the EL, and this is where

321
00:45:35.840 --> 00:45:37.530
Toni Wahrstätter: Those functions were needed.

322
00:45:47.600 --> 00:46:00.380
Stefan Starflinger: But from an implementation point of view, the ethG doc accesses lists by hash should be pretty similar to the engine get, values by hash implementation, just a different handler.

323
00:46:02.450 --> 00:46:04.669
Toni Wahrstätter: Yeah, I can see that. That's true.

324
00:46:05.860 --> 00:46:11.559
Toni Wahrstätter: I don't have an insight into how clients implemented it, but I can definitely see that those are very similar.

325
00:46:17.770 --> 00:46:25.740
Jared Wasinger: So, but, like, the… aren't the… the BALs are still in the execution payload?

326
00:46:26.310 --> 00:46:27.070
Jared Wasinger: that is…

327
00:46:27.070 --> 00:46:27.760
Toni Wahrstätter: Right, yeah.

328
00:46:27.760 --> 00:46:31.890
Jared Wasinger: to the CL, so they have it through there.

329
00:46:33.230 --> 00:46:34.490
Jared Wasinger: And…

330
00:46:34.490 --> 00:46:36.029
Toni Wahrstätter: They don't store them, though.

331
00:46:38.780 --> 00:46:40.930
Jared Wasinger: isn't… Hmm.

332
00:46:42.170 --> 00:46:52.280
Toni Wahrstätter: So what the CL does with transactions, transactions are stored on the EL, and the CL will only store the execution payload with the transaction's root.

333
00:46:52.660 --> 00:47:11.470
Toni Wahrstätter: Right? And the same will happen with the balls. So because this is, like, too much data to be duplicated, the CL will only store that block-level access list root in the execution payload, and if the CL actually needs the full block-level access list, the CL would need to request it from the EL.

334
00:47:24.300 --> 00:47:32.119
Jared Wasinger: Okay, Yeah, okay, so… so it's kind of similar to blobs, then?

335
00:47:32.920 --> 00:47:37.800
Jared Wasinger: Er, yeah, not really, but… Hmm.

336
00:47:39.030 --> 00:47:42.529
Jared Wasinger: Yeah, I mean, from… on the implementation side, it seems…

337
00:47:44.030 --> 00:47:53.150
Jared Wasinger: it's pretty straightforward. I mean, we… we have the block access lists sitting around, so it's just a matter of…

338
00:47:54.760 --> 00:48:00.280
Jared Wasinger: You know, loading them up and transmitting them, but, yeah.

339
00:48:02.730 --> 00:48:11.219
Karim T. (matkt): Do we have a CL using that for the moment? If we implement it for DevNet2, is this API will be used, or will it just be there?

340
00:48:13.990 --> 00:48:19.079
Toni Wahrstätter: I don't think so, I don't think we would use it for Definite 2 already,

341
00:48:19.360 --> 00:48:22.450
Toni Wahrstätter: Maybe… Stefan, do you think we would need it already?

342
00:48:23.740 --> 00:48:25.660
Toni Wahrstätter: I don't think so, personally.

343
00:48:26.190 --> 00:48:32.840
Stefan Starflinger: I'm not sure if we would, use it yet, because, yeah, like, the CRS

344
00:48:33.070 --> 00:48:40.240
Stefan Starflinger: probably won't have that implemented, but I can talk to Lodestar. Maybe they, can do something about it.

345
00:48:46.690 --> 00:48:48.350
Toni Wahrstätter: So I… Awesome, yeah.

346
00:48:49.000 --> 00:48:49.559
Toni Wahrstätter: Yeah, go ahead.

347
00:48:49.560 --> 00:48:57.980
Jared Wasinger: I guess the source of my confusion here is that, okay, so the access list is in the execution payload, but the CL…

348
00:48:58.160 --> 00:49:07.140
Jared Wasinger: Doesn't store it, but under which… circumstances would the CL… need…

349
00:49:07.780 --> 00:49:17.749
Jared Wasinger: A need to query the block access list again for a payload it had already received and discarded the block access list from.

350
00:49:20.630 --> 00:49:33.310
Toni Wahrstätter: For syncing. I think the CL, if you want to help other node syncing, you would want to give them the full execution payload, including their transactions, and including their block lab access list.

351
00:49:34.920 --> 00:49:38.520
Jared Wasinger: But isn't that… I thought we were… that… that's what…

352
00:49:38.670 --> 00:49:44.600
Jared Wasinger: is… but, oh, okay, I see. So, that kind of…

353
00:49:45.140 --> 00:49:54.520
Jared Wasinger: Presumes that, recomputing it locally is too… like, these nodes syncing are somewhat close to the tip.

354
00:49:54.800 --> 00:49:59.940
Jared Wasinger: And recomputing the access list locally would be too slow to…

355
00:50:00.270 --> 00:50:03.410
Jared Wasinger: sync, or maybe they're not full nodes, yeah, I don't know.

356
00:50:05.610 --> 00:50:16.139
Toni Wahrstätter: Yeah, the seal cannot really recompute them, so the only thing that you could do is, if you don't store it on the EL, you could recompute it on the EL and then return it to the seal.

357
00:50:16.670 --> 00:50:19.379
Toni Wahrstätter: This is, I guess, a different topic then.

358
00:50:19.950 --> 00:50:28.759
Toni Wahrstätter: The use case I'm thinking of, if you fall, like, a few blocks ahead, behind, and you want to catch up again, then you need some…

359
00:50:29.280 --> 00:50:38.780
Toni Wahrstätter: You need someone to feed you the blocks, and they would then include the full execution payload, including the full block access list.

360
00:50:40.040 --> 00:50:41.960
Jared Wasinger: Gotcha. Yeah, that makes sense.

361
00:50:49.950 --> 00:50:51.160
Toni Wahrstätter: Okay, perfect.

362
00:50:52.880 --> 00:50:53.800
Toni Wahrstätter: M?

363
00:50:54.540 --> 00:50:59.930
Toni Wahrstätter: We can also… we can also continue that discussion async to make sure we are all on the same page here.

364
00:51:14.750 --> 00:51:20.410
Toni Wahrstätter: Perfect. Anything else regarding that topic before we move on to the next agenda item?

365
00:51:34.010 --> 00:51:43.960
Toni Wahrstätter: Perfect, then let's move on with, balls and RPC providers. So, Josh from OP Labs, is… joins the call today.

366
00:51:44.110 --> 00:51:49.789
Toni Wahrstätter: Josh, could you give us a quick, intro into what are you trying to achieve there?

367
00:51:51.240 --> 00:51:59.080
Josh | OP Labs: Yeah, thank you. So, the basic context is that many RPC providers, and really anyone who

368
00:51:59.220 --> 00:52:00.879
Josh | OP Labs: Operates a lot of…

369
00:52:01.730 --> 00:52:08.890
Josh | OP Labs: nodes in their infrastructure may not need to re… with VALs, may not need to verify

370
00:52:09.720 --> 00:52:16.480
Josh | OP Labs: the full block, if they can outsource that verification to another node in their infrastructure. So, the idea is that

371
00:52:16.770 --> 00:52:20.910
Josh | OP Labs: Only a single node would actually need to re-execute the transactions at all.

372
00:52:21.050 --> 00:52:27.310
Josh | OP Labs: And the rest can just act as dumb replicas, applying vowels as they receive them.

373
00:52:27.680 --> 00:52:34.410
Josh | OP Labs: As long as they can outsource the verification to this other node. So, you know.

374
00:52:34.990 --> 00:52:45.679
Josh | OP Labs: haven't thought too far about implementation yet, but the idea is that maybe the EL would just have a mode where it would just apply the bowel instead of doing the full re-execution.

375
00:52:45.920 --> 00:52:51.149
Josh | OP Labs: And we were curious if, any Owen Klein teams had.

376
00:52:51.300 --> 00:52:57.970
Josh | OP Labs: thought about this, if there's any, like, hard blockers to this idea that make it infeasible or not useful.

377
00:52:58.310 --> 00:53:04.150
Josh | OP Labs: Yeah, and if this might be considered as something to be implemented in the future.

378
00:53:06.860 --> 00:53:08.160
Josh | OP Labs: Yeah, great question.

379
00:53:08.160 --> 00:53:18.519
Toni Wahrstätter: This is… this is almost like the execution-less, state updates, basically. Not executing, using the bowel to make sure your state is in sync with the… with the chain.

380
00:53:18.790 --> 00:53:24.079
Toni Wahrstätter: I would just forward this to client. Have clients implemented anything around that, or thought of it?

381
00:53:28.370 --> 00:53:33.289
Jared Wasinger: So are you talking about using bowels for, like, sort of, like, a stateless…

382
00:53:33.800 --> 00:53:45.410
Jared Wasinger: Execution? I mean, I guess I'm… I don't fully understand, because you… you need the pre-state to do the execution. The information contained in the bowel alone isn't…

383
00:53:47.560 --> 00:53:48.680
Jared Wasinger: Enough.

384
00:53:53.480 --> 00:53:58.370
Josh | OP Labs: So, perhaps I'm misunderstanding, but…

385
00:53:58.690 --> 00:54:06.030
Josh | OP Labs: the way I understand the ballots, essentially, includes enough information to update the pre-state to the post-state.

386
00:54:06.910 --> 00:54:17.139
Josh | OP Labs: let me know if that's… if that's not correct. But if it does, then I think as long as we can apply the… the bowel, then re-execution shouldn't be necessary.

387
00:54:18.490 --> 00:54:19.630
Jared Wasinger: Yeah, that's correct.

388
00:54:20.810 --> 00:54:26.540
Toni Wahrstätter: Yeah, as I understood, Josh, it's not like… it's not about statelessness, it's more about

389
00:54:26.980 --> 00:54:43.409
Toni Wahrstätter: running a node without executing. Basically, you would outsource execution to another node that you trust. The node will tell you this block is valid, which also means, at this point, you can trust the bul. And at this point, you can then just apply the ball to your

390
00:54:43.550 --> 00:54:55.550
Toni Wahrstätter: pre-state, you get the post state, and you would run a very cheap RPC provider, right? Because you could run an RPC service that doesn't need any execution at all.

391
00:54:56.020 --> 00:55:02.990
Toni Wahrstätter: And this is one of the things you can do with Bulse. We had it, at some point, we discussed it under the optimizations.

392
00:55:04.700 --> 00:55:13.320
Toni Wahrstätter: I guess clients haven't really implemented that yet, but would be curious if… if there is a client team that has thought about it, or might be doing so.

393
00:55:17.190 --> 00:55:22.130
Karim T. (matkt): In Bezoo, we have something, but it's not using block access list, it's using,

394
00:55:22.620 --> 00:55:30.209
Karim T. (matkt): what we have in Bonsai, we have Trilog, it's something similar to Block Access. We… we have the…

395
00:55:30.780 --> 00:55:41.560
Karim T. (matkt): It's a different modification we are doing in a block, and the idea of fleets to have a captain that is executing a block and sending this trailer to followers that are just applying states.

396
00:55:42.030 --> 00:55:45.410
Karim T. (matkt): So it should be something similar to…

397
00:55:45.660 --> 00:55:48.149
Karim T. (matkt): What you want to do is block access list.

398
00:55:52.940 --> 00:55:53.530
Karim T. (matkt): Right.

399
00:55:54.320 --> 00:56:01.249
Toni Wahrstätter: It sounds like it… sounds like you could just plug in block level access list into that workflow, and you're fine.

400
00:56:04.500 --> 00:56:16.800
Karim T. (matkt): I think just in case of a reorg, for example, in Trilog, we have the value before the modification and the value after the modification, like that, if we have a reorg, we just have to

401
00:56:17.650 --> 00:56:36.669
Karim T. (matkt): to roll back the trilog, and if we want just to import any block, we just have to roll forward the trilog, so as it's a B-directional diff, we can roll back and manage the reorg. With block access, we don't have that, so I think if we apply a block assist, we need to be sure that we not have a reorg.

402
00:56:36.890 --> 00:56:42.640
Karim T. (matkt): Because if we have a rug, I think it would be a problem.

403
00:56:44.510 --> 00:56:47.469
Toni Wahrstätter: I see, yeah. I can see that. So…

404
00:56:48.000 --> 00:56:53.700
Toni Wahrstätter: In theory, you would also need to cache somehow the values that were,

405
00:56:53.930 --> 00:56:57.629
Toni Wahrstätter: on state before applying a block-level access list, right?

406
00:56:59.250 --> 00:57:12.939
Karim T. (matkt): I think yes, but regarding how we are working in Bezu, it's needed, maybe those are clients that have different storage formats, maybe it's not important, but for Bezu, it was important to have this value before the modification also.

407
00:57:19.400 --> 00:57:20.110
Toni Wahrstätter: Thank you.

408
00:57:20.900 --> 00:57:26.209
Toni Wahrstätter: Yeah, just relaying what Jared is saying in the chat. Jared is also saying this is very much feasible, and…

409
00:57:26.650 --> 00:57:27.779
Toni Wahrstätter: can be done.

410
00:57:28.350 --> 00:57:33.089
Toni Wahrstätter: Need to be worked out, as it's dangerous for it's not here.

411
00:57:33.330 --> 00:57:49.810
Toni Wahrstätter: It's definitely more feasible for running an RPC service than doing something like this for testers or for validators. It would definitely cut the costs for RPC services, if they don't need to engage in any execution at all.

412
00:57:50.890 --> 00:57:55.069
Toni Wahrstätter: So yeah, definitely something, to keep on our radar.

413
00:57:58.980 --> 00:58:01.050
Josh | OP Labs: Right, thank you, appreciate the feedback.

414
00:58:02.220 --> 00:58:09.509
Jared Wasinger: It's possibly that something that might be worth adding under, like, a protected… more protected…

415
00:58:09.870 --> 00:58:15.060
Jared Wasinger: RPC namespace, maybe, like, admin or something, but yeah, it's…

416
00:58:16.100 --> 00:58:18.610
Jared Wasinger: It's… yeah, it's very straightforward to do this.

417
00:58:21.760 --> 00:58:23.759
Josh | OP Labs: That's very encouraging to hear. Thank you.

418
00:58:30.360 --> 00:58:38.360
Toni Wahrstätter: Great, this was, the last agenda item we had for today. Is there anything else that we should discuss before we wrap up?

419
00:58:41.000 --> 00:59:00.000
Josh | OP Labs: I guess, one last thing on this topic, is there a good place where we can continue this conversation? I know, Jared has already offered the idea of, like, potentially having an RPC method for this sort of thing. What's the best place to continue this discussion to make sure we can get follow-up?

420
00:59:04.860 --> 00:59:11.209
Toni Wahrstätter: I would propose the Block Live Access List Discord channel for that, for now, at least.

421
00:59:12.130 --> 00:59:15.120
Toni Wahrstätter: As soon as we get more concrete, I would,

422
00:59:15.400 --> 00:59:21.379
Toni Wahrstätter: yeah, directly talk with the client teams, how far they are. This is not something that is, like.

423
00:59:21.820 --> 00:59:33.000
Toni Wahrstätter: blocking the EAP from being shipped, so if clients, don't implement it until Amsterdam, nothing bad would happen. But it's definitely one of those optimizations that are very much,

424
00:59:33.160 --> 00:59:37.579
Toni Wahrstätter: That sound like they're very much worth it, and… Are worth to explore.

425
00:59:38.180 --> 00:59:44.769
Toni Wahrstätter: So I would, for now, propose that Box Live Access to this Discord channel, And otherwise,

426
00:59:45.490 --> 00:59:48.590
Toni Wahrstätter: the client's, discord channel.

427
00:59:50.100 --> 00:59:51.530
Josh | OP Labs: Sounds great, thank you.

428
00:59:54.290 --> 01:00:06.379
Toni Wahrstätter: Yeah, and also Banabas had a good idea here with the RPC standard call. So there's also an RPC standardization call that would be also a great venue for those topics. Agree.

429
01:00:07.160 --> 01:00:07.990
Toni Wahrstätter: Thank you.

430
01:00:11.080 --> 01:00:17.899
Toni Wahrstätter: Awesome. Any more comments before we wrap up? Anything I forgot that we should definitely mention?

431
01:00:32.690 --> 01:00:50.519
Toni Wahrstätter: Then, to just quickly summarize, we will, we plan to launch the DevNet 2 on the 21st of January. We will see, as the date approaches, how far we are with the four EAPs that we want to put on top of the block of access list, DEFNET.

432
01:00:50.960 --> 01:00:59.310
Toni Wahrstätter: We will also see how far we are with the batch I.O. optimization. That would be very great, good to have in order to,

433
01:00:59.440 --> 01:01:03.870
Toni Wahrstätter: Yeah, determine if we want to actually keep the state locations in the bar or not.

434
01:01:04.970 --> 01:01:14.010
Toni Wahrstätter: And DEFNET2 will then already include the JSON RPC methods, And also… The…

435
01:01:14.490 --> 01:01:20.960
Toni Wahrstätter: the decoupling of the execution block from the block lab access list, storing the block lab access list separately.

436
01:01:27.980 --> 01:01:28.930
Toni Wahrstätter: Awesome.

437
01:01:29.950 --> 01:01:33.870
Toni Wahrstätter: If there is nothing else, I would say we can wrap up.

438
01:01:34.050 --> 01:01:36.080
Toni Wahrstätter: An integral at this point.

439
01:01:42.900 --> 01:01:43.830
Toni Wahrstätter: Perfect.

440
01:01:43.830 --> 01:01:46.580
Stefan Starflinger: Ben, have a good day, everyone. Thank you very much.

441
01:01:47.380 --> 01:01:48.490
Jared Wasinger: Yep, bye.

442
01:01:49.030 --> 01:01:49.700
Marc: But…

443
01:01:50.210 --> 01:01:51.250
felipe: Alright, thank you.

